solution,filename,slicing_line_number,dynamic_tool,numbered_solution,iteration-1,iteration-1-not-parsed,iteration-2,iteration-2-not-parsed,iteration-3,iteration-3-not-parsed
"	public class AddBoldTag {
	    public String addBoldTag(String s, String[] dict) {
	        int n = s.length();
	        char[] ss = s.toCharArray();
	        int[] imos = new int[n+1];
	        for(String d : dict){
	        	char[] q = d.toCharArray();
	        	int[] kmp = kmpTable(q);
	    		int p = 0;
	    		for(int i = 0;i < ss.length;i++){
	    			while(p >= 0 && q[p] != ss[i])p = kmp[p];
	    			if(++p == q.length){
	    				imos[i-q.length+1]++;
	    				imos[i+1]--;
	    				p = kmp[p];
	    			}
	    		}
	        }
	        for(int i = 0;i < n;i++)imos[i+1] += imos[i];
	        StringBuilder sb = new StringBuilder();
	        StringBuilder temp = new StringBuilder();
	        for(int i = 0;i < n;i++){
	        	if(imos[i] > 0){
	        		temp.append(ss[i]);
	        	}else{
	        		if(temp.length() > 0){
		        		sb.append(""<b>"");
		        		sb.append(temp);
		        		sb.append(""</b>"");
		        		temp = new StringBuilder();
	        		}
	        		sb.append(ss[i]);
	        	}
	        }
    		if(temp.length() > 0){
        		sb.append(""<b>"");
        		sb.append(temp);
        		sb.append(""</b>"");
    		}
    		return sb.toString();
	    }
	    
		public int[] kmpTable(char[] str)
		{
			int n = str.length;
			int[] kmp = new int[n+1];
			kmp[0] = -1; kmp[1] = 0;
			for(int i = 2, j = 0;i <= n;i++){
				while(j > 0 && str[i-1] != str[j])j = kmp[j];
				kmp[i] = str[i-1] == str[j] ? ++j : 0;
			}
			return kmp;
		}
      public static void main(String[] args) {
        String input = ""The quick brown fox jumps over the lazy dog"";
        String[] dict = {""quick"", ""fox"", ""lazy""};

        AddBoldTag instance = new AddBoldTag();
        String result = instance.addBoldTag(input, dict);

        System.out.println(result);
    }
	}	
",AddBoldTag,59,"[56, 58, 1, 59, 3, 4, 5, 6, 7, 8, 45, 46, 47, 48, 50, 49, 52, 9, 10, 11, 12, 13, 14, 19, 20, 21, 22, 23, 32, 24, 26, 27, 28, 29, 30, 35, 40]","1: 	public class AddBoldTag {
2: 	    public String addBoldTag(String s, String[] dict) {
3: 	        int n = s.length();
4: 	        char[] ss = s.toCharArray();
5: 	        int[] imos = new int[n+1];
6: 	        for(String d : dict){
7: 	        	char[] q = d.toCharArray();
8: 	        	int[] kmp = kmpTable(q);
9: 	    		int p = 0;
10: 	    		for(int i = 0;i < ss.length;i++){
11: 	    			while(p >= 0 && q[p] != ss[i])p = kmp[p];
12: 	    			if(++p == q.length){
13: 	    				imos[i-q.length+1]++;
14: 	    				imos[i+1]--;
15: 	    				p = kmp[p];
16: 	    			}
17: 	    		}
18: 	        }
19: 	        for(int i = 0;i < n;i++)imos[i+1] += imos[i];
20: 	        StringBuilder sb = new StringBuilder();
21: 	        StringBuilder temp = new StringBuilder();
22: 	        for(int i = 0;i < n;i++){
23: 	        	if(imos[i] > 0){
24: 	        		temp.append(ss[i]);
25: 	        	}else{
26: 	        		if(temp.length() > 0){
27: 		        		sb.append(""<b>"");
28: 		        		sb.append(temp);
29: 		        		sb.append(""</b>"");
30: 		        		temp = new StringBuilder();
31: 	        		}
32: 	        		sb.append(ss[i]);
33: 	        	}
34: 	        }
35:     		if(temp.length() > 0){
36:         		sb.append(""<b>"");
37:         		sb.append(temp);
38:         		sb.append(""</b>"");
39:     		}
40:     		return sb.toString();
41: 	    }
42: 	    
43: 		public int[] kmpTable(char[] str)
44: 		{
45: 			int n = str.length;
46: 			int[] kmp = new int[n+1];
47: 			kmp[0] = -1; kmp[1] = 0;
48: 			for(int i = 2, j = 0;i <= n;i++){
49: 				while(j > 0 && str[i-1] != str[j])j = kmp[j];
50: 				kmp[i] = str[i-1] == str[j] ? ++j : 0;
51: 			}
52: 			return kmp;
53: 		}
54:       public static void main(String[] args) {
55:         String input = ""The quick brown fox jumps over the lazy dog"";
56:         String[] dict = {""quick"", ""fox"", ""lazy""};
57: 
58:         AddBoldTag instance = new AddBoldTag();
59:         String result = instance.addBoldTag(input, dict);
60: 
61:         System.out.println(result);
62:     }
63: 	}	
64: ","[59, 58, 2, 55, 56, 3, 4, 5, 6, 7, 8, 43, 45, 46, 47, 48, 49, 50, 52, 9, 10, 11, 12, 13, 14, 15, 17, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 32, 34, 35, 36, 37, 38, 39, 40]","{'output': ['59', '58', '2', '55', '56', '3', '4', '5', '6', '7', '8', '43', '45', '46', '47', '48', '49', '50', '52', '9', '10', '11', '12', '13', '14', '15', '17', '19', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '30', '32', '34', '35', '36', '37', '38', '39', '40']}","[59, 58, 2, 55, 56]","{'output': ['59', '58', '2', '55', '56']}","[59, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 17, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 32, 34, 35, 36, 37, 38, 40, 43, 45, 46, 47, 48, 49, 50, 52, 55, 56, 58]","{'output': ['59', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '17', '19', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '30', '32', '34', '35', '36', '37', '38', '40', '43', '45', '46', '47', '48', '49', '50', '52', '55', '56', '58']}"
"import java.util.*;

class AssignBikes {

	private static class Position {
		public int x , y;
		public Position(int x , int y) {
			this.x = x;
			this.y = y;			
		}
	}
	
	private int ans = - 1;	
	private boolean[] vis = new boolean[20];
	
    public int assignBikes(int[][] workers, int[][] bikes) {
    	List<Position> list1 = new ArrayList<>();
    	List<Position> list2 = new ArrayList<>();
    	for (int[] pos : workers) {
    		list1.add(new Position(pos[0] , pos[1]));    		
    	}
    	for (int[] pos : bikes) {
    		list2.add(new Position(pos[0] , pos[1]));
    	}
    	backtracking(list1 , 0 , list2 , 0);    	
    	return ans;
    }    
    
    private int getDist(Position pos1 , Position pos2) {
    	return Math.abs(pos1.x - pos2.x) + Math.abs(pos1.y - pos2.y);
    }
    
    private void backtracking(List<Position> list1 , int current , List<Position> list2 , int dist) {
    	if (current == list1.size()) {
    		if (dist < ans || ans < 0) {
    			ans = dist;    			
    		}    		
    	} else {
    		for (int i = 0;i < list2.size();i ++) {
    			if (!vis[i]) {
    				vis[i] = true;
    				backtracking(list1 , current + 1 , list2 , dist + getDist(list1.get(current) , list2.get(i)));
    				vis[i] = false;
    			}
    		}
    	}    	
    }

	public static void main(String[] args) {
        int[][] workers = {{0, 0}, {2, 1}};
        int[][] bikes = {{1, 2}, {3, 3}};

        AssignBikes assignBikes = new AssignBikes();
        int result = assignBikes.assignBikes(workers, bikes);

        System.out.println(""Minimum Distance: "" + result);
    }
    
}",AssignBikes,54,"[50, 51, 53, 3, 13, 14, 54, 17]","1: import java.util.*;
2: 
3: class AssignBikes {
4: 
5: 	private static class Position {
6: 		public int x , y;
7: 		public Position(int x , int y) {
8: 			this.x = x;
9: 			this.y = y;			
10: 		}
11: 	}
12: 	
13: 	private int ans = - 1;	
14: 	private boolean[] vis = new boolean[20];
15: 	
16:     public int assignBikes(int[][] workers, int[][] bikes) {
17:     	List<Position> list1 = new ArrayList<>();
18:     	List<Position> list2 = new ArrayList<>();
19:     	for (int[] pos : workers) {
20:     		list1.add(new Position(pos[0] , pos[1]));    		
21:     	}
22:     	for (int[] pos : bikes) {
23:     		list2.add(new Position(pos[0] , pos[1]));
24:     	}
25:     	backtracking(list1 , 0 , list2 , 0);    	
26:     	return ans;
27:     }    
28:     
29:     private int getDist(Position pos1 , Position pos2) {
30:     	return Math.abs(pos1.x - pos2.x) + Math.abs(pos1.y - pos2.y);
31:     }
32:     
33:     private void backtracking(List<Position> list1 , int current , List<Position> list2 , int dist) {
34:     	if (current == list1.size()) {
35:     		if (dist < ans || ans < 0) {
36:     			ans = dist;    			
37:     		}    		
38:     	} else {
39:     		for (int i = 0;i < list2.size();i ++) {
40:     			if (!vis[i]) {
41:     				vis[i] = true;
42:     				backtracking(list1 , current + 1 , list2 , dist + getDist(list1.get(current) , list2.get(i)));
43:     				vis[i] = false;
44:     			}
45:     		}
46:     	}    	
47:     }
48: 
49: 	public static void main(String[] args) {
50:         int[][] workers = {{0, 0}, {2, 1}};
51:         int[][] bikes = {{1, 2}, {3, 3}};
52: 
53:         AssignBikes assignBikes = new AssignBikes();
54:         int result = assignBikes.assignBikes(workers, bikes);
55: 
56:         System.out.println(""Minimum Distance: "" + result);
57:     }
58:     
59: }","[54, 53, 50, 51, 16, 17, 18, 19, 20, 22, 23, 25, 33, 39, 40, 41, 42, 29, 30, 43, 34, 35, 36, 26]","{'output': ['54', '53', '50', '51', '16', '17', '18', '19', '20', '22', '23', '25', '33', '39', '40', '41', '42', '29', '30', '43', '34', '35', '36', '26']}","[54, 53, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 13]","{'output': ['54', '53', '26', '25', '24', '23', '22', '21', '20', '19', '18', '17', '16', '13']}","[54, 53, 16, 25, 26, 35, 36]","{'output': ['54', '53', '16', '25', '26', '35', '36']}"
"import java.util.*;

	class AsteroidCollision {
	    public int[] asteroidCollision(int[] as) {
	        int n = as.length;
	        LST lst = new LST(n);
	        lst.setRange(n);
	        Queue<Integer> q = new ArrayDeque<>();
	        for(int i = 0;i < n-1;i++){
	        	if(as[i] > 0 && as[i+1] < 0){
	        		q.add(i);
	        	}
	        }
	        while(!q.isEmpty()){
	        	int cur = q.poll();
	        	int l = lst.prev(cur);
	        	int r = lst.next(cur+1);
	        	if(l != -1 && r != -1 &&
	        			as[l] > 0 && as[r] < 0
	        			){
	        		boolean ch = false;
	        		if(Math.abs(as[l]) >= Math.abs(as[r])){
	        			lst.unset(r);
	        			ch = true;
	        		}
	        		if(Math.abs(as[r]) >= Math.abs(as[l])){
	        			lst.unset(l);
	        			ch = true;
	        		}
	        		if(ch){
	        			q.add(cur);
	        		}
	        	}
	        }
	        int[] ret = new int[n];
	        int p = 0;
	        for(int i = lst.next(0);i != -1;lst.unset(i), i = lst.next(0)){
	        	ret[p++] = as[i];
	        }
	        return Arrays.copyOf(ret, p);
	    }
	    
	    class LST {
	    	public long[][] set;
	    	public int n;
//	    	public int size;
	    	
	    	public LST(int n) {
	    		this.n = n;
	    		int d = 1;
	    		for(int m = n;m > 1;m>>>=6, d++);
	    		
	    		set = new long[d][];
	    		for(int i = 0, m = n>>>6;i < d;i++, m>>>=6){
	    			set[i] = new long[m+1];
	    		}
//	    		size = 0;
	    	}
	    	
	    	// [0,r)
	    	public LST setRange(int r)
	    	{
	    		for(int i = 0;i < set.length;i++, r=r+63>>>6){
	    			for(int j = 0;j < r>>>6;j++){
	    				set[i][j] = -1L;
	    			}
	    			if((r&63) != 0)set[i][r>>>6] |= (1L<<r)-1;
	    		}
	    		return this;
	    	}
	    	
	    	// [0,r)
	    	public LST unsetRange(int r)
	    	{
	    		if(r >= 0){
	    			for(int i = 0;i < set.length;i++, r=r+63>>>6){
	    				for(int j = 0;j < r+63>>>6;j++){
	    					set[i][j] = 0;
	    				}
	    				if((r&63) != 0)set[i][r>>>6] &= ~((1L<<r)-1);
	    			}
	    		}
	    		return this;
	    	}
	    	
	    	public LST set(int pos)
	    	{
	    		if(pos >= 0 && pos < n){
//	    			if(!get(pos))size++;
	    			for(int i = 0;i < set.length;i++, pos>>>=6){
	    				set[i][pos>>>6] |= 1L<<pos;
	    			}
	    		}
	    		return this;
	    	}
	    	
	    	public LST unset(int pos)
	    	{
	    		if(pos >= 0 && pos < n){
//	    			if(get(pos))size--;
	    			for(int i = 0;i < set.length && (i == 0 || set[i-1][pos] == 0L);i++, pos>>>=6){
	    				set[i][pos>>>6] &= ~(1L<<pos);
	    			}
	    		}
	    		return this;
	    	}
	    	
	    	public boolean get(int pos)
	    	{
	    		return pos >= 0 && pos < n && set[0][pos>>>6]<<~pos<0;
	    	}
	    	
	    	public int prev(int pos)
	    	{
	    		for(int i = 0;i < set.length && pos >= 0;i++, pos>>>=6, pos--){
	    			int pre = prev(set[i][pos>>>6], pos&63);
	    			if(pre != -1){
	    				pos = pos>>>6<<6|pre;
	    				while(i > 0)pos = pos<<6|63-Long.numberOfLeadingZeros(set[--i][pos]);
	    				return pos;
	    			}
	    		}
	    		return -1;
	    	}
	    	
	    	public int next(int pos)
	    	{
	    		for(int i = 0;i < set.length && pos>>>6 < set[i].length;i++, pos>>>=6, pos++){
	    			int nex = next(set[i][pos>>>6], pos&63);
	    			if(nex != -1){
	    				pos = pos>>>6<<6|nex;
	    				while(i > 0)pos = pos<<6|Long.numberOfTrailingZeros(set[--i][pos]);
	    				return pos;
	    			}
	    		}
	    		return -1;
	    	}
	    	
	    	private int prev(long set, int n)
	    	{
	    		long h = Long.highestOneBit(set<<~n);
	    		if(h == 0L)return -1;
	    		return Long.numberOfTrailingZeros(h)-(63-n);
	    	}
	    	
	    	private int next(long set, int n)
	    	{
	    		long h = Long.lowestOneBit(set>>>n);
	    		if(h == 0L)return -1;
	    		return Long.numberOfTrailingZeros(h)+n;
	    	}
	    	
	    	@Override
	    	public String toString()
	    	{
	    		List<Integer> list = new ArrayList<Integer>();
	    		for(int pos = next(0);pos != -1;pos = next(pos+1)){
	    			list.add(pos);
	    		}
	    		return list.toString();
	    	}
	    }
    public static void main(String[] args) {
        int[] asteroids = {5, 10, -5};
        AsteroidCollision collision = new AsteroidCollision();
        int[] result = collision.asteroidCollision(asteroids);
        System.out.println(Arrays.toString(result));
    }
	
	}	
",AsteroidCollision,166,"[164, 165, 3, 166, 5]","1: import java.util.*;
2: 
3: 	class AsteroidCollision {
4: 	    public int[] asteroidCollision(int[] as) {
5: 	        int n = as.length;
6: 	        LST lst = new LST(n);
7: 	        lst.setRange(n);
8: 	        Queue<Integer> q = new ArrayDeque<>();
9: 	        for(int i = 0;i < n-1;i++){
10: 	        	if(as[i] > 0 && as[i+1] < 0){
11: 	        		q.add(i);
12: 	        	}
13: 	        }
14: 	        while(!q.isEmpty()){
15: 	        	int cur = q.poll();
16: 	        	int l = lst.prev(cur);
17: 	        	int r = lst.next(cur+1);
18: 	        	if(l != -1 && r != -1 &&
19: 	        			as[l] > 0 && as[r] < 0
20: 	        			){
21: 	        		boolean ch = false;
22: 	        		if(Math.abs(as[l]) >= Math.abs(as[r])){
23: 	        			lst.unset(r);
24: 	        			ch = true;
25: 	        		}
26: 	        		if(Math.abs(as[r]) >= Math.abs(as[l])){
27: 	        			lst.unset(l);
28: 	        			ch = true;
29: 	        		}
30: 	        		if(ch){
31: 	        			q.add(cur);
32: 	        		}
33: 	        	}
34: 	        }
35: 	        int[] ret = new int[n];
36: 	        int p = 0;
37: 	        for(int i = lst.next(0);i != -1;lst.unset(i), i = lst.next(0)){
38: 	        	ret[p++] = as[i];
39: 	        }
40: 	        return Arrays.copyOf(ret, p);
41: 	    }
42: 	    
43: 	    class LST {
44: 	    	public long[][] set;
45: 	    	public int n;
46: //	    	public int size;
47: 	    	
48: 	    	public LST(int n) {
49: 	    		this.n = n;
50: 	    		int d = 1;
51: 	    		for(int m = n;m > 1;m>>>=6, d++);
52: 	    		
53: 	    		set = new long[d][];
54: 	    		for(int i = 0, m = n>>>6;i < d;i++, m>>>=6){
55: 	    			set[i] = new long[m+1];
56: 	    		}
57: //	    		size = 0;
58: 	    	}
59: 	    	
60: 	    	// [0,r)
61: 	    	public LST setRange(int r)
62: 	    	{
63: 	    		for(int i = 0;i < set.length;i++, r=r+63>>>6){
64: 	    			for(int j = 0;j < r>>>6;j++){
65: 	    				set[i][j] = -1L;
66: 	    			}
67: 	    			if((r&63) != 0)set[i][r>>>6] |= (1L<<r)-1;
68: 	    		}
69: 	    		return this;
70: 	    	}
71: 	    	
72: 	    	// [0,r)
73: 	    	public LST unsetRange(int r)
74: 	    	{
75: 	    		if(r >= 0){
76: 	    			for(int i = 0;i < set.length;i++, r=r+63>>>6){
77: 	    				for(int j = 0;j < r+63>>>6;j++){
78: 	    					set[i][j] = 0;
79: 	    				}
80: 	    				if((r&63) != 0)set[i][r>>>6] &= ~((1L<<r)-1);
81: 	    			}
82: 	    		}
83: 	    		return this;
84: 	    	}
85: 	    	
86: 	    	public LST set(int pos)
87: 	    	{
88: 	    		if(pos >= 0 && pos < n){
89: //	    			if(!get(pos))size++;
90: 	    			for(int i = 0;i < set.length;i++, pos>>>=6){
91: 	    				set[i][pos>>>6] |= 1L<<pos;
92: 	    			}
93: 	    		}
94: 	    		return this;
95: 	    	}
96: 	    	
97: 	    	public LST unset(int pos)
98: 	    	{
99: 	    		if(pos >= 0 && pos < n){
100: //	    			if(get(pos))size--;
101: 	    			for(int i = 0;i < set.length && (i == 0 || set[i-1][pos] == 0L);i++, pos>>>=6){
102: 	    				set[i][pos>>>6] &= ~(1L<<pos);
103: 	    			}
104: 	    		}
105: 	    		return this;
106: 	    	}
107: 	    	
108: 	    	public boolean get(int pos)
109: 	    	{
110: 	    		return pos >= 0 && pos < n && set[0][pos>>>6]<<~pos<0;
111: 	    	}
112: 	    	
113: 	    	public int prev(int pos)
114: 	    	{
115: 	    		for(int i = 0;i < set.length && pos >= 0;i++, pos>>>=6, pos--){
116: 	    			int pre = prev(set[i][pos>>>6], pos&63);
117: 	    			if(pre != -1){
118: 	    				pos = pos>>>6<<6|pre;
119: 	    				while(i > 0)pos = pos<<6|63-Long.numberOfLeadingZeros(set[--i][pos]);
120: 	    				return pos;
121: 	    			}
122: 	    		}
123: 	    		return -1;
124: 	    	}
125: 	    	
126: 	    	public int next(int pos)
127: 	    	{
128: 	    		for(int i = 0;i < set.length && pos>>>6 < set[i].length;i++, pos>>>=6, pos++){
129: 	    			int nex = next(set[i][pos>>>6], pos&63);
130: 	    			if(nex != -1){
131: 	    				pos = pos>>>6<<6|nex;
132: 	    				while(i > 0)pos = pos<<6|Long.numberOfTrailingZeros(set[--i][pos]);
133: 	    				return pos;
134: 	    			}
135: 	    		}
136: 	    		return -1;
137: 	    	}
138: 	    	
139: 	    	private int prev(long set, int n)
140: 	    	{
141: 	    		long h = Long.highestOneBit(set<<~n);
142: 	    		if(h == 0L)return -1;
143: 	    		return Long.numberOfTrailingZeros(h)-(63-n);
144: 	    	}
145: 	    	
146: 	    	private int next(long set, int n)
147: 	    	{
148: 	    		long h = Long.lowestOneBit(set>>>n);
149: 	    		if(h == 0L)return -1;
150: 	    		return Long.numberOfTrailingZeros(h)+n;
151: 	    	}
152: 	    	
153: 	    	@Override
154: 	    	public String toString()
155: 	    	{
156: 	    		List<Integer> list = new ArrayList<Integer>();
157: 	    		for(int pos = next(0);pos != -1;pos = next(pos+1)){
158: 	    			list.add(pos);
159: 	    		}
160: 	    		return list.toString();
161: 	    	}
162: 	    }
163:     public static void main(String[] args) {
164:         int[] asteroids = {5, 10, -5};
165:         AsteroidCollision collision = new AsteroidCollision();
166:         int[] result = collision.asteroidCollision(asteroids);
167:         System.out.println(Arrays.toString(result));
168:     }
169: 	
170: 	}	
171: ","[166, 164, 165, 4, 5, 6, 7, 8, 9, 10, 11, 14, 15, 16, 17, 18, 19, 22, 23, 26, 27, 30, 31, 35, 36, 37, 38, 40]","{'output': ['166', '164', '165', '4', '5', '6', '7', '8', '9', '10', '11', '14', '15', '16', '17', '18', '19', '22', '23', '26', '27', '30', '31', '35', '36', '37', '38', '40']}","[166, 164, 4, 5, 6, 7, 8, 9, 10, 11, 14, 15, 16, 17, 18, 19, 22, 23, 26, 27, 30, 31, 35, 36, 37, 38, 40]","{'output': ['166', '164', '4', '5', '6', '7', '8', '9', '10', '11', '14', '15', '16', '17', '18', '19', '22', '23', '26', '27', '30', '31', '35', '36', '37', '38', '40']}","[166, 165, 164, 4, 9, 10, 11, 14, 15, 16, 17, 18, 19, 22, 23, 26, 27, 31, 35, 36, 37, 38, 40]","{'output': ['166', '165', '164', '4', '9', '10', '11', '14', '15', '16', '17', '18', '19', '22', '23', '26', '27', '31', '35', '36', '37', '38', '40']}"
"class BestRotation {
    public int bestRotation(int[] A) {
        int[] scoreIncrease = new int[A.length + 1];
        for (int i = 0; i < A.length; i++) {
            int v = A[i];
            if (i - v >= 0) {
                scoreIncrease[0]++;
                scoreIncrease[i - v + 1]--;
            }
            scoreIncrease[i + 1]++;
            if (i + A.length - v + 1 <= A.length) scoreIncrease[i + A.length - v + 1]--;
        }
        int maxScore = 0;
        int bestK = 0;
        int K = -1;
        int score = 0;
        while (K < A.length) {
            K++;
            score += scoreIncrease[K];
            if (score > maxScore) {
                maxScore = score;
                bestK = K;
            }
        }
        return bestK;
    }

    public static void main(String[] args) {
        int[] A = {2, 3, 1, 4, 0};
        BestRotation br = new BestRotation();
        int result = br.bestRotation(A);
        System.out.println(""Best Rotation K: "" + result);
    }

}",BestRotation,31,"[29, 30, 1, 31, 15, 17, 18, 22, 25]","1: class BestRotation {
2:     public int bestRotation(int[] A) {
3:         int[] scoreIncrease = new int[A.length + 1];
4:         for (int i = 0; i < A.length; i++) {
5:             int v = A[i];
6:             if (i - v >= 0) {
7:                 scoreIncrease[0]++;
8:                 scoreIncrease[i - v + 1]--;
9:             }
10:             scoreIncrease[i + 1]++;
11:             if (i + A.length - v + 1 <= A.length) scoreIncrease[i + A.length - v + 1]--;
12:         }
13:         int maxScore = 0;
14:         int bestK = 0;
15:         int K = -1;
16:         int score = 0;
17:         while (K < A.length) {
18:             K++;
19:             score += scoreIncrease[K];
20:             if (score > maxScore) {
21:                 maxScore = score;
22:                 bestK = K;
23:             }
24:         }
25:         return bestK;
26:     }
27: 
28:     public static void main(String[] args) {
29:         int[] A = {2, 3, 1, 4, 0};
30:         BestRotation br = new BestRotation();
31:         int result = br.bestRotation(A);
32:         System.out.println(""Best Rotation K: "" + result);
33:     }
34: 
35: }","[31, 2, 3, 4, 5, 6, 7, 8, 10, 11, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 24, 25]","{'output': ['31', '2', '3', '4', '5', '6', '7', '8', '10', '11', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '24', '25']}","[31, 2, 3, 4, 5, 6, 7, 8, 10, 11, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 24, 25]","{'output': ['31', '2', '3', '4', '5', '6', '7', '8', '10', '11', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '24', '25']}","[31, 2, 3, 4, 5, 6, 7, 8, 10, 11, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 24, 25, 29, 30]","{'output': ['31', '2', '3', '4', '5', '6', '7', '8', '10', '11', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '24', '25', '29', '30']}"
"import java.util.*;

/**
 * Definition for a binary tree node.
 *  */
 public class TreeNode {
      int val;
     TreeNode left;
      TreeNode right;
     TreeNode(int x) { this.val = x; }
        public static void main(String[] args) {
        // Create a sample binary tree
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(2);
        root.right = new TreeNode(3);
        root.left.left = new TreeNode(4);
        root.left.right = new TreeNode(5);
        root.right.left = new TreeNode(6);

        // Initialize CBTInserter with the sample tree
        CBTInserter obj = new CBTInserter(root);

        // Insert new nodes and print the parent's value
        System.out.println(""Parent node after inserting 7: "" + obj.insert(7));  // Should insert 7 as the right child of node 3
        System.out.println(""Parent node after inserting 8: "" + obj.insert(8));  // Should insert 8 as the left child of node 4

        // Get the root of the tree and print its structure
        TreeNode updatedRoot = obj.get_root();
        printTree(updatedRoot);
    }

    // Helper method to print the tree structure
    public static void printTree(TreeNode root) {
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            System.out.print(node.val + "" "");
            if (node.left != null) queue.add(node.left);
            if (node.right != null) queue.add(node.right);
        }
        System.out.println();
    }
  }



class CBTInserter {
    TreeNode root;
    int cnt;
    private int calc(TreeNode root) {
        if (root == null) {
            return 0;
        }
        return calc(root.left) + calc(root.right) + 1;
    }
    public CBTInserter(TreeNode root) {
        this.root = root;
        cnt = calc(root);
    }
    
    public int insert(int v) {
        int cur = ++cnt;
        int ipos = 31;
        while ((cur & (1 << ipos)) == 0) {
            ipos--;
        }
        ipos--;
        TreeNode curNode = root;
        while (ipos > 0) {
            if ((cur & (1 << ipos)) == 0) {
                curNode = curNode.left;
            } else {
                curNode = curNode.right;
            }
            ipos--;
        }
        if ((cur & (1 << ipos)) == 0) {
            curNode.left = new TreeNode(v);
        } else {
            curNode.right = new TreeNode(v);
        }
        return curNode.val;
    }
    
    public TreeNode get_root() {
        return root;
    }
   
}

/**
 * Your CBTInserter object will be instantiated and called as such:
 * CBTInserter obj = new CBTInserter(root);
 * int param_1 = obj.insert(v);
 * TreeNode param_2 = obj.get_root();
 */",Calc,78,"[62, 64, 73, 53, 74, 78]","1: import java.util.*;
2: 
3: /**
4:  * Definition for a binary tree node.
5:  *  */
6:  public class TreeNode {
7:       int val;
8:      TreeNode left;
9:       TreeNode right;
10:      TreeNode(int x) { this.val = x; }
11:         public static void main(String[] args) {
12:         // Create a sample binary tree
13:         TreeNode root = new TreeNode(1);
14:         root.left = new TreeNode(2);
15:         root.right = new TreeNode(3);
16:         root.left.left = new TreeNode(4);
17:         root.left.right = new TreeNode(5);
18:         root.right.left = new TreeNode(6);
19: 
20:         // Initialize CBTInserter with the sample tree
21:         CBTInserter obj = new CBTInserter(root);
22: 
23:         // Insert new nodes and print the parent's value
24:         System.out.println(""Parent node after inserting 7: "" + obj.insert(7));  // Should insert 7 as the right child of node 3
25:         System.out.println(""Parent node after inserting 8: "" + obj.insert(8));  // Should insert 8 as the left child of node 4
26: 
27:         // Get the root of the tree and print its structure
28:         TreeNode updatedRoot = obj.get_root();
29:         printTree(updatedRoot);
30:     }
31: 
32:     // Helper method to print the tree structure
33:     public static void printTree(TreeNode root) {
34:         Queue<TreeNode> queue = new LinkedList<>();
35:         queue.add(root);
36:         while (!queue.isEmpty()) {
37:             TreeNode node = queue.poll();
38:             System.out.print(node.val + "" "");
39:             if (node.left != null) queue.add(node.left);
40:             if (node.right != null) queue.add(node.right);
41:         }
42:         System.out.println();
43:     }
44:   }
45: 
46: 
47: 
48: class CBTInserter {
49:     TreeNode root;
50:     int cnt;
51:     private int calc(TreeNode root) {
52:         if (root == null) {
53:             return 0;
54:         }
55:         return calc(root.left) + calc(root.right) + 1;
56:     }
57:     public CBTInserter(TreeNode root) {
58:         this.root = root;
59:         cnt = calc(root);
60:     }
61:     
62:     public int insert(int v) {
63:         int cur = ++cnt;
64:         int ipos = 31;
65:         while ((cur & (1 << ipos)) == 0) {
66:             ipos--;
67:         }
68:         ipos--;
69:         TreeNode curNode = root;
70:         while (ipos > 0) {
71:             if ((cur & (1 << ipos)) == 0) {
72:                 curNode = curNode.left;
73:             } else {
74:                 curNode = curNode.right;
75:             }
76:             ipos--;
77:         }
78:         if ((cur & (1 << ipos)) == 0) {
79:             curNode.left = new TreeNode(v);
80:         } else {
81:             curNode.right = new TreeNode(v);
82:         }
83:         return curNode.val;
84:     }
85:     
86:     public TreeNode get_root() {
87:         return root;
88:     }
89:    
90: }
91: 
92: /**
93:  * Your CBTInserter object will be instantiated and called as such:
94:  * CBTInserter obj = new CBTInserter(root);
95:  * int param_1 = obj.insert(v);
96:  * TreeNode param_2 = obj.get_root();
97:  */","[78, 77, 76, 75, 74, 73, 72, 71, 70, 69, 68, 67, 66, 65, 64, 63, 50, 49, 48]","{'output': ['78', '77', '76', '75', '74', '73', '72', '71', '70', '69', '68', '67', '66', '65', '64', '63', '50', '49', '48']}","[78, 63, 62, 59, 58, 57, 21, 20]","{'output': ['78', '63', '62', '59', '58', '57', '21', '20']}","[78, 77, 76, 75, 74, 73, 72, 71, 70, 69, 68, 67, 66, 65, 64, 63, 62, 59, 58, 57, 51, 50, 49, 21, 13]","{'output': ['78', '77', '76', '75', '74', '73', '72', '71', '70', '69', '68', '67', '66', '65', '64', '63', '62', '59', '58', '57', '51', '50', '49', '21', '13']}"
"class Can {
    public boolean can(int[] weights, int D, int cap) {
        int cd = 0;
        int ans = 1;
        for (int i = 0; i < weights.length; i++) {
            if (cd + weights[i] > cap) {
                ans++;
                cd = 0;
            }
            cd += weights[i];
        }
        return ans <= D;
    }
    public int shipWithinDays(int[] weights, int D) {
        int lo = weights[0], hi = 0;
        for (int i = 0; i < weights.length; i++) {
            lo = Math.max(weights[i], lo);
            hi += weights[i];
        }
        while (lo < hi) {
            int mid = (hi+lo)/2;
            if (can(weights, D, mid)) hi = mid;
            else lo = mid+1;
        }
        return lo;
    }
     public static void main(String[] args) {
        int[] weights = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        int D = 5;
        Can canInstance = new Can();
        int result = canInstance.shipWithinDays(weights, D);
        System.out.println(""Minimum capacity needed to ship within "" + D + "" days: "" + result);
    }
}",Can,31,"[28, 30, 1, 31, 15, 16, 17, 18, 20, 21, 22, 3, 4, 5, 10, 6, 7, 12, 8, 23, 25]","1: class Can {
2:     public boolean can(int[] weights, int D, int cap) {
3:         int cd = 0;
4:         int ans = 1;
5:         for (int i = 0; i < weights.length; i++) {
6:             if (cd + weights[i] > cap) {
7:                 ans++;
8:                 cd = 0;
9:             }
10:             cd += weights[i];
11:         }
12:         return ans <= D;
13:     }
14:     public int shipWithinDays(int[] weights, int D) {
15:         int lo = weights[0], hi = 0;
16:         for (int i = 0; i < weights.length; i++) {
17:             lo = Math.max(weights[i], lo);
18:             hi += weights[i];
19:         }
20:         while (lo < hi) {
21:             int mid = (hi+lo)/2;
22:             if (can(weights, D, mid)) hi = mid;
23:             else lo = mid+1;
24:         }
25:         return lo;
26:     }
27:      public static void main(String[] args) {
28:         int[] weights = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
29:         int D = 5;
30:         Can canInstance = new Can();
31:         int result = canInstance.shipWithinDays(weights, D);
32:         System.out.println(""Minimum capacity needed to ship within "" + D + "" days: "" + result);
33:     }
34: }","[31, 30, 28, 29, 25, 24, 22, 21, 20, 15, 16, 17, 18]","{'output': ['31', '30', '28', '29', '25', '24', '22', '21', '20', '15', '16', '17', '18']}","[31, 30, 14, 15, 16, 17, 18, 20, 21, 22, 23, 25]","{'output': ['31', '30', '14', '15', '16', '17', '18', '20', '21', '22', '23', '25']}","[31, 30, 28, 29, 14, 15, 16, 17, 18, 20, 21, 22, 23, 25, 2, 3, 4, 5, 6, 7, 8, 10, 12]","{'output': ['31', '30', '28', '29', '14', '15', '16', '17', '18', '20', '21', '22', '23', '25', '2', '3', '4', '5', '6', '7', '8', '10', '12']}"
"	class CanTransform {
	    public boolean canTransform(String start, String end) {
	    	if(!start.replace(""X"", """").equals(end.replace(""X"", """")))return false;
	    	int n = start.length();
	    	int p = 0;
	    	for(int i = 0;i < n;i++){
	    		if(start.charAt(i) != 'X'){
	    			while(p < n && end.charAt(p) == 'X'){
	    				p++;
	    			}
	    			if(start.charAt(i) == 'R'){
	    				if(i > p)return false;
	    			}else{
	    				if(i < p)return false;
	    			}
	    			p++;
	    		}
	    	}
	    	return true;
	    }
		public static void main(String[] args) {
			String start = ""RXXLRXRXL"";
			String end = ""XRLXXRRLX"";
			
			CanTransform canTransformInstance = new CanTransform();
			boolean result = canTransformInstance.canTransform(start, end);
			
			System.out.println(""Can transform: "" + result);
    }
	}	
",CanTransform,26,"[25, 1, 26, 3, 4, 5, 6, 7, 8, 9, 11, 12, 16, 14, 19]","1: 	class CanTransform {
2: 	    public boolean canTransform(String start, String end) {
3: 	    	if(!start.replace(""X"", """").equals(end.replace(""X"", """")))return false;
4: 	    	int n = start.length();
5: 	    	int p = 0;
6: 	    	for(int i = 0;i < n;i++){
7: 	    		if(start.charAt(i) != 'X'){
8: 	    			while(p < n && end.charAt(p) == 'X'){
9: 	    				p++;
10: 	    			}
11: 	    			if(start.charAt(i) == 'R'){
12: 	    				if(i > p)return false;
13: 	    			}else{
14: 	    				if(i < p)return false;
15: 	    			}
16: 	    			p++;
17: 	    		}
18: 	    	}
19: 	    	return true;
20: 	    }
21: 		public static void main(String[] args) {
22: 			String start = ""RXXLRXRXL"";
23: 			String end = ""XRLXXRRLX"";
24: 			
25: 			CanTransform canTransformInstance = new CanTransform();
26: 			boolean result = canTransformInstance.canTransform(start, end);
27: 			
28: 			System.out.println(""Can transform: "" + result);
29:     }
30: 	}	
31: ","[26, 25, 22, 23]","{'output': ['26', '25', '22', '23']}","[26, 25, 22, 23, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 18, 19]","{'output': ['26', '25', '22', '23', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '18', '19']}","[26, 25, 22, 23]","{'output': ['26', '25', '22', '23']}"
"import java.util.*;

public class CanTraverseAllPairs {
    public boolean canTraverseAllPairs(int[] arr) {
        int N = arr.length;
        boolean[] has = new boolean[1<<17];
        int MAX = 100000;
        for(int x: arr)
            has[x] = true;
        if(N == 1)
            return true;
        if(has[1])
            return false;
        DSU union = new DSU(2*MAX+1);
        for(int d=2; d <= MAX; d++)
        {
            int root = d+MAX;
            for(int v=d; v <= MAX; v+=d)
                if(has[v])
                    union.merge(root, v);
        }
        HashSet<Integer> comps = new HashSet<Integer>();
        for(int i=2; i <= MAX; i++)
            if(has[i])
                comps.add(union.find(i));
        return comps.size() == 1;
    }
    public static void main(String[] args) {
        int[] arr = {2, 3, 6, 12, 18};
        CanTraverseAllPairs canTraverseAllPairs = new CanTraverseAllPairs();
        boolean result = canTraverseAllPairs.canTraverseAllPairs(arr);
        System.out.println(""Can traverse all pairs: "" + result);
    }
}
class DSU
{
    public int[] dsu;

    public DSU(int N)
    {
        dsu = new int[N+1];
        for(int i=0; i <= N; i++)
        {
            dsu[i] = i;
        }
    }
    //with path compression, no find by rank
    public int find(int x)
    {
        return dsu[x] == x ? x : (dsu[x] = find(dsu[x]));
    }
    public void merge(int x, int y)
    {
        int fx = find(x);
        int fy = find(y);
        if(fx == fy)
            return;
        dsu[fx] = fy;
    }
}",CanTraverseAllPairs,31,"[29, 30, 3, 31, 5]","1: import java.util.*;
2: 
3: public class CanTraverseAllPairs {
4:     public boolean canTraverseAllPairs(int[] arr) {
5:         int N = arr.length;
6:         boolean[] has = new boolean[1<<17];
7:         int MAX = 100000;
8:         for(int x: arr)
9:             has[x] = true;
10:         if(N == 1)
11:             return true;
12:         if(has[1])
13:             return false;
14:         DSU union = new DSU(2*MAX+1);
15:         for(int d=2; d <= MAX; d++)
16:         {
17:             int root = d+MAX;
18:             for(int v=d; v <= MAX; v+=d)
19:                 if(has[v])
20:                     union.merge(root, v);
21:         }
22:         HashSet<Integer> comps = new HashSet<Integer>();
23:         for(int i=2; i <= MAX; i++)
24:             if(has[i])
25:                 comps.add(union.find(i));
26:         return comps.size() == 1;
27:     }
28:     public static void main(String[] args) {
29:         int[] arr = {2, 3, 6, 12, 18};
30:         CanTraverseAllPairs canTraverseAllPairs = new CanTraverseAllPairs();
31:         boolean result = canTraverseAllPairs.canTraverseAllPairs(arr);
32:         System.out.println(""Can traverse all pairs: "" + result);
33:     }
34: }
35: class DSU
36: {
37:     public int[] dsu;
38: 
39:     public DSU(int N)
40:     {
41:         dsu = new int[N+1];
42:         for(int i=0; i <= N; i++)
43:         {
44:             dsu[i] = i;
45:         }
46:     }
47:     //with path compression, no find by rank
48:     public int find(int x)
49:     {
50:         return dsu[x] == x ? x : (dsu[x] = find(dsu[x]));
51:     }
52:     public void merge(int x, int y)
53:     {
54:         int fx = find(x);
55:         int fy = find(y);
56:         if(fx == fy)
57:             return;
58:         dsu[fx] = fy;
59:     }
60: }","[31, 30, 4, 5, 6, 8, 9, 10, 11, 12, 13, 14, 15, 17, 18, 19, 20, 22, 23, 24, 25, 26]","{'output': ['31', '30', '4', '5', '6', '8', '9', '10', '11', '12', '13', '14', '15', '17', '18', '19', '20', '22', '23', '24', '25', '26']}","[31, 30, 4, 5, 6, 7, 8, 9, 10, 12, 14, 15, 17, 18, 19, 20, 22, 23, 24, 25, 26]","{'output': ['31', '30', '4', '5', '6', '7', '8', '9', '10', '12', '14', '15', '17', '18', '19', '20', '22', '23', '24', '25', '26']}","[31, 4, 5, 6, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 22, 23, 24, 25, 26]","{'output': ['31', '4', '5', '6', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '22', '23', '24', '25', '26']}"
"	class ConcatenatedBinary {
		public int concatenatedBinary(int n) {
			int t = 2;
			final int mod = 1000000007;
			long ret = 0;
			for(int i = 1;i <= n;i++){
				if(i == t){
					t *= 2;
				}
				ret = ret * t + i;
				ret %= mod;
			}
			return (int)ret;
		}
		public static void main(String[] args) {
			int n = 12; // Example input
			ConcatenatedBinary concatenatedBinary = new ConcatenatedBinary();
			int result = concatenatedBinary.concatenatedBinary(n);
			System.out.println(""Concatenated Binary result for n = "" + n + "" is: "" + result);
   	 }
	}
",ConcatenatedBinary,18,"[17, 1, 18, 3, 5, 6, 10, 11, 7, 8, 13]","1: 	class ConcatenatedBinary {
2: 		public int concatenatedBinary(int n) {
3: 			int t = 2;
4: 			final int mod = 1000000007;
5: 			long ret = 0;
6: 			for(int i = 1;i <= n;i++){
7: 				if(i == t){
8: 					t *= 2;
9: 				}
10: 				ret = ret * t + i;
11: 				ret %= mod;
12: 			}
13: 			return (int)ret;
14: 		}
15: 		public static void main(String[] args) {
16: 			int n = 12; // Example input
17: 			ConcatenatedBinary concatenatedBinary = new ConcatenatedBinary();
18: 			int result = concatenatedBinary.concatenatedBinary(n);
19: 			System.out.println(""Concatenated Binary result for n = "" + n + "" is: "" + result);
20:    	 }
21: 	}
22: ","[18, 16, 2, 6, 10, 11, 13]","{'output': ['18', '16', '2', '6', '10', '11', '13']}","[18, 16, 2, 6, 7, 8, 10, 11, 13]","{'output': ['18', '16', '2', '6', '7', '8', '10', '11', '13']}","[18, 16, 2, 6, 7, 8, 10, 11, 13]","{'output': ['18', '16', '2', '6', '7', '8', '10', '11', '13']}"
"	import java.util.*;
	class ConnectSticks {
	    public int connectSticks(int[] sticks) {
	        PriorityQueue<Integer> pq = new PriorityQueue<>();
	        for(int v : sticks){
	        	pq.add(v);
	        }
	        int ans = 0;
	        while(pq.size() > 1){
	        	int x = pq.poll();
	        	int y = pq.poll();
	        	ans += x + y;
	        	pq.add(x+y);
	        }
	        return ans;
	    }
		public static void main(String[] args) {
			int[] sticks = {2, 4, 3}; // Example input
			ConnectSticks connectSticks = new ConnectSticks();
			int result = connectSticks.connectSticks(sticks);
			System.out.println(""Minimum cost to connect sticks: "" + result);
   	 }
	}	
",ConnectSticks,20,"[18, 19, 2, 20, 4, 8, 9, 10, 11, 12, 15]","1: 	import java.util.*;
2: 	class ConnectSticks {
3: 	    public int connectSticks(int[] sticks) {
4: 	        PriorityQueue<Integer> pq = new PriorityQueue<>();
5: 	        for(int v : sticks){
6: 	        	pq.add(v);
7: 	        }
8: 	        int ans = 0;
9: 	        while(pq.size() > 1){
10: 	        	int x = pq.poll();
11: 	        	int y = pq.poll();
12: 	        	ans += x + y;
13: 	        	pq.add(x+y);
14: 	        }
15: 	        return ans;
16: 	    }
17: 		public static void main(String[] args) {
18: 			int[] sticks = {2, 4, 3}; // Example input
19: 			ConnectSticks connectSticks = new ConnectSticks();
20: 			int result = connectSticks.connectSticks(sticks);
21: 			System.out.println(""Minimum cost to connect sticks: "" + result);
22:    	 }
23: 	}	
24: ","[20, 19, 3, 4, 5, 6, 8, 9, 10, 11, 12, 13, 15]","{'output': ['20', '19', '3', '4', '5', '6', '8', '9', '10', '11', '12', '13', '15']}","[20, 19, 3, 4, 5, 6, 8, 9, 10, 11, 12, 13, 15]","{'output': ['20', '19', '3', '4', '5', '6', '8', '9', '10', '11', '12', '13', '15']}","[20, 19, 3]","{'output': ['20', '19', '3']}"
"	class ConstructArray {
	    public int[] constructArray(int n, int k) {
	    	int[] a = new int[n];
	    	int l = 1, h = n;
	    	int p = 0;
	        for(int i = 0;i < k-1;i++){
	        	if(i % 2 == 0){
	        		a[p++] = l++;
	        	}else{
	        		a[p++] = h--;
	        	}
	        }
	        if(k % 2 == 1){
		        for(int i = l;i <= h;i++){
		        	a[p++] = i;
		        }
	        }else{
		        for(int i = h;i >= l;i--){
		        	a[p++] = i;
		        }
	        }
	        return a;
	    }
		public static void main(String[] args) {
			int n = 10; // Example value for n
			int k = 4;  // Example value for k
			ConstructArray constructArray = new ConstructArray();
			int[] result = constructArray.constructArray(n, k);
			System.out.print(""Constructed array: "");
			for (int num : result) {
				System.out.print(num + "" "");
			}
			System.out.println();
    }
	}
",ConstructArray,28,"[27, 1, 28, 3, 4, 6, 7, 8, 10, 13, 18, 19, 22]","1: 	class ConstructArray {
2: 	    public int[] constructArray(int n, int k) {
3: 	    	int[] a = new int[n];
4: 	    	int l = 1, h = n;
5: 	    	int p = 0;
6: 	        for(int i = 0;i < k-1;i++){
7: 	        	if(i % 2 == 0){
8: 	        		a[p++] = l++;
9: 	        	}else{
10: 	        		a[p++] = h--;
11: 	        	}
12: 	        }
13: 	        if(k % 2 == 1){
14: 		        for(int i = l;i <= h;i++){
15: 		        	a[p++] = i;
16: 		        }
17: 	        }else{
18: 		        for(int i = h;i >= l;i--){
19: 		        	a[p++] = i;
20: 		        }
21: 	        }
22: 	        return a;
23: 	    }
24: 		public static void main(String[] args) {
25: 			int n = 10; // Example value for n
26: 			int k = 4;  // Example value for k
27: 			ConstructArray constructArray = new ConstructArray();
28: 			int[] result = constructArray.constructArray(n, k);
29: 			System.out.print(""Constructed array: "");
30: 			for (int num : result) {
31: 				System.out.print(num + "" "");
32: 			}
33: 			System.out.println();
34:     }
35: 	}
36: ","[28, 27, 26, 25, 2, 3, 4, 5, 6, 7, 8, 10, 11, 13, 14, 15, 17, 18, 19, 22]","{'output': ['28', '27', '26', '25', '2', '3', '4', '5', '6', '7', '8', '10', '11', '13', '14', '15', '17', '18', '19', '22']}","[28, 27, 26, 25, 2]","{'output': ['28', '27', '26', '25', '2']}","[28, 25, 26, 2, 3, 4, 5, 6, 7, 8, 10, 12, 13, 14, 15, 17, 18, 19, 22]","{'output': ['28', '25', '26', '2', '3', '4', '5', '6', '7', '8', '10', '12', '13', '14', '15', '17', '18', '19', '22']}"
"import java.util.*;
class CountDifferentSubsequenceGCDs {
    public int countDifferentSubsequenceGCDs(int[] arr) {
        int N = arr.length;
        int[] buckets = new int[200001];
        for(int x: arr)
        {
            ArrayList<Integer> div = findDiv(x);
            for(int d: div)
            {
                if(buckets[d] == 0)
                    buckets[d] = x;
                else
                    buckets[d] = gcd(buckets[d], x);
            }
        }
        int res = 0;
        for(int i=1; i <= 200000; i++)
            if(buckets[i] == i)
            {
                res++;
            }
        return res;
    }
    public ArrayList<Integer> findDiv(int N)
    {
        //gens all divisors of N
        ArrayList<Integer> ls1 = new ArrayList<Integer>();
        ArrayList<Integer> ls2 = new ArrayList<Integer>();
        for(int i=1; i <= (int)(Math.sqrt(N)+0.00000001); i++)
            if(N%i == 0)
            {
                ls1.add(i);
                ls2.add(N/i);
            }
        Collections.reverse(ls2);
        for(int b: ls2)
            if(b != ls1.get(ls1.size()-1))
                ls1.add(b);
        return ls1;
    }
    public static int gcd(int a, int b)
    {
        if(a > b)
        {
            int t = a;
            a = b;
            b = t;
        }
        if(a == 0)
            return b;
        return gcd(b%a, a);
    }

      public static void main(String[] args) {
        int[] arr = {6, 10, 3}; // Example input
        CountDifferentSubsequenceGCDs countGCDs = new CountDifferentSubsequenceGCDs();
        int result = countGCDs.countDifferentSubsequenceGCDs(arr);
        System.out.println(""Count of different subsequence GCDs: "" + result);
    }
}",CountDifferentSubsequenceGCDs,58,"[56, 57, 2, 58, 5, 6, 12, 8, 28, 40, 9, 14, 50, 52, 51, 44, 46, 47, 48, 17, 18, 19, 21, 23]","1: import java.util.*;
2: class CountDifferentSubsequenceGCDs {
3:     public int countDifferentSubsequenceGCDs(int[] arr) {
4:         int N = arr.length;
5:         int[] buckets = new int[200001];
6:         for(int x: arr)
7:         {
8:             ArrayList<Integer> div = findDiv(x);
9:             for(int d: div)
10:             {
11:                 if(buckets[d] == 0)
12:                     buckets[d] = x;
13:                 else
14:                     buckets[d] = gcd(buckets[d], x);
15:             }
16:         }
17:         int res = 0;
18:         for(int i=1; i <= 200000; i++)
19:             if(buckets[i] == i)
20:             {
21:                 res++;
22:             }
23:         return res;
24:     }
25:     public ArrayList<Integer> findDiv(int N)
26:     {
27:         //gens all divisors of N
28:         ArrayList<Integer> ls1 = new ArrayList<Integer>();
29:         ArrayList<Integer> ls2 = new ArrayList<Integer>();
30:         for(int i=1; i <= (int)(Math.sqrt(N)+0.00000001); i++)
31:             if(N%i == 0)
32:             {
33:                 ls1.add(i);
34:                 ls2.add(N/i);
35:             }
36:         Collections.reverse(ls2);
37:         for(int b: ls2)
38:             if(b != ls1.get(ls1.size()-1))
39:                 ls1.add(b);
40:         return ls1;
41:     }
42:     public static int gcd(int a, int b)
43:     {
44:         if(a > b)
45:         {
46:             int t = a;
47:             a = b;
48:             b = t;
49:         }
50:         if(a == 0)
51:             return b;
52:         return gcd(b%a, a);
53:     }
54: 
55:       public static void main(String[] args) {
56:         int[] arr = {6, 10, 3}; // Example input
57:         CountDifferentSubsequenceGCDs countGCDs = new CountDifferentSubsequenceGCDs();
58:         int result = countGCDs.countDifferentSubsequenceGCDs(arr);
59:         System.out.println(""Count of different subsequence GCDs: "" + result);
60:     }
61: }","[58, 57, 3, 4, 5, 6, 8, 9, 11, 12, 14, 17, 18, 19, 23]","{'output': ['58', '57', '3', '4', '5', '6', '8', '9', '11', '12', '14', '17', '18', '19', '23']}","[58, 57]","{'output': ['58', '57']}","[58, 57, 3]","{'output': ['58', '57', '3']}"
"import java.util.*;
class CountGood {

	public long countGood(int[] nums, int k) {
		long count = 0, curr = 0;
		HashMap<Integer, Integer> map = new HashMap<>();
		for (int i = 0, j = 0; i < nums.length; i++, count += j) {
			curr += map.getOrDefault(nums[i], 0);
			map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);
			for (; curr >= k; j++) {
				curr -= map.put(nums[j], map.get(nums[j]) - 1) - 1;
			}
		}
		return count;
	}
	public static void main(String[] args) {
        int[] nums = {1, 2, 1, 2, 1}; // Example input
        int k = 2;  // Example value for k
        CountGood countGood = new CountGood();
        long result = countGood.countGood(nums, k);
        System.out.println(""Count of good subarrays: "" + result);
    }
}",CountGood,20,"[17, 19, 2, 20, 5, 6, 7, 8, 10, 11, 14]","1: import java.util.*;
2: class CountGood {
3: 
4: 	public long countGood(int[] nums, int k) {
5: 		long count = 0, curr = 0;
6: 		HashMap<Integer, Integer> map = new HashMap<>();
7: 		for (int i = 0, j = 0; i < nums.length; i++, count += j) {
8: 			curr += map.getOrDefault(nums[i], 0);
9: 			map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);
10: 			for (; curr >= k; j++) {
11: 				curr -= map.put(nums[j], map.get(nums[j]) - 1) - 1;
12: 			}
13: 		}
14: 		return count;
15: 	}
16: 	public static void main(String[] args) {
17:         int[] nums = {1, 2, 1, 2, 1}; // Example input
18:         int k = 2;  // Example value for k
19:         CountGood countGood = new CountGood();
20:         long result = countGood.countGood(nums, k);
21:         System.out.println(""Count of good subarrays: "" + result);
22:     }
23: }","[20, 19, 4, 5, 6, 7, 8, 9, 10, 11, 14]","{'output': ['20', '19', '4', '5', '6', '7', '8', '9', '10', '11', '14']}","[20, 19, 18, 4, 5, 6, 7, 8, 9, 10, 11, 14]","{'output': ['20', '19', '18', '4', '5', '6', '7', '8', '9', '10', '11', '14']}","[20, 19, 18, 17, 4, 5, 6, 7, 8, 9, 10, 11, 14]","{'output': ['20', '19', '18', '17', '4', '5', '6', '7', '8', '9', '10', '11', '14']}"
"class CountMaxOrSubsets {
    public int countMaxOrSubsets(int[] a) {
        int n = a.length;
        int all = 0;
        for(int v : a){
            all |= v;
        }
        int ct = 0;
        for(int i = 0;i < 1<<n;i++){
            int s = 0;
            for(int j = 0;j < n;j++){
                if(i<<~j<0){
                    s |= a[j];
                }
            }
            if(s == all)ct++;
        }
        return ct;
    }
      public static void main(String[] args) {
        int[] a = {3, 1, 2}; // Example input
        CountMaxOrSubsets countMaxOrSubsets = new CountMaxOrSubsets();
        int result = countMaxOrSubsets.countMaxOrSubsets(a);
        System.out.println(""Count of maximum OR subsets: "" + result);
    }
}",CountMaxOrSubsets,23,"[21, 22, 1, 23, 3, 4, 5, 6, 8, 9, 10, 11, 13, 16, 18]","1: class CountMaxOrSubsets {
2:     public int countMaxOrSubsets(int[] a) {
3:         int n = a.length;
4:         int all = 0;
5:         for(int v : a){
6:             all |= v;
7:         }
8:         int ct = 0;
9:         for(int i = 0;i < 1<<n;i++){
10:             int s = 0;
11:             for(int j = 0;j < n;j++){
12:                 if(i<<~j<0){
13:                     s |= a[j];
14:                 }
15:             }
16:             if(s == all)ct++;
17:         }
18:         return ct;
19:     }
20:       public static void main(String[] args) {
21:         int[] a = {3, 1, 2}; // Example input
22:         CountMaxOrSubsets countMaxOrSubsets = new CountMaxOrSubsets();
23:         int result = countMaxOrSubsets.countMaxOrSubsets(a);
24:         System.out.println(""Count of maximum OR subsets: "" + result);
25:     }
26: }","[23, 22, 2, 8, 9, 10, 11, 12, 13, 16, 18]","{'output': ['23', '22', '2', '8', '9', '10', '11', '12', '13', '16', '18']}","[23, 22, 2, 3, 4, 5, 6, 8, 9, 10, 11, 12, 13, 16, 18]","{'output': ['23', '22', '2', '3', '4', '5', '6', '8', '9', '10', '11', '12', '13', '16', '18']}","[23, 22, 2, 18, 16, 13, 12, 11, 10, 9, 8, 5, 6, 4, 3]","{'output': ['23', '22', '2', '18', '16', '13', '12', '11', '10', '9', '8', '5', '6', '4', '3']}"
"	import java.util.*;
	class CountOfAtoms {
		char[] s;
		int pos, len;
		
	    public String countOfAtoms(String formula) {
	        s = formula.toCharArray();
	        pos = 0;
	        len = s.length;
	        TreeMap<String, java.math.BigInteger> res = go();
	        StringBuilder sb = new StringBuilder();
	        for(String key : res.keySet()){
	        	sb.append(key);
	        	java.math.BigInteger val = res.get(key);
	        	if(!val.equals(java.math.BigInteger.ONE)){
	        		sb.append(val);
	        	}
	        }
	        return sb.toString();
	    }
	    
	    TreeMap<String, java.math.BigInteger> go()
	    {
	    	TreeMap<String, java.math.BigInteger> ret = new TreeMap<>();
	    	while(pos < len && s[pos] != ')'){
		    	if(s[pos] == '('){
		    		pos++;
		    		TreeMap<String, java.math.BigInteger> res = go();
		    		pos++;
		    		java.math.BigInteger num = num();
		    		for(String key : res.keySet()){
		    			java.math.BigInteger val = res.get(key).multiply(num);
		    			if(ret.containsKey(key)){
		    				ret.put(key, ret.get(key).add(val));
		    			}else{
		    				ret.put(key, val);
		    			}
		    		}
		    	}else{
		    		String atom = atom();
		    		java.math.BigInteger num = java.math.BigInteger.ONE;
		    		if(pos < len && s[pos] >= '0' && s[pos] <= '9'){
		    			num = num();
		    		}
	    			if(ret.containsKey(atom)){
	    				ret.put(atom, ret.get(atom).add(num));
	    			}else{
	    				ret.put(atom, num);
	    			}
		    	}
	    	}
	    	return ret;
	    }
	    
	    String atom()
	    {
	    	int opos = pos++;
	    	while(pos < len && s[pos] >= 'a' && s[pos] <= 'z')pos++;
	    	return new String(s, opos, pos - opos);
	    }
	    
	    java.math.BigInteger num()
	    {
	    	int opos = pos;
	    	while(pos < len && s[pos] >= '0' && s[pos] <= '9')pos++;
	    	return new java.math.BigInteger(new String(s, opos, pos-opos));
	    }
		 public static void main(String[] args) {
			String formula = ""K4(ON(SO3)2)2""; // Example input
			CountOfAtoms countOfAtoms = new CountOfAtoms();
			String result = countOfAtoms.countOfAtoms(formula);
			System.out.println(""Count of atoms: "" + result);
    }
	}	
",CountOfAtoms,71,"[70, 2, 71, 7, 8, 9, 10, 26, 40, 57, 43, 65, 27, 24, 59, 42, 45, 28, 52, 11, 12, 13, 14, 15, 16, 19]","1: 	import java.util.*;
2: 	class CountOfAtoms {
3: 		char[] s;
4: 		int pos, len;
5: 		
6: 	    public String countOfAtoms(String formula) {
7: 	        s = formula.toCharArray();
8: 	        pos = 0;
9: 	        len = s.length;
10: 	        TreeMap<String, java.math.BigInteger> res = go();
11: 	        StringBuilder sb = new StringBuilder();
12: 	        for(String key : res.keySet()){
13: 	        	sb.append(key);
14: 	        	java.math.BigInteger val = res.get(key);
15: 	        	if(!val.equals(java.math.BigInteger.ONE)){
16: 	        		sb.append(val);
17: 	        	}
18: 	        }
19: 	        return sb.toString();
20: 	    }
21: 	    
22: 	    TreeMap<String, java.math.BigInteger> go()
23: 	    {
24: 	    	TreeMap<String, java.math.BigInteger> ret = new TreeMap<>();
25: 	    	while(pos < len && s[pos] != ')'){
26: 		    	if(s[pos] == '('){
27: 		    		pos++;
28: 		    		TreeMap<String, java.math.BigInteger> res = go();
29: 		    		pos++;
30: 		    		java.math.BigInteger num = num();
31: 		    		for(String key : res.keySet()){
32: 		    			java.math.BigInteger val = res.get(key).multiply(num);
33: 		    			if(ret.containsKey(key)){
34: 		    				ret.put(key, ret.get(key).add(val));
35: 		    			}else{
36: 		    				ret.put(key, val);
37: 		    			}
38: 		    		}
39: 		    	}else{
40: 		    		String atom = atom();
41: 		    		java.math.BigInteger num = java.math.BigInteger.ONE;
42: 		    		if(pos < len && s[pos] >= '0' && s[pos] <= '9'){
43: 		    			num = num();
44: 		    		}
45: 	    			if(ret.containsKey(atom)){
46: 	    				ret.put(atom, ret.get(atom).add(num));
47: 	    			}else{
48: 	    				ret.put(atom, num);
49: 	    			}
50: 		    	}
51: 	    	}
52: 	    	return ret;
53: 	    }
54: 	    
55: 	    String atom()
56: 	    {
57: 	    	int opos = pos++;
58: 	    	while(pos < len && s[pos] >= 'a' && s[pos] <= 'z')pos++;
59: 	    	return new String(s, opos, pos - opos);
60: 	    }
61: 	    
62: 	    java.math.BigInteger num()
63: 	    {
64: 	    	int opos = pos;
65: 	    	while(pos < len && s[pos] >= '0' && s[pos] <= '9')pos++;
66: 	    	return new java.math.BigInteger(new String(s, opos, pos-opos));
67: 	    }
68: 		 public static void main(String[] args) {
69: 			String formula = ""K4(ON(SO3)2)2""; // Example input
70: 			CountOfAtoms countOfAtoms = new CountOfAtoms();
71: 			String result = countOfAtoms.countOfAtoms(formula);
72: 			System.out.println(""Count of atoms: "" + result);
73:     }
74: 	}	
75: ","[71, 70, 6, 7, 8, 9, 10, 22, 24, 25, 26, 27, 28, 30, 31, 32, 33, 34, 35, 36, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 52, 55, 57, 58, 59, 62, 64, 65, 66]","{'output': ['71', '70', '6', '7', '8', '9', '10', '22', '24', '25', '26', '27', '28', '30', '31', '32', '33', '34', '35', '36', '39', '40', '41', '42', '43', '44', '45', '46', '47', '48', '52', '55', '57', '58', '59', '62', '64', '65', '66']}","[71, 6, 7, 8, 9, 10, 22, 24, 25, 39, 40, 55, 56, 57, 58, 59, 45, 46, 47, 48, 50, 52, 19]","{'output': ['71', '6', '7', '8', '9', '10', '22', '24', '25', '39', '40', '55', '56', '57', '58', '59', '45', '46', '47', '48', '50', '52', '19']}","[71, 69, 70, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 18, 19, 22, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 52, 55, 56, 57, 58, 59, 62, 63, 64, 65, 66]","{'output': ['71', '69', '70', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '18', '19', '22', '24', '25', '26', '27', '28', '29', '30', '31', '32', '33', '34', '35', '36', '38', '39', '40', '41', '42', '43', '44', '45', '46', '47', '48', '52', '55', '56', '57', '58', '59', '62', '63', '64', '65', '66']}"
"class CountQuadruplets {

	public long countQuadruplets(int[] nums) {
		int[][] left = new int[nums.length][nums.length], right = new int[nums.length][nums.length];
		for (int i = 0; i < nums.length; i++) {
			for (int j = 0; j < i; j++) {
				left[j + 1][i] = left[j][i] + (nums[j] < nums[i] ? 1 : 0);
			}
			for (int j = nums.length - 1; j > i; j--) {
				right[i][j - 1] = right[i][j] + (nums[j] > nums[i] ? 1 : 0);
			}
		}
		long count = 0;
		for (int i = 0; i < nums.length; i++) {
			for (int j = i + 1; j < nums.length; j++) {
				count += nums[i] > nums[j] ? left[i + 1][j] * right[i][j - 1] : 0;
			}
		}
		return count;
	}
	public static void main(String[] args) {
        int[] nums = {1, 3, 2, 4, 5}; // Example input
        CountQuadruplets countQuadruplets = new CountQuadruplets();
        long result = countQuadruplets.countQuadruplets(nums);
        System.out.println(""Count of quadruplets: "" + result);
    }
}",CountQuadruplets,24,"[22, 23, 1, 24, 4, 13, 14, 15, 16, 19]","1: class CountQuadruplets {
2: 
3: 	public long countQuadruplets(int[] nums) {
4: 		int[][] left = new int[nums.length][nums.length], right = new int[nums.length][nums.length];
5: 		for (int i = 0; i < nums.length; i++) {
6: 			for (int j = 0; j < i; j++) {
7: 				left[j + 1][i] = left[j][i] + (nums[j] < nums[i] ? 1 : 0);
8: 			}
9: 			for (int j = nums.length - 1; j > i; j--) {
10: 				right[i][j - 1] = right[i][j] + (nums[j] > nums[i] ? 1 : 0);
11: 			}
12: 		}
13: 		long count = 0;
14: 		for (int i = 0; i < nums.length; i++) {
15: 			for (int j = i + 1; j < nums.length; j++) {
16: 				count += nums[i] > nums[j] ? left[i + 1][j] * right[i][j - 1] : 0;
17: 			}
18: 		}
19: 		return count;
20: 	}
21: 	public static void main(String[] args) {
22:         int[] nums = {1, 3, 2, 4, 5}; // Example input
23:         CountQuadruplets countQuadruplets = new CountQuadruplets();
24:         long result = countQuadruplets.countQuadruplets(nums);
25:         System.out.println(""Count of quadruplets: "" + result);
26:     }
27: }","[24, 23, 3, 19, 16, 14, 13, 10, 9, 5, 4]","{'output': ['24', '23', '3', '19', '16', '14', '13', '10', '9', '5', '4']}","[24, 23, 3, 13, 16, 19]","{'output': ['24', '23', '3', '13', '16', '19']}","[24, 23, 3, 13, 16, 19]","{'output': ['24', '23', '3', '13', '16', '19']}"
"import java.util.*;
class CountWays {

	public int countWays(int[][] ranges) {
		Arrays.sort(ranges, (int[] o,int[] p) -> o[0] - p[0]);
		int count = 1;
		for (int i = 0, j = -1; i < ranges.length; j = Math.max(j, ranges[i++][1])) {
			count = ranges[i][0] > j ? count * 2 % 1000000007 : count;
		}
		return count;
	}
	public static void main(String[] args) {
        int[][] ranges = { {1, 3}, {2, 4}, {6, 8} }; // Example input
        CountWays countWays = new CountWays();
        int result = countWays.countWays(ranges);
        System.out.println(""Number of ways: "" + result);
    }
}",CountWays,15,"[13, 14, 2, 15, 5, 6, 7, 8, 10]","1: import java.util.*;
2: class CountWays {
3: 
4: 	public int countWays(int[][] ranges) {
5: 		Arrays.sort(ranges, (int[] o,int[] p) -> o[0] - p[0]);
6: 		int count = 1;
7: 		for (int i = 0, j = -1; i < ranges.length; j = Math.max(j, ranges[i++][1])) {
8: 			count = ranges[i][0] > j ? count * 2 % 1000000007 : count;
9: 		}
10: 		return count;
11: 	}
12: 	public static void main(String[] args) {
13:         int[][] ranges = { {1, 3}, {2, 4}, {6, 8} }; // Example input
14:         CountWays countWays = new CountWays();
15:         int result = countWays.countWays(ranges);
16:         System.out.println(""Number of ways: "" + result);
17:     }
18: }","[15, 14, 4, 5, 6, 7, 8, 10]","{'output': ['15', '14', '4', '5', '6', '7', '8', '10']}","[15, 14, 13, 4, 5, 6, 7, 8, 10]","{'output': ['15', '14', '13', '4', '5', '6', '7', '8', '10']}","[15, 14, 4, 5, 6, 7, 8, 10]","{'output': ['15', '14', '4', '5', '6', '7', '8', '10']}"
"public class CycleLengthQueries {

	public int[] cycleLengthQueries(int n, int[][] queries) {
		int[] result = new int[queries.length];
		for (int i = 0; i < queries.length; i++) {
			String s = Integer.toBinaryString(queries[i][0]), t = Integer.toBinaryString(queries[i][1]);
			result[i] = s.length() + t.length() + 1;
			for (int j = 0, k = 0; j < s.length() && k < t.length() && s.charAt(j) == t.charAt(k); j++, k++) {
				result[i] -= 2;
			}
		}
		return result;
	}
	public static void main(String[] args) {
        int n = 5; // Example value for n
        int[][] queries = { {3, 5}, {1, 7}, {2, 6} }; // Example queries
        CycleLengthQueries cycleLengthQueries = new CycleLengthQueries();
        int[] result = cycleLengthQueries.cycleLengthQueries(n, queries);
    }
}",CycleLengthQueries,18,"[16, 17, 1, 18, 4, 5, 6, 7, 9, 12]","1: public class CycleLengthQueries {
2: 
3: 	public int[] cycleLengthQueries(int n, int[][] queries) {
4: 		int[] result = new int[queries.length];
5: 		for (int i = 0; i < queries.length; i++) {
6: 			String s = Integer.toBinaryString(queries[i][0]), t = Integer.toBinaryString(queries[i][1]);
7: 			result[i] = s.length() + t.length() + 1;
8: 			for (int j = 0, k = 0; j < s.length() && k < t.length() && s.charAt(j) == t.charAt(k); j++, k++) {
9: 				result[i] -= 2;
10: 			}
11: 		}
12: 		return result;
13: 	}
14: 	public static void main(String[] args) {
15:         int n = 5; // Example value for n
16:         int[][] queries = { {3, 5}, {1, 7}, {2, 6} }; // Example queries
17:         CycleLengthQueries cycleLengthQueries = new CycleLengthQueries();
18:         int[] result = cycleLengthQueries.cycleLengthQueries(n, queries);
19:     }
20: }","[18, 17, 16]","{'output': ['18', '17', '16']}","[18, 17, 3, 4, 5, 6, 7, 8, 9, 12]","{'output': ['18', '17', '3', '4', '5', '6', '7', '8', '9', '12']}","[18, 17, 3, 4, 5, 6, 7, 8, 9, 12]","{'output': ['18', '17', '3', '4', '5', '6', '7', '8', '9', '12']}"
"public class DecodeCiphertext {
    public String decodeCiphertext(String et, int rows) {
        int cols = et.length()/rows;
        StringBuilder ans = new StringBuilder();
        for (int i = 0; i < cols; ++i) {
            for (int j = 0; j < rows && i+j<cols; ++j) {
                ans.append(et.charAt(j*cols+i+j));
            }
        }
        String aa = ans.toString();
        int last = 0;
        for (int i = 0; i < aa.length(); ++i) {
            if (aa.charAt(i)!=' ')
                last = i+1;
        }
        return aa.substring(0,last);
    }
    public static void main(String[] args) {
        DecodeCiphertext decoder = new DecodeCiphertext();
        String encodedText = ""ch   ie   pr"";
        int rows = 3;
        String decodedText = decoder.decodeCiphertext(encodedText, rows);
        System.out.println(""Decoded Text: "" + decodedText);
    }
}
",DecodeCiphertext,14,"[22, 3, 4, 5, 6, 7, 10, 12, 13, 14]","1: public class DecodeCiphertext {
2:     public String decodeCiphertext(String et, int rows) {
3:         int cols = et.length()/rows;
4:         StringBuilder ans = new StringBuilder();
5:         for (int i = 0; i < cols; ++i) {
6:             for (int j = 0; j < rows && i+j<cols; ++j) {
7:                 ans.append(et.charAt(j*cols+i+j));
8:             }
9:         }
10:         String aa = ans.toString();
11:         int last = 0;
12:         for (int i = 0; i < aa.length(); ++i) {
13:             if (aa.charAt(i)!=' ')
14:                 last = i+1;
15:         }
16:         return aa.substring(0,last);
17:     }
18:     public static void main(String[] args) {
19:         DecodeCiphertext decoder = new DecodeCiphertext();
20:         String encodedText = ""ch   ie   pr"";
21:         int rows = 3;
22:         String decodedText = decoder.decodeCiphertext(encodedText, rows);
23:         System.out.println(""Decoded Text: "" + decodedText);
24:     }
25: }
26: ","[14, 13, 12]","{'output': ['14', '13', '12']}","[14, 13, 10, 4]","{'output': ['14', '13', '10', '4']}","[14, 13, 12, 10, 4, 7, 6, 5]","{'output': ['14', '13', '12', '10', '4', '7', '6', '5']}"
"
 
class DeepestLeavesSum {
    public static class TreeNode {
      int val;
     TreeNode left;
     TreeNode right;
      TreeNode(int x) { val = x; }
    }
    int[] c = new int[10001];
    int max = 0;
    
    public int deepestLeavesSum(TreeNode root) {
        dls(root, 0);
        return c[max];
    }
    
    public void dls(TreeNode root, int d) {
        if (root==null)
            return;
        if (root.left==null&&root.right==null) {
            c[d] += root.val;
        }
        max = Math.max(max,d);
        dls(root.left,d+1);
        dls(root.right,d+1);
    }
      public static void main(String[] args) {
        DeepestLeavesSum.TreeNode root = new DeepestLeavesSum.TreeNode(1);
        root.left = new DeepestLeavesSum.TreeNode(2);
        root.right = new DeepestLeavesSum.TreeNode(3);
        root.left.left = new DeepestLeavesSum.TreeNode(4);
        root.left.right = new DeepestLeavesSum.TreeNode(5);
        root.right.right = new DeepestLeavesSum.TreeNode(6);
        root.left.left.left = new DeepestLeavesSum.TreeNode(7);
        root.right.right.right = new DeepestLeavesSum.TreeNode(8);

        DeepestLeavesSum deepestLeavesSum = new DeepestLeavesSum();
        int result = deepestLeavesSum.deepestLeavesSum(root);
        System.out.println(""Deepest Leaves Sum: "" + result);
    }
}",DeepestLeavesSum,39,"[29, 30, 31, 38, 3, 10, 11, 39, 14, 19, 24, 15]","1: 
2:  
3: class DeepestLeavesSum {
4:     public static class TreeNode {
5:       int val;
6:      TreeNode left;
7:      TreeNode right;
8:       TreeNode(int x) { val = x; }
9:     }
10:     int[] c = new int[10001];
11:     int max = 0;
12:     
13:     public int deepestLeavesSum(TreeNode root) {
14:         dls(root, 0);
15:         return c[max];
16:     }
17:     
18:     public void dls(TreeNode root, int d) {
19:         if (root==null)
20:             return;
21:         if (root.left==null&&root.right==null) {
22:             c[d] += root.val;
23:         }
24:         max = Math.max(max,d);
25:         dls(root.left,d+1);
26:         dls(root.right,d+1);
27:     }
28:       public static void main(String[] args) {
29:         DeepestLeavesSum.TreeNode root = new DeepestLeavesSum.TreeNode(1);
30:         root.left = new DeepestLeavesSum.TreeNode(2);
31:         root.right = new DeepestLeavesSum.TreeNode(3);
32:         root.left.left = new DeepestLeavesSum.TreeNode(4);
33:         root.left.right = new DeepestLeavesSum.TreeNode(5);
34:         root.right.right = new DeepestLeavesSum.TreeNode(6);
35:         root.left.left.left = new DeepestLeavesSum.TreeNode(7);
36:         root.right.right.right = new DeepestLeavesSum.TreeNode(8);
37: 
38:         DeepestLeavesSum deepestLeavesSum = new DeepestLeavesSum();
39:         int result = deepestLeavesSum.deepestLeavesSum(root);
40:         System.out.println(""Deepest Leaves Sum: "" + result);
41:     }
42: }","[39, 38, 13, 14, 15, 10, 11, 18, 19, 21, 22, 24, 25, 26]","{'output': ['39', '38', '13', '14', '15', '10', '11', '18', '19', '21', '22', '24', '25', '26']}","[39, 13, 14, 18, 19, 21, 22, 24, 25, 26, 10, 11]","{'output': ['39', '13', '14', '18', '19', '21', '22', '24', '25', '26', '10', '11']}","[39, 13, 14, 18, 19, 21, 22, 24, 25, 26, 15]","{'output': ['39', '13', '14', '18', '19', '21', '22', '24', '25', '26', '15']}"
"	import java.util.*;
	class DeleteString {
		public int deleteString(String S) {
			char[] s = S.toCharArray();
			int n = s.length;
			int[] dp = new int[n];
			for(int i = n-1;i >= 0;i--){
				char[] t = Arrays.copyOfRange(s, i, n);
				int[] z = Z(t);
				dp[i] = 1;
				for(int j = 1;2*j <= t.length;j++){
					if(z[j] >= j){
						dp[i] = Math.max(dp[i], dp[i+j] + 1);
					}
				}
			}
			return dp[0];
		}

		public int[] Z(char[] str)
		{
			int n = str.length;
			int[] z = new int[n];
			if(n == 0)return z;
			z[0] = n;
			int l = 0, r = 0;
			for(int i = 1;i < n;i++){
				if(i > r){
					l = r = i;
					while(r < n && str[r-l] == str[r])r++;
					z[i] = r-l; r--;
				}else{
					if(z[i-l] < r-i+1){
						z[i] = z[i-l];
					}else{
						l = i;
						while(r < n && str[r-l] == str[r])r++;
						z[i] = r-l; r--;
					}
				}
			}

			return z;
		}
	 public static void main(String[] args) {
        DeleteString deleteString = new DeleteString();
        String input = ""abcabcdabc"";
        int result = deleteString.deleteString(input);
        System.out.println(""The maximum number of deletions: "" + result);
    }

	}
",DeleteString,48,"[46, 2, 48, 4, 5, 6, 7, 8, 10, 9, 22, 23, 24, 25, 26, 27, 28, 29, 31, 30, 33, 34, 43, 11, 12, 13, 17]","1: 	import java.util.*;
2: 	class DeleteString {
3: 		public int deleteString(String S) {
4: 			char[] s = S.toCharArray();
5: 			int n = s.length;
6: 			int[] dp = new int[n];
7: 			for(int i = n-1;i >= 0;i--){
8: 				char[] t = Arrays.copyOfRange(s, i, n);
9: 				int[] z = Z(t);
10: 				dp[i] = 1;
11: 				for(int j = 1;2*j <= t.length;j++){
12: 					if(z[j] >= j){
13: 						dp[i] = Math.max(dp[i], dp[i+j] + 1);
14: 					}
15: 				}
16: 			}
17: 			return dp[0];
18: 		}
19: 
20: 		public int[] Z(char[] str)
21: 		{
22: 			int n = str.length;
23: 			int[] z = new int[n];
24: 			if(n == 0)return z;
25: 			z[0] = n;
26: 			int l = 0, r = 0;
27: 			for(int i = 1;i < n;i++){
28: 				if(i > r){
29: 					l = r = i;
30: 					while(r < n && str[r-l] == str[r])r++;
31: 					z[i] = r-l; r--;
32: 				}else{
33: 					if(z[i-l] < r-i+1){
34: 						z[i] = z[i-l];
35: 					}else{
36: 						l = i;
37: 						while(r < n && str[r-l] == str[r])r++;
38: 						z[i] = r-l; r--;
39: 					}
40: 				}
41: 			}
42: 
43: 			return z;
44: 		}
45: 	 public static void main(String[] args) {
46:         DeleteString deleteString = new DeleteString();
47:         String input = ""abcabcdabc"";
48:         int result = deleteString.deleteString(input);
49:         System.out.println(""The maximum number of deletions: "" + result);
50:     }
51: 
52: 	}
53: ","[48, 46, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 16, 17]","{'output': ['48', '46', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '16', '17']}","[48, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 16, 17, 46, 47]","{'output': ['48', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '16', '17', '46', '47']}","[48, 47, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 16, 17]","{'output': ['48', '47', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '16', '17']}"
"class Dfs {
    static boolean[][] vis;
    static int[][] grid;
    static int[] dx = {1, 0, -1, 0};
    static int[] dy = {0, -1, 0, 1};
    
    public int dfs(int x, int y, int ex, int ey, int open) {
        if (x < 0 || x >= grid.length || y < 0 || y >= grid[x].length || vis[x][y] || grid[x][y] == -1) {
            return 0;
        }

        if (x == ex && y == ey) {
            return open == 1 ? 1 : 0;
        }
        int ans = 0;
        vis[x][y] = true;
        for (int d = 0; d < 4; ++d) {
            ans += dfs(x + dx[d], y + dy[d], ex, ey, open - 1);
        }
        vis[x][y] = false;
        return ans;
    }
                   
    public int uniquePathsIII(int[][] _grid) {
        grid = _grid;
        int n = grid.length;
        int m = grid[0].length;
        vis = new boolean[n][m];
        int open = 0;
        int sx = -1;
        int sy = -1;
        int ex = -1;
        int ey = -1;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (grid[i][j] == 1) {
                    sx = i;
                    sy = j;
                    grid[i][j] = 0;
                } else if (grid[i][j] == 2) {
                    ex = i;
                    ey = j;
                    grid[i][j] = 0;
                }
                
                if (grid[i][j] == 0) {
                    open++;
                }
            }
        }
        
        return dfs(sx, sy, ex, ey, open);
    }
    public static void main(String[] args) {
        Dfs dfsSolver = new Dfs();
        int[][] grid = {
            {1, 0, 0, 0},
            {0, 0, 0, 0},
            {0, 0, 2, -1}
        };
        
        int result = dfsSolver.uniquePathsIII(grid);
        System.out.println(""Unique Paths III: "" + result);
    }
}",Dfs,62,"[4, 5, 55, 1, 56, 62, 25, 26, 27, 29, 34, 35, 36, 37, 38, 46, 47, 40, 41, 42, 52, 12, 17, 18, 15, 8, 9, 21]","1: class Dfs {
2:     static boolean[][] vis;
3:     static int[][] grid;
4:     static int[] dx = {1, 0, -1, 0};
5:     static int[] dy = {0, -1, 0, 1};
6:     
7:     public int dfs(int x, int y, int ex, int ey, int open) {
8:         if (x < 0 || x >= grid.length || y < 0 || y >= grid[x].length || vis[x][y] || grid[x][y] == -1) {
9:             return 0;
10:         }
11: 
12:         if (x == ex && y == ey) {
13:             return open == 1 ? 1 : 0;
14:         }
15:         int ans = 0;
16:         vis[x][y] = true;
17:         for (int d = 0; d < 4; ++d) {
18:             ans += dfs(x + dx[d], y + dy[d], ex, ey, open - 1);
19:         }
20:         vis[x][y] = false;
21:         return ans;
22:     }
23:                    
24:     public int uniquePathsIII(int[][] _grid) {
25:         grid = _grid;
26:         int n = grid.length;
27:         int m = grid[0].length;
28:         vis = new boolean[n][m];
29:         int open = 0;
30:         int sx = -1;
31:         int sy = -1;
32:         int ex = -1;
33:         int ey = -1;
34:         for (int i = 0; i < n; ++i) {
35:             for (int j = 0; j < m; ++j) {
36:                 if (grid[i][j] == 1) {
37:                     sx = i;
38:                     sy = j;
39:                     grid[i][j] = 0;
40:                 } else if (grid[i][j] == 2) {
41:                     ex = i;
42:                     ey = j;
43:                     grid[i][j] = 0;
44:                 }
45:                 
46:                 if (grid[i][j] == 0) {
47:                     open++;
48:                 }
49:             }
50:         }
51:         
52:         return dfs(sx, sy, ex, ey, open);
53:     }
54:     public static void main(String[] args) {
55:         Dfs dfsSolver = new Dfs();
56:         int[][] grid = {
57:             {1, 0, 0, 0},
58:             {0, 0, 0, 0},
59:             {0, 0, 2, -1}
60:         };
61:         
62:         int result = dfsSolver.uniquePathsIII(grid);
63:         System.out.println(""Unique Paths III: "" + result);
64:     }
65: }","[62, 52, 7, 8, 9, 12, 13, 15, 16, 18, 20, 21, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 46, 47]","{'output': ['62', '52', '7', '8', '9', '12', '13', '15', '16', '18', '20', '21', '24', '25', '26', '27', '28', '29', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '40', '41', '42', '43', '46', '47']}","[62, 52, 24, 25, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 46, 47]","{'output': ['62', '52', '24', '25', '29', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '40', '41', '42', '43', '46', '47']}","[62, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24]","{'output': ['62', '52', '51', '50', '49', '48', '47', '46', '45', '44', '43', '42', '41', '40', '39', '38', '37', '36', '35', '34', '33', '32', '31', '30', '29', '28', '27', '26', '25', '24']}"
"import java.util.*;

class DiagonalSort {
    public int[][] diagonalSort(int[][] mat) {
        int n = mat.length;
        int m = mat[0].length;
        HashMap<Integer, ArrayList<Integer>> hm = new HashMap<>();
        HashMap<Integer, Integer> ind = new HashMap<>();
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                int d = i-j;
                if (!hm.containsKey(d))
                    hm.put(d, new ArrayList<>());
                hm.get(d).add(mat[i][j]);
                ind.put(d, hm.get(d).size()-1);
            }
        }
        for (int k : hm.keySet()) {
            Collections.sort(hm.get(k));
        }
        int[][] ans = new int[n][m];
        for (int i = n-1; i >= 0; --i) {
            for (int j = m-1; j >= 0; --j) {
                ans[i][j] = hm.get(i-j).get(ind.get(i-j));
                ind.put(i-j, ind.get(i-j)-1);
            }
        }
        return ans;
    }
    public static void main(String[] args) {
        DiagonalSort diagonalSort = new DiagonalSort();
        int[][] mat = {
            {3, 3, 1, 1},
            {2, 2, 1, 2},
            {1, 1, 1, 2}
        };

        int[][] sortedMat = diagonalSort.diagonalSort(mat);
        System.out.println(""Sorted Matrix Diagonally:"");
        for (int i = 0; i < sortedMat.length; i++) {
            for (int j = 0; j < sortedMat[i].length; j++) {
                System.out.print(sortedMat[i][j] + "" "");
            }
            System.out.println();
        }
    }
}",DiagonalSort,38,"[31, 3, 32, 38, 5, 6, 21, 28]","1: import java.util.*;
2: 
3: class DiagonalSort {
4:     public int[][] diagonalSort(int[][] mat) {
5:         int n = mat.length;
6:         int m = mat[0].length;
7:         HashMap<Integer, ArrayList<Integer>> hm = new HashMap<>();
8:         HashMap<Integer, Integer> ind = new HashMap<>();
9:         for (int i = 0; i < n; ++i) {
10:             for (int j = 0; j < m; ++j) {
11:                 int d = i-j;
12:                 if (!hm.containsKey(d))
13:                     hm.put(d, new ArrayList<>());
14:                 hm.get(d).add(mat[i][j]);
15:                 ind.put(d, hm.get(d).size()-1);
16:             }
17:         }
18:         for (int k : hm.keySet()) {
19:             Collections.sort(hm.get(k));
20:         }
21:         int[][] ans = new int[n][m];
22:         for (int i = n-1; i >= 0; --i) {
23:             for (int j = m-1; j >= 0; --j) {
24:                 ans[i][j] = hm.get(i-j).get(ind.get(i-j));
25:                 ind.put(i-j, ind.get(i-j)-1);
26:             }
27:         }
28:         return ans;
29:     }
30:     public static void main(String[] args) {
31:         DiagonalSort diagonalSort = new DiagonalSort();
32:         int[][] mat = {
33:             {3, 3, 1, 1},
34:             {2, 2, 1, 2},
35:             {1, 1, 1, 2}
36:         };
37: 
38:         int[][] sortedMat = diagonalSort.diagonalSort(mat);
39:         System.out.println(""Sorted Matrix Diagonally:"");
40:         for (int i = 0; i < sortedMat.length; i++) {
41:             for (int j = 0; j < sortedMat[i].length; j++) {
42:                 System.out.print(sortedMat[i][j] + "" "");
43:             }
44:             System.out.println();
45:         }
46:     }
47: }","[38, 31, 32, 33, 34, 35, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 21, 22, 23, 24, 25, 26, 28]","{'output': ['38', '31', '32', '33', '34', '35', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '21', '22', '23', '24', '25', '26', '28']}","[38, 31, 32, 33, 34, 35, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 17, 18, 19, 21, 22, 23, 24, 25, 27, 28]","{'output': ['38', '31', '32', '33', '34', '35', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '17', '18', '19', '21', '22', '23', '24', '25', '27', '28']}","[38, 37, 36, 35, 34, 33, 32, 31, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28]","{'output': ['38', '37', '36', '35', '34', '33', '32', '31', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24', '25', '26', '27', '28']}"
"import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class FileSystem {
    private static class File {
        boolean isDir;
        Map<String, File> files;
        StringBuilder content;

        public File(boolean isDir) {
            this.isDir = isDir;
            if (isDir) {
                files = new HashMap<>();
            } else {
                content = new StringBuilder();
            }
        }
    }

    File root;

    public FileSystem() {
        root = new File(true);
    }

    public List<String> ls(String path) {
        String[] names = path.split(""/"");
        File cur = root;
        for (String name : names) {
            if (!name.isEmpty()) {
                cur = cur.files.get(name);
            }
        }
        if (cur.isDir) {
            ArrayList<String> strings = new ArrayList<>(cur.files.keySet());
            Collections.sort(strings);
            return strings;
        } else {
            return Collections.singletonList(names[names.length - 1]);
        }
    }

    public void mkdir(String path) {
        String[] names = path.split(""/"");
        File cur = root;
        for (String name : names) {
            if (!name.isEmpty()) {
                if (!cur.files.containsKey(name)) {
                    cur.files.put(name, new File(true));
                }
                cur = cur.files.get(name);
            }
        }
    }

    public void addContentToFile(String filePath, String content) {
        String[] names = filePath.split(""/"");
        File cur = root;
        for (int i = 0; i < names.length; i++) {
            String name = names[i];
            if (!name.isEmpty()) {
                if (i == names.length - 1 && !cur.files.containsKey(name)) {
                    cur.files.put(name, new File(false));
                }
                cur = cur.files.get(name);
            }
        }
        cur.content.append(content);
    }

    public String readContentFromFile(String filePath) {
        String[] names = filePath.split(""/"");
        File cur = root;
        for (String name : names) {
            if (!name.isEmpty()) {
                cur = cur.files.get(name);
            }
        }
        return cur.content.toString();
    }

    public static void main(String[] args) {
        FileSystem fileSystem = new FileSystem();
        fileSystem.mkdir(""/goowmfn"");
        System.out.println(fileSystem.ls(""/""));
        System.out.println(fileSystem.ls(""/goowmfn""));
        fileSystem.mkdir(""/z"");
        System.out.println(fileSystem.ls(""/""));
        System.out.println(fileSystem.ls(""/""));
        fileSystem.addContentToFile(""/goowmfn/c"", ""shetopcy"");
        System.out.println(fileSystem.ls(""/goowmfn/c""));

    }
}

/**
 * Your FileSystem object will be instantiated and called as such:
 * FileSystem obj = new FileSystem();
 * List<String> param_1 = obj.ls(path);
 * obj.mkdir(path);
 * obj.addContentToFile(filePath,content);
 * String param_4 = obj.readContentFromFile(filePath);
 */",FileSystem,93,"[86, 25, 87, 90, 93]","1: import java.util.ArrayList;
2: import java.util.Collections;
3: import java.util.HashMap;
4: import java.util.List;
5: import java.util.Map;
6: 
7: public class FileSystem {
8:     private static class File {
9:         boolean isDir;
10:         Map<String, File> files;
11:         StringBuilder content;
12: 
13:         public File(boolean isDir) {
14:             this.isDir = isDir;
15:             if (isDir) {
16:                 files = new HashMap<>();
17:             } else {
18:                 content = new StringBuilder();
19:             }
20:         }
21:     }
22: 
23:     File root;
24: 
25:     public FileSystem() {
26:         root = new File(true);
27:     }
28: 
29:     public List<String> ls(String path) {
30:         String[] names = path.split(""/"");
31:         File cur = root;
32:         for (String name : names) {
33:             if (!name.isEmpty()) {
34:                 cur = cur.files.get(name);
35:             }
36:         }
37:         if (cur.isDir) {
38:             ArrayList<String> strings = new ArrayList<>(cur.files.keySet());
39:             Collections.sort(strings);
40:             return strings;
41:         } else {
42:             return Collections.singletonList(names[names.length - 1]);
43:         }
44:     }
45: 
46:     public void mkdir(String path) {
47:         String[] names = path.split(""/"");
48:         File cur = root;
49:         for (String name : names) {
50:             if (!name.isEmpty()) {
51:                 if (!cur.files.containsKey(name)) {
52:                     cur.files.put(name, new File(true));
53:                 }
54:                 cur = cur.files.get(name);
55:             }
56:         }
57:     }
58: 
59:     public void addContentToFile(String filePath, String content) {
60:         String[] names = filePath.split(""/"");
61:         File cur = root;
62:         for (int i = 0; i < names.length; i++) {
63:             String name = names[i];
64:             if (!name.isEmpty()) {
65:                 if (i == names.length - 1 && !cur.files.containsKey(name)) {
66:                     cur.files.put(name, new File(false));
67:                 }
68:                 cur = cur.files.get(name);
69:             }
70:         }
71:         cur.content.append(content);
72:     }
73: 
74:     public String readContentFromFile(String filePath) {
75:         String[] names = filePath.split(""/"");
76:         File cur = root;
77:         for (String name : names) {
78:             if (!name.isEmpty()) {
79:                 cur = cur.files.get(name);
80:             }
81:         }
82:         return cur.content.toString();
83:     }
84: 
85:     public static void main(String[] args) {
86:         FileSystem fileSystem = new FileSystem();
87:         fileSystem.mkdir(""/goowmfn"");
88:         System.out.println(fileSystem.ls(""/""));
89:         System.out.println(fileSystem.ls(""/goowmfn""));
90:         fileSystem.mkdir(""/z"");
91:         System.out.println(fileSystem.ls(""/""));
92:         System.out.println(fileSystem.ls(""/""));
93:         fileSystem.addContentToFile(""/goowmfn/c"", ""shetopcy"");
94:         System.out.println(fileSystem.ls(""/goowmfn/c""));
95: 
96:     }
97: }
98: 
99: /**
100:  * Your FileSystem object will be instantiated and called as such:
101:  * FileSystem obj = new FileSystem();
102:  * List<String> param_1 = obj.ls(path);
103:  * obj.mkdir(path);
104:  * obj.addContentToFile(filePath,content);
105:  * String param_4 = obj.readContentFromFile(filePath);
106:  */","[93, 59, 60, 61, 62, 63, 64, 65, 66, 68, 71]","{'output': ['93', '59', '60', '61', '62', '63', '64', '65', '66', '68', '71']}","[93, 59, 60, 61, 62, 63, 64, 65, 66, 68, 71, 8, 9, 10, 11, 13, 14, 15, 16, 18, 25, 26]","{'output': ['93', '59', '60', '61', '62', '63', '64', '65', '66', '68', '71', '8', '9', '10', '11', '13', '14', '15', '16', '18', '25', '26']}","[93, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 71, 8, 10, 11, 13, 14, 15, 16, 18, 19]","{'output': ['93', '59', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '71', '8', '10', '11', '13', '14', '15', '16', '18', '19']}"
"import java.util.*;

public class FindBlackPixel {
    public int findBlackPixel(char[][] picture, int N) {
        int m=picture.length; if (m==0) return 0;
        int n=picture[0].length;
        String[] rowStrings=new String[m];
        for (int i=0;i<m;i++) rowStrings[i]=new String(picture[i]);
        int[] row=new int[m];
        HashSet<Integer>[] col=new HashSet[n];
        for (int i=0;i<n;i++) col[i]=new HashSet<>();
        for (int i=0;i<m;i++) {
            for (int j=0;j<n;j++) {
                if (picture[i][j]=='B') {
                    row[i]++;
                    col[j].add(i);
                }
            }
        }
        int cnt=0;
        for (int i=0;i<m;i++) {
            for (int j=0;j<n;j++) {
                if (picture[i][j]=='B' && row[i]==N && col[j].size()==N) {
                    boolean able=true;
                    for (int id: col[j]) {
                        if (!rowStrings[id].equals(rowStrings[i])) {
                            able=false;break;
                        }
                    }
                    if (able) cnt++;
                }
            }
        }
        return cnt;
    }
     public static void main(String[] args) {
        FindBlackPixel findBlackPixel = new FindBlackPixel();
        char[][] picture = {
            {'W', 'B', 'W', 'B', 'B', 'W'},
            {'W', 'B', 'W', 'B', 'B', 'W'},
            {'W', 'B', 'W', 'B', 'B', 'W'},
            {'W', 'W', 'B', 'W', 'B', 'W'}
        };
        int N = 3;
        int result = findBlackPixel.findBlackPixel(picture, N);
        System.out.println(""Number of black pixels: "" + result);
    }
}",FindBlackPixel,45,"[37, 3, 38, 45, 5, 20, 24, 30, 34]","1: import java.util.*;
2: 
3: public class FindBlackPixel {
4:     public int findBlackPixel(char[][] picture, int N) {
5:         int m=picture.length; if (m==0) return 0;
6:         int n=picture[0].length;
7:         String[] rowStrings=new String[m];
8:         for (int i=0;i<m;i++) rowStrings[i]=new String(picture[i]);
9:         int[] row=new int[m];
10:         HashSet<Integer>[] col=new HashSet[n];
11:         for (int i=0;i<n;i++) col[i]=new HashSet<>();
12:         for (int i=0;i<m;i++) {
13:             for (int j=0;j<n;j++) {
14:                 if (picture[i][j]=='B') {
15:                     row[i]++;
16:                     col[j].add(i);
17:                 }
18:             }
19:         }
20:         int cnt=0;
21:         for (int i=0;i<m;i++) {
22:             for (int j=0;j<n;j++) {
23:                 if (picture[i][j]=='B' && row[i]==N && col[j].size()==N) {
24:                     boolean able=true;
25:                     for (int id: col[j]) {
26:                         if (!rowStrings[id].equals(rowStrings[i])) {
27:                             able=false;break;
28:                         }
29:                     }
30:                     if (able) cnt++;
31:                 }
32:             }
33:         }
34:         return cnt;
35:     }
36:      public static void main(String[] args) {
37:         FindBlackPixel findBlackPixel = new FindBlackPixel();
38:         char[][] picture = {
39:             {'W', 'B', 'W', 'B', 'B', 'W'},
40:             {'W', 'B', 'W', 'B', 'B', 'W'},
41:             {'W', 'B', 'W', 'B', 'B', 'W'},
42:             {'W', 'W', 'B', 'W', 'B', 'W'}
43:         };
44:         int N = 3;
45:         int result = findBlackPixel.findBlackPixel(picture, N);
46:         System.out.println(""Number of black pixels: "" + result);
47:     }
48: }","[45, 37, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 30, 32, 33, 34]","{'output': ['45', '37', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '18', '19', '20', '21', '22', '23', '24', '25', '26', '27', '28', '30', '32', '33', '34']}","[45, 44, 37, 4, 34]","{'output': ['45', '44', '37', '4', '34']}","[45, 37, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 32, 33, 34]","{'output': ['45', '37', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '18', '19', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '30', '32', '33', '34']}"
"import java.util.*;

public class FindDiagonalOrder {

	public int[] findDiagonalOrder(int[][] matrix) {
		
		int i , n = matrix.length;
		if (n == 0)
			return new int[] { };
		else {
			
			List<Integer> list = new ArrayList<Integer>();
			int m = matrix[0].length , x = 0 , y = 0 , cnt = 0;
			boolean rightUp = true;
			while (cnt < n * m) {
		
				list.add(matrix[x][y]);
				if (rightUp) {
					if (x - 1 >= 0 && y + 1 < m) {
						x --;
						y ++;
					} else {
						y ++;
						if (y >= m) {
							y = m - 1;
							x ++;
						}
						rightUp = false;
					}
				} else {
					if (x + 1 < n && y - 1 >= 0) {
						x ++;
						y --;
					} else {
						x ++;
						if (x >= n) {
							x = n - 1;
							y ++;
						}
						rightUp = true;
					}
				}
				
				cnt ++;
			}
			
			int[] ans = new int[list.size()];
			for (i = 0;i < list.size();i ++)
				ans[i] = list.get(i);
			return ans;
			
		}
        
    }
	public static void main(String[] args) {
		FindDiagonalOrder solution = new FindDiagonalOrder();
		int[][] matrix = {
			{1, 2, 3},
			{4, 5, 6},
			{7, 8, 9}
		};

		int[] result = solution.findDiagonalOrder(matrix);
		System.out.println(""Diagonal Order: "" + Arrays.toString(result));
}

}",FindDiagonalOrder,63,"[56, 3, 57, 63, 7, 8, 12, 13, 14, 15, 17, 18, 19, 23, 28, 44, 31, 32, 33, 35, 40, 20, 21, 24, 25, 26, 36, 37, 38, 47, 48, 49, 50]","1: import java.util.*;
2: 
3: public class FindDiagonalOrder {
4: 
5: 	public int[] findDiagonalOrder(int[][] matrix) {
6: 		
7: 		int i , n = matrix.length;
8: 		if (n == 0)
9: 			return new int[] { };
10: 		else {
11: 			
12: 			List<Integer> list = new ArrayList<Integer>();
13: 			int m = matrix[0].length , x = 0 , y = 0 , cnt = 0;
14: 			boolean rightUp = true;
15: 			while (cnt < n * m) {
16: 		
17: 				list.add(matrix[x][y]);
18: 				if (rightUp) {
19: 					if (x - 1 >= 0 && y + 1 < m) {
20: 						x --;
21: 						y ++;
22: 					} else {
23: 						y ++;
24: 						if (y >= m) {
25: 							y = m - 1;
26: 							x ++;
27: 						}
28: 						rightUp = false;
29: 					}
30: 				} else {
31: 					if (x + 1 < n && y - 1 >= 0) {
32: 						x ++;
33: 						y --;
34: 					} else {
35: 						x ++;
36: 						if (x >= n) {
37: 							x = n - 1;
38: 							y ++;
39: 						}
40: 						rightUp = true;
41: 					}
42: 				}
43: 				
44: 				cnt ++;
45: 			}
46: 			
47: 			int[] ans = new int[list.size()];
48: 			for (i = 0;i < list.size();i ++)
49: 				ans[i] = list.get(i);
50: 			return ans;
51: 			
52: 		}
53:         
54:     }
55: 	public static void main(String[] args) {
56: 		FindDiagonalOrder solution = new FindDiagonalOrder();
57: 		int[][] matrix = {
58: 			{1, 2, 3},
59: 			{4, 5, 6},
60: 			{7, 8, 9}
61: 		};
62: 
63: 		int[] result = solution.findDiagonalOrder(matrix);
64: 		System.out.println(""Diagonal Order: "" + Arrays.toString(result));
65: }
66: 
67: }","[63, 5, 7, 8, 9, 12, 13, 15, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 44, 47, 48, 49, 50]","{'output': ['63', '5', '7', '8', '9', '12', '13', '15', '17', '18', '19', '20', '21', '22', '23', '24', '25', '26', '27', '28', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '40', '44', '47', '48', '49', '50']}","[63, 56, 5]","{'output': ['63', '56', '5']}","[63, 56, 5, 7, 8, 12, 13, 14, 15, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 44, 45, 47, 48, 49, 50]","{'output': ['63', '56', '5', '7', '8', '12', '13', '14', '15', '17', '18', '19', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '40', '41', '42', '44', '45', '47', '48', '49', '50']}"
"	class FindGoodStrings {
    	int mod = 1000000007;
	    public int findGoodStrings(int n, String s1, String s2, String evil) {
	    	int[] mp = mpTable(evil.toCharArray());
	    	long ret = count(s2.toCharArray(), n, mp, evil.toCharArray()) - count(s1.toCharArray(), n, mp, evil.toCharArray()) + mod;
	    	if(s1.indexOf(evil) < 0)ret++;
	    	return (int)(ret%mod);
//	    	int p = 0;
//	    	for(int i = 0;i < haystack.length;i++){
//	    		while(p >= 0 && needle[p] != haystack[i])p = kmp[p];
//	    		if(++p == needle.length){
//	    			out.println(i-needle.length+1);
//	    			p = kmp[p];
//	    		}

	    }
	    
	    long count(char[] s, int n, int[] mp, char[] needle)
	    {
	    	int m = mp.length-1;
	    	long[] dp = new long[m];
	    	dp[0] = 1;
	    	int edge = 0;
	    	for(int i = 0;i < n;i++){
	    		long[] ndp = new long[m];
	    		for(int j = 0;j < m;j++){
	    			for(int k = 0;k < 26;k++){
	    				int p = j;
	    	    		while(p >= 0 && needle[p]-'a' != k){
	    	    			p = mp[p];
	    	    		}
	    	    		if(++p < needle.length){
	    	    			ndp[p] += dp[j];
	    	    			if(ndp[p] >= mod)ndp[p] -= mod;
	    	    		}
	    			}
	    		}
	    		if(edge != needle.length){
		    		for(int k = 0;k < s[i]-'a';k++){
	    				int p = edge;
	    	    		while(p >= 0 && needle[p]-'a' != k){
	    	    			p = mp[p];
	    	    		}
	    	    		if(++p < needle.length){
	    	    			ndp[p] += 1;
	    	    			if(ndp[p] >= mod)ndp[p] -= mod;
	    	    		}
		    		}
		    		
    				int p = edge;
    	    		while(p >= 0 && needle[p] != s[i]){
    	    			p = mp[p];
    	    		}
    	    		++p;
    	    		edge = p;
	    		}
	    		
	    		dp = ndp;
	    	}
	    	
	    	long ret = 0;
	    	if(edge != needle.length)ret++;
	    	for(long v : dp)ret += v;
	    	return ret%mod;
	    }
	    
		public int[] mpTable(char[] str)
		{
			int n = str.length;
			int[] mp = new int[n+1];
			mp[0] = -1;
			for(int i = 1, j = 0;i < n;i++){
				while(j >= 0 && str[i] != str[j])j = mp[j];
				mp[i+1] = ++j;
			}
			return mp;
		}
	public static void main(String[] args) {
		FindGoodStrings findGoodStrings = new FindGoodStrings();
		int n = 3;
		String s1 = ""abc"";
		String s2 = ""bcd"";
		String evil = ""c"";

		int result = findGoodStrings.findGoodStrings(n, s1, s2, evil);
		System.out.println(""Number of good strings: "" + result);
}

	}	
",FindGoodStrings,85,"[79, 1, 2, 85, 4, 69, 70, 71, 76, 5, 20, 21, 22, 23, 24, 25, 26, 27, 28, 30, 32, 33, 38, 39, 40, 42, 44, 45, 50, 52, 54, 55, 58, 61, 63, 64, 7]","1: 	class FindGoodStrings {
2:     	int mod = 1000000007;
3: 	    public int findGoodStrings(int n, String s1, String s2, String evil) {
4: 	    	int[] mp = mpTable(evil.toCharArray());
5: 	    	long ret = count(s2.toCharArray(), n, mp, evil.toCharArray()) - count(s1.toCharArray(), n, mp, evil.toCharArray()) + mod;
6: 	    	if(s1.indexOf(evil) < 0)ret++;
7: 	    	return (int)(ret%mod);
8: //	    	int p = 0;
9: //	    	for(int i = 0;i < haystack.length;i++){
10: //	    		while(p >= 0 && needle[p] != haystack[i])p = kmp[p];
11: //	    		if(++p == needle.length){
12: //	    			out.println(i-needle.length+1);
13: //	    			p = kmp[p];
14: //	    		}
15: 
16: 	    }
17: 	    
18: 	    long count(char[] s, int n, int[] mp, char[] needle)
19: 	    {
20: 	    	int m = mp.length-1;
21: 	    	long[] dp = new long[m];
22: 	    	dp[0] = 1;
23: 	    	int edge = 0;
24: 	    	for(int i = 0;i < n;i++){
25: 	    		long[] ndp = new long[m];
26: 	    		for(int j = 0;j < m;j++){
27: 	    			for(int k = 0;k < 26;k++){
28: 	    				int p = j;
29: 	    	    		while(p >= 0 && needle[p]-'a' != k){
30: 	    	    			p = mp[p];
31: 	    	    		}
32: 	    	    		if(++p < needle.length){
33: 	    	    			ndp[p] += dp[j];
34: 	    	    			if(ndp[p] >= mod)ndp[p] -= mod;
35: 	    	    		}
36: 	    			}
37: 	    		}
38: 	    		if(edge != needle.length){
39: 		    		for(int k = 0;k < s[i]-'a';k++){
40: 	    				int p = edge;
41: 	    	    		while(p >= 0 && needle[p]-'a' != k){
42: 	    	    			p = mp[p];
43: 	    	    		}
44: 	    	    		if(++p < needle.length){
45: 	    	    			ndp[p] += 1;
46: 	    	    			if(ndp[p] >= mod)ndp[p] -= mod;
47: 	    	    		}
48: 		    		}
49: 		    		
50:     				int p = edge;
51:     	    		while(p >= 0 && needle[p] != s[i]){
52:     	    			p = mp[p];
53:     	    		}
54:     	    		++p;
55:     	    		edge = p;
56: 	    		}
57: 	    		
58: 	    		dp = ndp;
59: 	    	}
60: 	    	
61: 	    	long ret = 0;
62: 	    	if(edge != needle.length)ret++;
63: 	    	for(long v : dp)ret += v;
64: 	    	return ret%mod;
65: 	    }
66: 	    
67: 		public int[] mpTable(char[] str)
68: 		{
69: 			int n = str.length;
70: 			int[] mp = new int[n+1];
71: 			mp[0] = -1;
72: 			for(int i = 1, j = 0;i < n;i++){
73: 				while(j >= 0 && str[i] != str[j])j = mp[j];
74: 				mp[i+1] = ++j;
75: 			}
76: 			return mp;
77: 		}
78: 	public static void main(String[] args) {
79: 		FindGoodStrings findGoodStrings = new FindGoodStrings();
80: 		int n = 3;
81: 		String s1 = ""abc"";
82: 		String s2 = ""bcd"";
83: 		String evil = ""c"";
84: 
85: 		int result = findGoodStrings.findGoodStrings(n, s1, s2, evil);
86: 		System.out.println(""Number of good strings: "" + result);
87: }
88: 
89: 	}	
90: ","[85, 3, 4, 5, 6, 7, 2, 18, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 50, 51, 52, 53, 54, 55, 56, 58, 59, 61, 62, 63, 64, 67, 69, 70, 71, 72, 73, 74, 75, 76]","{'output': ['85', '3', '4', '5', '6', '7', '2', '18', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '40', '41', '42', '43', '44', '45', '46', '47', '48', '50', '51', '52', '53', '54', '55', '56', '58', '59', '61', '62', '63', '64', '67', '69', '70', '71', '72', '73', '74', '75', '76']}","[85, 3, 4, 5, 6, 2, 18, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 50, 51, 52, 53, 54, 55, 56, 58, 59, 61, 62, 63, 64, 67, 69, 70, 71, 72, 73, 74, 75, 76, 80, 81, 82, 83]","{'output': ['85', '3', '4', '5', '6', '2', '18', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '40', '41', '42', '43', '44', '45', '46', '47', '48', '50', '51', '52', '53', '54', '55', '56', '58', '59', '61', '62', '63', '64', '67', '69', '70', '71', '72', '73', '74', '75', '76', '80', '81', '82', '83']}","[85, 3, 4, 5, 6, 7, 2, 18, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 32, 33, 34, 36, 38, 39, 40, 41, 42, 44, 45, 46, 48, 50, 51, 52, 54, 55, 58, 59, 61, 62, 63, 64, 67, 69, 70, 71, 72, 73, 74, 75, 76]","{'output': ['85', '3', '4', '5', '6', '7', '2', '18', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '30', '32', '33', '34', '36', '38', '39', '40', '41', '42', '44', '45', '46', '48', '50', '51', '52', '54', '55', '58', '59', '61', '62', '63', '64', '67', '69', '70', '71', '72', '73', '74', '75', '76']}"
"public class FindMaxConsecutiveOnes {
    public int findMaxConsecutiveOnes(int[] nums) {
        int n = nums.length, con = 0, res = 0;
        int[] dp = new int [n];
        for (int i = 0; i < n; i ++) {
            if (nums[i] == 1) {
                con ++;
                dp[i] = con;
            } else {
                con = 0;
            }
        }
        con = 0;
        for (int i = n - 1; i >= 0; i --) {
            int head = i - 1 >= 0 ? dp[i - 1] : 0;
            int one = head + con + 1;
            res = Math.max(one, res);
            if (nums[i] == 1) {
                con ++;
            } else con = 0;
        }
        return res;
    }
    public static void main(String[] args) {
        FindMaxConsecutiveOnes findMaxConsecutiveOnes = new FindMaxConsecutiveOnes();
        int[] nums = {1, 0, 1, 1, 0};
        int result = findMaxConsecutiveOnes.findMaxConsecutiveOnes(nums);
        System.out.println(""Maximum number of consecutive ones: "" + result);
    }
}",FindMaxConsecutiveOnes,27,"[25, 1, 26, 27, 3, 4, 5, 6, 7, 8, 10, 13, 14, 15, 16, 17, 18, 20, 19, 22]","1: public class FindMaxConsecutiveOnes {
2:     public int findMaxConsecutiveOnes(int[] nums) {
3:         int n = nums.length, con = 0, res = 0;
4:         int[] dp = new int [n];
5:         for (int i = 0; i < n; i ++) {
6:             if (nums[i] == 1) {
7:                 con ++;
8:                 dp[i] = con;
9:             } else {
10:                 con = 0;
11:             }
12:         }
13:         con = 0;
14:         for (int i = n - 1; i >= 0; i --) {
15:             int head = i - 1 >= 0 ? dp[i - 1] : 0;
16:             int one = head + con + 1;
17:             res = Math.max(one, res);
18:             if (nums[i] == 1) {
19:                 con ++;
20:             } else con = 0;
21:         }
22:         return res;
23:     }
24:     public static void main(String[] args) {
25:         FindMaxConsecutiveOnes findMaxConsecutiveOnes = new FindMaxConsecutiveOnes();
26:         int[] nums = {1, 0, 1, 1, 0};
27:         int result = findMaxConsecutiveOnes.findMaxConsecutiveOnes(nums);
28:         System.out.println(""Maximum number of consecutive ones: "" + result);
29:     }
30: }","[27, 2, 22]","{'output': ['27', '2', '22']}","[27, 26, 25, 2, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3]","{'output': ['27', '26', '25', '2', '22', '21', '20', '19', '18', '17', '16', '15', '14', '13', '12', '11', '10', '9', '8', '7', '6', '5', '4', '3']}","[27, 26, 25, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 13, 14, 15, 16, 17, 18, 19, 20, 22]","{'output': ['27', '26', '25', '2', '3', '4', '5', '6', '7', '8', '9', '10', '12', '13', '14', '15', '16', '17', '18', '19', '20', '22']}"
"/**
 * Definition for a binary tree node. public class TreeNode { int val; TreeNode left; TreeNode
 * right; TreeNode(int x) { val = x; } }
 */
import java.util.*;

public class FindValueMostElement {
  public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode(int x) {
      this.val = x;
    }
  }

  public int[] findValueMostElement(TreeNode root) {
    if (root == null) return new int[0];
    List<Integer> level = new LinkedList<>();

    Queue<TreeNode> que = new LinkedList<>();
    que.add(root);

    while (!que.isEmpty()) {
      int currMax = que.peek().val;
      int size = que.size();

      while (size-- > 0) {
        TreeNode curr = que.remove();

        if (curr.left != null) que.add(curr.left);
        if (curr.right != null) que.add(curr.right);
        currMax = Math.max(currMax, curr.val);
      }

      level.add(currMax);
    }

    int[] maxLevel = new int[level.size()];
    int i = 0;
    for (int c : level) {
      maxLevel[i++] = c;
    }
    return maxLevel;
  }
  public static void main(String[] args) {
    FindValueMostElement solution = new FindValueMostElement();

    // Create a sample tree manually
    TreeNode root = solution.new TreeNode(1);
    root.left = solution.new TreeNode(3);
    root.right = solution.new TreeNode(2);
    root.left.left = solution.new TreeNode(5);
    root.left.right = solution.new TreeNode(3);
    root.right.right = solution.new TreeNode(9);

    int[] result = solution.findValueMostElement(root);
    System.out.println(""The maximum value at each level is: "" + Arrays.toString(result));
}
}
",FindValueMostElement,59,"[48, 7, 51, 52, 53, 54, 55, 56, 58, 19, 20, 22, 23, 25, 26, 27, 29, 32, 33, 34, 37, 40, 42, 43, 45, 59]","1: /**
2:  * Definition for a binary tree node. public class TreeNode { int val; TreeNode left; TreeNode
3:  * right; TreeNode(int x) { val = x; } }
4:  */
5: import java.util.*;
6: 
7: public class FindValueMostElement {
8:   public class TreeNode {
9:     int val;
10:     TreeNode left;
11:     TreeNode right;
12: 
13:     TreeNode(int x) {
14:       this.val = x;
15:     }
16:   }
17: 
18:   public int[] findValueMostElement(TreeNode root) {
19:     if (root == null) return new int[0];
20:     List<Integer> level = new LinkedList<>();
21: 
22:     Queue<TreeNode> que = new LinkedList<>();
23:     que.add(root);
24: 
25:     while (!que.isEmpty()) {
26:       int currMax = que.peek().val;
27:       int size = que.size();
28: 
29:       while (size-- > 0) {
30:         TreeNode curr = que.remove();
31: 
32:         if (curr.left != null) que.add(curr.left);
33:         if (curr.right != null) que.add(curr.right);
34:         currMax = Math.max(currMax, curr.val);
35:       }
36: 
37:       level.add(currMax);
38:     }
39: 
40:     int[] maxLevel = new int[level.size()];
41:     int i = 0;
42:     for (int c : level) {
43:       maxLevel[i++] = c;
44:     }
45:     return maxLevel;
46:   }
47:   public static void main(String[] args) {
48:     FindValueMostElement solution = new FindValueMostElement();
49: 
50:     // Create a sample tree manually
51:     TreeNode root = solution.new TreeNode(1);
52:     root.left = solution.new TreeNode(3);
53:     root.right = solution.new TreeNode(2);
54:     root.left.left = solution.new TreeNode(5);
55:     root.left.right = solution.new TreeNode(3);
56:     root.right.right = solution.new TreeNode(9);
57: 
58:     int[] result = solution.findValueMostElement(root);
59:     System.out.println(""The maximum value at each level is: "" + Arrays.toString(result));
60: }
61: }
62: ","[59, 58, 47, 48, 51, 52, 53, 54, 55, 56, 18, 19, 20, 22, 23, 25, 26, 27, 29, 30, 32, 33, 34, 37, 40, 41, 42, 43, 45]","{'output': ['59', '58', '47', '48', '51', '52', '53', '54', '55', '56', '18', '19', '20', '22', '23', '25', '26', '27', '29', '30', '32', '33', '34', '37', '40', '41', '42', '43', '45']}","[59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 47]","{'output': ['59', '58', '57', '56', '55', '54', '53', '52', '51', '50', '49', '47']}","[59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 48, 47]","{'output': ['59', '58', '57', '56', '55', '54', '53', '52', '51', '50', '48', '47']}"
"import java.util.*;


  
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
 class FlipMatchVoyage {
    public static class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;
        TreeNode(int x) { val = x; }
    }

   Set<TreeNode> flipped = new HashSet<>();
    Map<TreeNode, TreeNode> parent = new HashMap<>();
    int index = 0;
    List<Integer> ans;

    public List<Integer> flipMatchVoyage(TreeNode root, int[] voyage) {
        flipped = new HashSet<>();
        parent = new HashMap<>();
        index = 0;
        ans = new ArrayList<>();

        List<Integer> allValues = new ArrayList<>();
        visitAll(root, allValues);
        if (allValues.size() != voyage.length) {
            ans.add(-1);
            return ans;
        }

        genParent(root);

        for (int i = 0; i < voyage.length; i++) {
            index = 0;
            int ret = dfs(root, voyage);
            if (ret == 0) return ans;
            else if (ret == -1) {
                ans = new ArrayList<>();
                ans.add(-1);
                return ans;
            }
        }

        return ans;
    }

    private void visitAll(TreeNode root, List<Integer> list) {
        if (root == null) return;
        list.add(root.val);
        visitAll(root.left, list);
        visitAll(root.right, list);
    }

    private void genParent(TreeNode root) {
        if (root == null) {
            return;
        }
        if (root.left != null) {
            parent.put(root.left, root);
        }

        if (root.right != null) {
            parent.put(root.right, root);
        }

        genParent(root.left);
        genParent(root.right);
    }

    private int dfs(TreeNode root, int[] voyage) {
        if (root == null) return 0;

        if (root.val != voyage[index]) {
            TreeNode p = parent.get(root);
            if (p == null || flipped.contains(p)) {
                ans = new ArrayList<>();
                ans.add(-1);
                return -1;
            } else {
                ans.add(p.val);
                flipped.add(p);
                TreeNode t = p.left;
                p.left = p.right;
                p.right = t;
            }
            return 1;
        } else {
            if (root.left != null) {
                index++;
                int ret = dfs(root.left, voyage);
                if (ret != 0) return ret;
            }

            if (root.right != null) {
                index++;
                int ret = dfs(root.right, voyage);
                if (ret != 0) return ret;
            }

            return 0;
        }
    }


     public static void main(String[] args) {
        FlipMatchVoyage solution = new FlipMatchVoyage();
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(2);
        root.right = new TreeNode(3);

        int[] voyage = {1, 3, 2};
        List<Integer> result = solution.flipMatchVoyage(root, voyage);
        System.out.println(""Result: "" + result);
    }


}",FlipMatchVoyage,121,"[115, 14, 22, 23, 24, 116, 117, 118, 120, 121, 28, 29, 30, 31, 33, 34, 57, 58, 59, 60, 35, 40, 64, 67, 68, 71, 72, 75, 76, 42, 43, 44, 80, 82, 97, 99, 89, 91, 92, 93, 98, 103, 109, 100, 45]","1: import java.util.*;
2: 
3: 
4:   
5: /**
6:  * Definition for a binary tree node.
7:  * public class TreeNode {
8:  *     int val;
9:  *     TreeNode left;
10:  *     TreeNode right;
11:  *     TreeNode(int x) { val = x; }
12:  * }
13:  */
14:  class FlipMatchVoyage {
15:     public static class TreeNode {
16:         int val;
17:         TreeNode left;
18:         TreeNode right;
19:         TreeNode(int x) { val = x; }
20:     }
21: 
22:    Set<TreeNode> flipped = new HashSet<>();
23:     Map<TreeNode, TreeNode> parent = new HashMap<>();
24:     int index = 0;
25:     List<Integer> ans;
26: 
27:     public List<Integer> flipMatchVoyage(TreeNode root, int[] voyage) {
28:         flipped = new HashSet<>();
29:         parent = new HashMap<>();
30:         index = 0;
31:         ans = new ArrayList<>();
32: 
33:         List<Integer> allValues = new ArrayList<>();
34:         visitAll(root, allValues);
35:         if (allValues.size() != voyage.length) {
36:             ans.add(-1);
37:             return ans;
38:         }
39: 
40:         genParent(root);
41: 
42:         for (int i = 0; i < voyage.length; i++) {
43:             index = 0;
44:             int ret = dfs(root, voyage);
45:             if (ret == 0) return ans;
46:             else if (ret == -1) {
47:                 ans = new ArrayList<>();
48:                 ans.add(-1);
49:                 return ans;
50:             }
51:         }
52: 
53:         return ans;
54:     }
55: 
56:     private void visitAll(TreeNode root, List<Integer> list) {
57:         if (root == null) return;
58:         list.add(root.val);
59:         visitAll(root.left, list);
60:         visitAll(root.right, list);
61:     }
62: 
63:     private void genParent(TreeNode root) {
64:         if (root == null) {
65:             return;
66:         }
67:         if (root.left != null) {
68:             parent.put(root.left, root);
69:         }
70: 
71:         if (root.right != null) {
72:             parent.put(root.right, root);
73:         }
74: 
75:         genParent(root.left);
76:         genParent(root.right);
77:     }
78: 
79:     private int dfs(TreeNode root, int[] voyage) {
80:         if (root == null) return 0;
81: 
82:         if (root.val != voyage[index]) {
83:             TreeNode p = parent.get(root);
84:             if (p == null || flipped.contains(p)) {
85:                 ans = new ArrayList<>();
86:                 ans.add(-1);
87:                 return -1;
88:             } else {
89:                 ans.add(p.val);
90:                 flipped.add(p);
91:                 TreeNode t = p.left;
92:                 p.left = p.right;
93:                 p.right = t;
94:             }
95:             return 1;
96:         } else {
97:             if (root.left != null) {
98:                 index++;
99:                 int ret = dfs(root.left, voyage);
100:                 if (ret != 0) return ret;
101:             }
102: 
103:             if (root.right != null) {
104:                 index++;
105:                 int ret = dfs(root.right, voyage);
106:                 if (ret != 0) return ret;
107:             }
108: 
109:             return 0;
110:         }
111:     }
112: 
113: 
114:      public static void main(String[] args) {
115:         FlipMatchVoyage solution = new FlipMatchVoyage();
116:         TreeNode root = new TreeNode(1);
117:         root.left = new TreeNode(2);
118:         root.right = new TreeNode(3);
119: 
120:         int[] voyage = {1, 3, 2};
121:         List<Integer> result = solution.flipMatchVoyage(root, voyage);
122:         System.out.println(""Result: "" + result);
123:     }
124: 
125: 
126: }","[121, 27, 40, 79, 44, 97, 98, 99, 100]","{'output': ['121', '27', '40', '79', '44', '97', '98', '99', '100']}","[121, 27, 28, 29, 30, 31, 40, 63, 64, 67, 68, 71, 72, 75, 76, 42, 43, 44, 79, 80, 82, 83, 84, 85, 86]","{'output': ['121', '27', '28', '29', '30', '31', '40', '63', '64', '67', '68', '71', '72', '75', '76', '42', '43', '44', '79', '80', '82', '83', '84', '85', '86']}","[121, 27, 33, 34, 56, 57, 58, 59, 60, 35, 36, 37, 38, 40, 63, 64, 67, 68, 71, 72, 75, 76, 42, 43, 44, 79, 80, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 95, 96, 97, 98, 99, 100, 103, 104, 105, 106, 109, 53]","{'output': ['121', '27', '33', '34', '56', '57', '58', '59', '60', '35', '36', '37', '38', '40', '63', '64', '67', '68', '71', '72', '75', '76', '42', '43', '44', '79', '80', '82', '83', '84', '85', '86', '87', '88', '89', '90', '91', '92', '93', '95', '96', '97', '98', '99', '100', '103', '104', '105', '106', '109', '53']}"
"	import java.util.*;
	class FreqStack {
		Map<Integer, Integer> map = new HashMap<>(); // heap-id
		Map<Integer, Deque<Integer>> dqs = new HashMap<>();
		MinHeapL h = new MinHeapL(10010);
		int[] imap = new int[10010];
		int gen = 0;
		int time = 0;
		long O = 1000000000;
		
	    public FreqStack() {
	        
	    }
	    
	    public void push(int x) {
	        if(!map.containsKey(x)){
	        	imap[gen] = x;
	        	map.put(x, gen++);
	        	dqs.put(x, new ArrayDeque<>());
	        }
	        h.update(map.get(x), O-dqs.get(x).size()-1<<32|O-time);
	        dqs.get(x).addLast(time++);
	    }
	    
	    public int pop() {
	        int argmin = h.argmin();
	        h.remove(argmin);
	        int x = imap[argmin];
	        dqs.get(x).pollLast();
	        if(!dqs.get(x).isEmpty()){
	        	h.update(map.get(x), O-dqs.get(x).size()<<32|O-dqs.get(x).peekLast());
	        }
	        return x;
	    }
	    
	    class MinHeapL {
	    	public long[] a;
	    	public int[] map;
	    	public int[] imap;
	    	public int n;
	    	public int pos;
	    	public long INF = Long.MAX_VALUE;
	    	
	    	public MinHeapL(int m)
	    	{
	    		n = Integer.highestOneBit((m+1)<<1);
	    		a = new long[n];
	    		map = new int[n];
	    		imap = new int[n];
	    		Arrays.fill(a, INF);
	    		Arrays.fill(map, -1);
	    		Arrays.fill(imap, -1);
	    		pos = 1;
	    	}
	    	
	    	public long add(int ind, long x)
	    	{
	    		int ret = imap[ind];
	    		if(imap[ind] < 0){
	    			a[pos] = x; map[pos] = ind; imap[ind] = pos;
	    			pos++;
	    			up(pos-1);
	    		}
	    		return ret != -1 ? a[ret] : x;
	    	}
	    	
	    	public long update(int ind, long x)
	    	{
	    		int ret = imap[ind];
	    		if(imap[ind] < 0){
	    			a[pos] = x; map[pos] = ind; imap[ind] = pos;
	    			pos++;
	    			up(pos-1);
	    		}else{
	    			a[ret] = x;
	    			up(ret);
	    			down(ret);
	    		}
	    		return x;
	    	}
	    	
	    	public long remove(int ind)
	    	{
	    		if(pos == 1)return INF;
	    		if(imap[ind] == -1)return INF;
	    		
	    		pos--;
	    		int rem = imap[ind];
	    		long ret = a[rem];
	    		map[rem] = map[pos];
	    		imap[map[pos]] = rem;
	    		imap[ind] = -1;
	    		a[rem] = a[pos];
	    		a[pos] = INF;
	    		map[pos] = -1;
	    		
	    		up(rem);
	    		down(rem);
	    		return ret;
	    	}
	    	
	    	public long min() { return a[1]; }
	    	public int argmin() { return map[1]; }
	    	public int size() {	return pos-1; }
	    	
	    	private void up(int cur)
	    	{
	    		for(int c = cur, p = c>>>1;p >= 1 && a[p] > a[c];c>>>=1, p>>>=1){
	    			long d = a[p]; a[p] = a[c]; a[c] = d;
	    			int e = imap[map[p]]; imap[map[p]] = imap[map[c]]; imap[map[c]] = e;
	    			e = map[p]; map[p] = map[c]; map[c] = e;
	    		}
	    	}
	    	
	    	private void down(int cur)
	    	{
	    		for(int c = cur;2*c < pos;){
	    			int b = a[2*c] < a[2*c+1] ? 2*c : 2*c+1;
	    			if(a[b] < a[c]){
	    				long d = a[c]; a[c] = a[b]; a[b] = d;
	    				int e = imap[map[c]]; imap[map[c]] = imap[map[b]]; imap[map[b]] = e;
	    				e = map[c]; map[c] = map[b]; map[b] = e;
	    				c = b;
	    			}else{
	    				break;
	    			}
	    		}
	    	}
	    }
		  public static void main(String[] args) {
        FreqStack freqStack = new FreqStack();
        
        freqStack.push(5);
        freqStack.push(7);
        freqStack.push(5);
        freqStack.push(7);
        freqStack.push(4);
        freqStack.push(5);
        
        System.out.println(freqStack.pop()); // should return 5
        System.out.println(freqStack.pop()); // should return 7
        System.out.println(freqStack.pop()); // should return 5
        System.out.println(freqStack.pop()); // should return 4
    }
	}
",FreqStack,140,"[131, 11, 3, 4, 5, 6, 7, 8, 133, 16, 18, 19, 22, 134, 135, 136, 137, 138, 140, 26, 28, 29, 30, 31, 33]","1: 	import java.util.*;
2: 	class FreqStack {
3: 		Map<Integer, Integer> map = new HashMap<>(); // heap-id
4: 		Map<Integer, Deque<Integer>> dqs = new HashMap<>();
5: 		MinHeapL h = new MinHeapL(10010);
6: 		int[] imap = new int[10010];
7: 		int gen = 0;
8: 		int time = 0;
9: 		long O = 1000000000;
10: 		
11: 	    public FreqStack() {
12: 	        
13: 	    }
14: 	    
15: 	    public void push(int x) {
16: 	        if(!map.containsKey(x)){
17: 	        	imap[gen] = x;
18: 	        	map.put(x, gen++);
19: 	        	dqs.put(x, new ArrayDeque<>());
20: 	        }
21: 	        h.update(map.get(x), O-dqs.get(x).size()-1<<32|O-time);
22: 	        dqs.get(x).addLast(time++);
23: 	    }
24: 	    
25: 	    public int pop() {
26: 	        int argmin = h.argmin();
27: 	        h.remove(argmin);
28: 	        int x = imap[argmin];
29: 	        dqs.get(x).pollLast();
30: 	        if(!dqs.get(x).isEmpty()){
31: 	        	h.update(map.get(x), O-dqs.get(x).size()<<32|O-dqs.get(x).peekLast());
32: 	        }
33: 	        return x;
34: 	    }
35: 	    
36: 	    class MinHeapL {
37: 	    	public long[] a;
38: 	    	public int[] map;
39: 	    	public int[] imap;
40: 	    	public int n;
41: 	    	public int pos;
42: 	    	public long INF = Long.MAX_VALUE;
43: 	    	
44: 	    	public MinHeapL(int m)
45: 	    	{
46: 	    		n = Integer.highestOneBit((m+1)<<1);
47: 	    		a = new long[n];
48: 	    		map = new int[n];
49: 	    		imap = new int[n];
50: 	    		Arrays.fill(a, INF);
51: 	    		Arrays.fill(map, -1);
52: 	    		Arrays.fill(imap, -1);
53: 	    		pos = 1;
54: 	    	}
55: 	    	
56: 	    	public long add(int ind, long x)
57: 	    	{
58: 	    		int ret = imap[ind];
59: 	    		if(imap[ind] < 0){
60: 	    			a[pos] = x; map[pos] = ind; imap[ind] = pos;
61: 	    			pos++;
62: 	    			up(pos-1);
63: 	    		}
64: 	    		return ret != -1 ? a[ret] : x;
65: 	    	}
66: 	    	
67: 	    	public long update(int ind, long x)
68: 	    	{
69: 	    		int ret = imap[ind];
70: 	    		if(imap[ind] < 0){
71: 	    			a[pos] = x; map[pos] = ind; imap[ind] = pos;
72: 	    			pos++;
73: 	    			up(pos-1);
74: 	    		}else{
75: 	    			a[ret] = x;
76: 	    			up(ret);
77: 	    			down(ret);
78: 	    		}
79: 	    		return x;
80: 	    	}
81: 	    	
82: 	    	public long remove(int ind)
83: 	    	{
84: 	    		if(pos == 1)return INF;
85: 	    		if(imap[ind] == -1)return INF;
86: 	    		
87: 	    		pos--;
88: 	    		int rem = imap[ind];
89: 	    		long ret = a[rem];
90: 	    		map[rem] = map[pos];
91: 	    		imap[map[pos]] = rem;
92: 	    		imap[ind] = -1;
93: 	    		a[rem] = a[pos];
94: 	    		a[pos] = INF;
95: 	    		map[pos] = -1;
96: 	    		
97: 	    		up(rem);
98: 	    		down(rem);
99: 	    		return ret;
100: 	    	}
101: 	    	
102: 	    	public long min() { return a[1]; }
103: 	    	public int argmin() { return map[1]; }
104: 	    	public int size() {	return pos-1; }
105: 	    	
106: 	    	private void up(int cur)
107: 	    	{
108: 	    		for(int c = cur, p = c>>>1;p >= 1 && a[p] > a[c];c>>>=1, p>>>=1){
109: 	    			long d = a[p]; a[p] = a[c]; a[c] = d;
110: 	    			int e = imap[map[p]]; imap[map[p]] = imap[map[c]]; imap[map[c]] = e;
111: 	    			e = map[p]; map[p] = map[c]; map[c] = e;
112: 	    		}
113: 	    	}
114: 	    	
115: 	    	private void down(int cur)
116: 	    	{
117: 	    		for(int c = cur;2*c < pos;){
118: 	    			int b = a[2*c] < a[2*c+1] ? 2*c : 2*c+1;
119: 	    			if(a[b] < a[c]){
120: 	    				long d = a[c]; a[c] = a[b]; a[b] = d;
121: 	    				int e = imap[map[c]]; imap[map[c]] = imap[map[b]]; imap[map[b]] = e;
122: 	    				e = map[c]; map[c] = map[b]; map[b] = e;
123: 	    				c = b;
124: 	    			}else{
125: 	    				break;
126: 	    			}
127: 	    		}
128: 	    	}
129: 	    }
130: 		  public static void main(String[] args) {
131:         FreqStack freqStack = new FreqStack();
132:         
133:         freqStack.push(5);
134:         freqStack.push(7);
135:         freqStack.push(5);
136:         freqStack.push(7);
137:         freqStack.push(4);
138:         freqStack.push(5);
139:         
140:         System.out.println(freqStack.pop()); // should return 5
141:         System.out.println(freqStack.pop()); // should return 7
142:         System.out.println(freqStack.pop()); // should return 5
143:         System.out.println(freqStack.pop()); // should return 4
144:     }
145: 	}
146: ","[140, 25, 26, 103, 83, 88, 89, 90, 91, 92, 93, 94, 95, 28, 29, 30, 31, 18, 17]","{'output': ['140', '25', '26', '103', '83', '88', '89', '90', '91', '92', '93', '94', '95', '28', '29', '30', '31', '18', '17']}","[140, 33, 32, 31, 30, 29, 28, 27, 26, 25, 21, 20, 19, 18, 17, 16, 15, 5, 4, 3, 2, 1]","{'output': ['140', '33', '32', '31', '30', '29', '28', '27', '26', '25', '21', '20', '19', '18', '17', '16', '15', '5', '4', '3', '2', '1']}","[140, 33, 32, 31, 30, 29, 28, 27, 26, 25, 22, 21, 20, 19, 18, 17, 16, 15, 8, 7, 6, 5, 4, 3]","{'output': ['140', '33', '32', '31', '30', '29', '28', '27', '26', '25', '22', '21', '20', '19', '18', '17', '16', '15', '8', '7', '6', '5', '4', '3']}"
"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
import java.util.*;



class GetDirections {
     public static class TreeNode {
     int val;
     TreeNode left;
     TreeNode right;
     TreeNode() {}
     TreeNode(int val) { this.val = val; }
     TreeNode(int val, TreeNode left, TreeNode right) {
         this.val = val;
         this.left = left;
         this.right = right;
     }
 }
    char[] res;
    
    public String getDirections(TreeNode root, int startValue, int destValue) {
        dfs(root, startValue, 0, new char[100005]);
        char[] s = res;
        dfs(root, destValue, 0, new char[100005]);
        char[] t = res;
        int ld = 0;
        for(int i = 0;i < s.length && i < t.length && s[i] == t[i];i++){
            ld = i+1;
        }
        StringBuilder ret = new StringBuilder();
        for(int i = ld;i < s.length;i++)ret.append('U');
        for(int i = ld;i < t.length;i++)ret.append(t[i]);
        return ret.toString();
    }
    
    void dfs(TreeNode cur, int tar, int dep, char[] s)
    {
        if(cur == null)return;
        if(cur.val == tar){
            res = Arrays.copyOf(s, dep);
            return;
        }
        
        s[dep] = 'L';
        dfs(cur.left, tar, dep+1, s);
        s[dep] = 'R';
        dfs(cur.right, tar, dep+1, s);
    }
     public static void main(String[] args) {
        // Create the binary tree as per the definition in the TreeNode class
        GetDirections.TreeNode root = new GetDirections.TreeNode(5);
        root.left = new GetDirections.TreeNode(3);
        root.right = new GetDirections.TreeNode(6);
        root.left.left = new GetDirections.TreeNode(2);
        root.left.right = new GetDirections.TreeNode(4);
        root.left.left.left = new GetDirections.TreeNode(1);

        // Create an instance of the GetDirections class
        GetDirections getDirections = new GetDirections();

        // Call the getDirections method
        int startValue = 3;
        int destValue = 1;
        String result = getDirections.getDirections(root, startValue, destValue);

        // Print the result
        System.out.println(""Directions from "" + startValue + "" to "" + destValue + "": "" + result);
    }
}",GetDirections,78,"[65, 66, 67, 68, 70, 73, 20, 78, 36, 52, 53, 58, 59, 54, 60, 61, 38, 39, 41, 42, 44, 46, 47]","1: /**
2:  * Definition for a binary tree node.
3:  * public class TreeNode {
4:  *     int val;
5:  *     TreeNode left;
6:  *     TreeNode right;
7:  *     TreeNode() {}
8:  *     TreeNode(int val) { this.val = val; }
9:  *     TreeNode(int val, TreeNode left, TreeNode right) {
10:  *         this.val = val;
11:  *         this.left = left;
12:  *         this.right = right;
13:  *     }
14:  * }
15:  */
16: import java.util.*;
17: 
18: 
19: 
20: class GetDirections {
21:      public static class TreeNode {
22:      int val;
23:      TreeNode left;
24:      TreeNode right;
25:      TreeNode() {}
26:      TreeNode(int val) { this.val = val; }
27:      TreeNode(int val, TreeNode left, TreeNode right) {
28:          this.val = val;
29:          this.left = left;
30:          this.right = right;
31:      }
32:  }
33:     char[] res;
34:     
35:     public String getDirections(TreeNode root, int startValue, int destValue) {
36:         dfs(root, startValue, 0, new char[100005]);
37:         char[] s = res;
38:         dfs(root, destValue, 0, new char[100005]);
39:         char[] t = res;
40:         int ld = 0;
41:         for(int i = 0;i < s.length && i < t.length && s[i] == t[i];i++){
42:             ld = i+1;
43:         }
44:         StringBuilder ret = new StringBuilder();
45:         for(int i = ld;i < s.length;i++)ret.append('U');
46:         for(int i = ld;i < t.length;i++)ret.append(t[i]);
47:         return ret.toString();
48:     }
49:     
50:     void dfs(TreeNode cur, int tar, int dep, char[] s)
51:     {
52:         if(cur == null)return;
53:         if(cur.val == tar){
54:             res = Arrays.copyOf(s, dep);
55:             return;
56:         }
57:         
58:         s[dep] = 'L';
59:         dfs(cur.left, tar, dep+1, s);
60:         s[dep] = 'R';
61:         dfs(cur.right, tar, dep+1, s);
62:     }
63:      public static void main(String[] args) {
64:         // Create the binary tree as per the definition in the TreeNode class
65:         GetDirections.TreeNode root = new GetDirections.TreeNode(5);
66:         root.left = new GetDirections.TreeNode(3);
67:         root.right = new GetDirections.TreeNode(6);
68:         root.left.left = new GetDirections.TreeNode(2);
69:         root.left.right = new GetDirections.TreeNode(4);
70:         root.left.left.left = new GetDirections.TreeNode(1);
71: 
72:         // Create an instance of the GetDirections class
73:         GetDirections getDirections = new GetDirections();
74: 
75:         // Call the getDirections method
76:         int startValue = 3;
77:         int destValue = 1;
78:         String result = getDirections.getDirections(root, startValue, destValue);
79: 
80:         // Print the result
81:         System.out.println(""Directions from "" + startValue + "" to "" + destValue + "": "" + result);
82:     }
83: }","[78, 77, 76, 73, 75, 65]","{'output': ['78', '77', '76', '73', '75', '65']}","[78, 76, 77, 73, 35, 36, 38, 47]","{'output': ['78', '76', '77', '73', '35', '36', '38', '47']}","[78, 35, 36, 38, 45, 46, 47, 50, 51, 53, 54, 55, 58, 59, 60, 61]","{'output': ['78', '35', '36', '38', '45', '46', '47', '50', '51', '53', '54', '55', '58', '59', '60', '61']}"
"import java.util.*;

	class GroupStrings {
		public int[] groupStrings(String[] words) {
			int n = words.length;
			int[] a = new int[n];
			DJSet ds = new DJSet(n);
			Map<Integer, Integer> map = new HashMap<>();
			for(int i = 0;i < n;i++){
				for(char c : words[i].toCharArray()){
					a[i] |= 1<<c-'a';
				}
				if(map.containsKey(a[i])){
					ds.union(i, map.get(a[i]));
				}

				map.put(a[i], i);
			}

			for(int i = 0;i < n;i++){
				for(int j = 0;j < 26;j++){
					int k = a[i]^1<<j;
					if(map.containsKey(k)){
						ds.union(i, map.get(k));
					}
				}
				for(int j = 0;j < 26;j++){
					for(int l = 0;l < 26;l++){
						if(a[i]<<~j<0 && a[i]<<~l>=0){
							int k = a[i]^1<<j^1<<l;
							if(map.containsKey(k)){
								ds.union(i, map.get(k));
							}
						}
					}
				}
			}

			int min = 0;
			for(int i = 0;i < n;i++){
				min = Math.min(min, ds.upper[i]);
			}
			int[] ans = new int[]{ds.count(), -min};
			return ans;
		}

		public class DJSet {
			public int[] upper;

			public DJSet(int n) {
				upper = new int[n];
				Arrays.fill(upper, -1);
			}

			public int root(int x) {
				return upper[x] < 0 ? x : (upper[x] = root(upper[x]));
			}

			public boolean equiv(int x, int y) {
				return root(x) == root(y);
			}

			public boolean union(int x, int y) {
				x = root(x);
				y = root(y);
				if (x != y) {
					if (upper[y] < upper[x]) {
						int d = x;
						x = y;
						y = d;
					}
					upper[x] += upper[y];
					upper[y] = x;
				}
				return x == y;
			}

			public int count() {
				int ct = 0;
				for (int u : upper) if (u < 0) ct++;
				return ct;
			}

			public int[][] toBucket() {
				int n = upper.length;
				int[][] ret = new int[n][];
				int[] rp = new int[n];
				for (int i = 0; i < n; i++) if (upper[i] < 0) ret[i] = new int[-upper[i]];
				for (int i = 0; i < n; i++) {
					int r = root(i);
					ret[r][rp[r]++] = i;
				}
				return ret;
			}
		}
	public static void main(String[] args) {
			GroupStrings groupStrings = new GroupStrings();
			
			// Example input
			String[] words = {""abc"", ""bcd"", ""ace"", ""xyz"", ""az"", ""ba"", ""a"", ""z""};

			// Calling the groupStrings method and getting the result
			int[] result = groupStrings.groupStrings(words);

			// Printing the result
			System.out.println(""Number of groups: "" + result[0]);
			System.out.println(""Size of the largest group: "" + result[1]);
		}
	}
",GroupStrings,103,"[97, 3, 100, 103, 5]","1: import java.util.*;
2: 
3: 	class GroupStrings {
4: 		public int[] groupStrings(String[] words) {
5: 			int n = words.length;
6: 			int[] a = new int[n];
7: 			DJSet ds = new DJSet(n);
8: 			Map<Integer, Integer> map = new HashMap<>();
9: 			for(int i = 0;i < n;i++){
10: 				for(char c : words[i].toCharArray()){
11: 					a[i] |= 1<<c-'a';
12: 				}
13: 				if(map.containsKey(a[i])){
14: 					ds.union(i, map.get(a[i]));
15: 				}
16: 
17: 				map.put(a[i], i);
18: 			}
19: 
20: 			for(int i = 0;i < n;i++){
21: 				for(int j = 0;j < 26;j++){
22: 					int k = a[i]^1<<j;
23: 					if(map.containsKey(k)){
24: 						ds.union(i, map.get(k));
25: 					}
26: 				}
27: 				for(int j = 0;j < 26;j++){
28: 					for(int l = 0;l < 26;l++){
29: 						if(a[i]<<~j<0 && a[i]<<~l>=0){
30: 							int k = a[i]^1<<j^1<<l;
31: 							if(map.containsKey(k)){
32: 								ds.union(i, map.get(k));
33: 							}
34: 						}
35: 					}
36: 				}
37: 			}
38: 
39: 			int min = 0;
40: 			for(int i = 0;i < n;i++){
41: 				min = Math.min(min, ds.upper[i]);
42: 			}
43: 			int[] ans = new int[]{ds.count(), -min};
44: 			return ans;
45: 		}
46: 
47: 		public class DJSet {
48: 			public int[] upper;
49: 
50: 			public DJSet(int n) {
51: 				upper = new int[n];
52: 				Arrays.fill(upper, -1);
53: 			}
54: 
55: 			public int root(int x) {
56: 				return upper[x] < 0 ? x : (upper[x] = root(upper[x]));
57: 			}
58: 
59: 			public boolean equiv(int x, int y) {
60: 				return root(x) == root(y);
61: 			}
62: 
63: 			public boolean union(int x, int y) {
64: 				x = root(x);
65: 				y = root(y);
66: 				if (x != y) {
67: 					if (upper[y] < upper[x]) {
68: 						int d = x;
69: 						x = y;
70: 						y = d;
71: 					}
72: 					upper[x] += upper[y];
73: 					upper[y] = x;
74: 				}
75: 				return x == y;
76: 			}
77: 
78: 			public int count() {
79: 				int ct = 0;
80: 				for (int u : upper) if (u < 0) ct++;
81: 				return ct;
82: 			}
83: 
84: 			public int[][] toBucket() {
85: 				int n = upper.length;
86: 				int[][] ret = new int[n][];
87: 				int[] rp = new int[n];
88: 				for (int i = 0; i < n; i++) if (upper[i] < 0) ret[i] = new int[-upper[i]];
89: 				for (int i = 0; i < n; i++) {
90: 					int r = root(i);
91: 					ret[r][rp[r]++] = i;
92: 				}
93: 				return ret;
94: 			}
95: 		}
96: 	public static void main(String[] args) {
97: 			GroupStrings groupStrings = new GroupStrings();
98: 			
99: 			// Example input
100: 			String[] words = {""abc"", ""bcd"", ""ace"", ""xyz"", ""az"", ""ba"", ""a"", ""z""};
101: 
102: 			// Calling the groupStrings method and getting the result
103: 			int[] result = groupStrings.groupStrings(words);
104: 
105: 			// Printing the result
106: 			System.out.println(""Number of groups: "" + result[0]);
107: 			System.out.println(""Size of the largest group: "" + result[1]);
108: 		}
109: 	}
110: ","[103, 97, 4]","{'output': ['103', '97', '4']}","[103, 100, 99, 98, 97, 4]","{'output': ['103', '100', '99', '98', '97', '4']}","[103, 4, 5, 6, 7, 8, 9, 10, 11, 13, 14, 17, 20, 21, 22, 23, 24, 27, 28, 29, 30, 31, 32, 39, 40, 41, 43]","{'output': ['103', '4', '5', '6', '7', '8', '9', '10', '11', '13', '14', '17', '20', '21', '22', '23', '24', '27', '28', '29', '30', '31', '32', '39', '40', '41', '43']}"
"import java.math.BigDecimal;
import java.util.*;

class HalveArray {

	public int halveArray(int[] nums) {
		PriorityQueue<BigDecimal> queue = new PriorityQueue<>();
		BigDecimal sum = BigDecimal.ZERO, curr = BigDecimal.ZERO;
		for (int num : nums) {
			sum = sum.add(BigDecimal.valueOf(num).divide(BigDecimal.valueOf(2)));
			queue.add(BigDecimal.valueOf(-num));
		}
		for (int i = 1;; i++) {
			BigDecimal poll = queue.poll().divide(BigDecimal.valueOf(2));
			if ((curr = curr.subtract(poll)).compareTo(sum) >= 0) {
				return i;
			}
			queue.add(poll);
		}
	}
	public static void main(String[] args) {
        HalveArray halveArray = new HalveArray();
        int[] nums = {10, 20, 30};
        int result = halveArray.halveArray(nums);
        System.out.println(""Number of operations to halve the array sum: "" + result);
    }
}",HalveArray,24,"[22, 4, 23, 24, 7, 8, 9, 10, 13, 14, 15, 16]","1: import java.math.BigDecimal;
2: import java.util.*;
3: 
4: class HalveArray {
5: 
6: 	public int halveArray(int[] nums) {
7: 		PriorityQueue<BigDecimal> queue = new PriorityQueue<>();
8: 		BigDecimal sum = BigDecimal.ZERO, curr = BigDecimal.ZERO;
9: 		for (int num : nums) {
10: 			sum = sum.add(BigDecimal.valueOf(num).divide(BigDecimal.valueOf(2)));
11: 			queue.add(BigDecimal.valueOf(-num));
12: 		}
13: 		for (int i = 1;; i++) {
14: 			BigDecimal poll = queue.poll().divide(BigDecimal.valueOf(2));
15: 			if ((curr = curr.subtract(poll)).compareTo(sum) >= 0) {
16: 				return i;
17: 			}
18: 			queue.add(poll);
19: 		}
20: 	}
21: 	public static void main(String[] args) {
22:         HalveArray halveArray = new HalveArray();
23:         int[] nums = {10, 20, 30};
24:         int result = halveArray.halveArray(nums);
25:         System.out.println(""Number of operations to halve the array sum: "" + result);
26:     }
27: }","[24, 23, 21, 6, 7, 8, 9, 10, 11, 13, 14, 15, 16, 18]","{'output': ['24', '23', '21', '6', '7', '8', '9', '10', '11', '13', '14', '15', '16', '18']}","[24, 23, 22, 6, 7, 8, 9, 10, 11, 13, 14, 15, 16]","{'output': ['24', '23', '22', '6', '7', '8', '9', '10', '11', '13', '14', '15', '16']}","[24, 23, 22, 6, 20]","{'output': ['24', '23', '22', '6', '20']}"
"import java.util.*;

public class HashCode {

	private static class Pair
	{
		public int value1 , value2;
		public Pair(int value1 , int value2)
		{
			this.value1 = value1;
			this.value2 = value2;
		}
		
		public int hashCode()
		{
			return this.value1 * 31 + this.value2;
		}
		
		public boolean equals(Object object)
		{
			Pair pair = (Pair) object;
			return (this.value1 == pair.value1) && (this.value2 == pair.value2);
		}
	}
	
	private List<List<Integer>> ans = new ArrayList<List<Integer>>();
	private Set<Pair> set = new HashSet<Pair>();
	
	public List<List<Integer>> findSubsequences(int[] nums) {
		
		dfs(nums , 0 , new ArrayList<Integer>());
		return ans;
        
    }
	
	private int hash1(List<Integer> list)
	{
		int value = 31;
		for (int temp : list)
			value = value * 37 + temp;
		return value;
	}
	
	private int hash2(List<Integer> list)
	{
		int value = 71;
		for (int temp : list)
			value = value * 73 + temp;
		return value;
	}
	
	private void dfs(int[] nums , int current , List<Integer> list)
	{
		if (current == nums.length)
		{
			if (list.size() > 1)
			{
				int hashValue1 = hash1(list);
				int hashValue2 = hash2(list);
				Pair pair = new Pair(hashValue1 , hashValue2);
				if (!set.contains(pair))
				{
					set.add(pair);
					List<Integer> newList = new ArrayList<Integer>(list);
					ans.add(newList);
				}
			}
		}
		else
		{	
			if (list.size() == 0 || (nums[current] >= list.get(list.size() - 1)))
			{
				list.add(nums[current]);
				dfs(nums , current + 1 , list);
				list.remove(list.size() - 1);
			}
			dfs(nums , current + 1 , list);
		}
	}
	 public static void main(String[] args) {
        HashCode hashCode = new HashCode();
        int[] nums = {4, 6, 7, 7};
        List<List<Integer>> result = hashCode.findSubsequences(nums);
        
        System.out.println(""Subsequences:"");
        for (List<Integer> subsequence : result) {
            System.out.println(subsequence);
        }
    }

}",HashCode,83,"[81, 3, 26, 27, 82, 83, 31, 54, 71, 73, 74, 56, 58, 38, 39, 40, 41, 60, 61, 63, 64, 65, 75, 77, 32]","1: import java.util.*;
2: 
3: public class HashCode {
4: 
5: 	private static class Pair
6: 	{
7: 		public int value1 , value2;
8: 		public Pair(int value1 , int value2)
9: 		{
10: 			this.value1 = value1;
11: 			this.value2 = value2;
12: 		}
13: 		
14: 		public int hashCode()
15: 		{
16: 			return this.value1 * 31 + this.value2;
17: 		}
18: 		
19: 		public boolean equals(Object object)
20: 		{
21: 			Pair pair = (Pair) object;
22: 			return (this.value1 == pair.value1) && (this.value2 == pair.value2);
23: 		}
24: 	}
25: 	
26: 	private List<List<Integer>> ans = new ArrayList<List<Integer>>();
27: 	private Set<Pair> set = new HashSet<Pair>();
28: 	
29: 	public List<List<Integer>> findSubsequences(int[] nums) {
30: 		
31: 		dfs(nums , 0 , new ArrayList<Integer>());
32: 		return ans;
33:         
34:     }
35: 	
36: 	private int hash1(List<Integer> list)
37: 	{
38: 		int value = 31;
39: 		for (int temp : list)
40: 			value = value * 37 + temp;
41: 		return value;
42: 	}
43: 	
44: 	private int hash2(List<Integer> list)
45: 	{
46: 		int value = 71;
47: 		for (int temp : list)
48: 			value = value * 73 + temp;
49: 		return value;
50: 	}
51: 	
52: 	private void dfs(int[] nums , int current , List<Integer> list)
53: 	{
54: 		if (current == nums.length)
55: 		{
56: 			if (list.size() > 1)
57: 			{
58: 				int hashValue1 = hash1(list);
59: 				int hashValue2 = hash2(list);
60: 				Pair pair = new Pair(hashValue1 , hashValue2);
61: 				if (!set.contains(pair))
62: 				{
63: 					set.add(pair);
64: 					List<Integer> newList = new ArrayList<Integer>(list);
65: 					ans.add(newList);
66: 				}
67: 			}
68: 		}
69: 		else
70: 		{	
71: 			if (list.size() == 0 || (nums[current] >= list.get(list.size() - 1)))
72: 			{
73: 				list.add(nums[current]);
74: 				dfs(nums , current + 1 , list);
75: 				list.remove(list.size() - 1);
76: 			}
77: 			dfs(nums , current + 1 , list);
78: 		}
79: 	}
80: 	 public static void main(String[] args) {
81:         HashCode hashCode = new HashCode();
82:         int[] nums = {4, 6, 7, 7};
83:         List<List<Integer>> result = hashCode.findSubsequences(nums);
84:         
85:         System.out.println(""Subsequences:"");
86:         for (List<Integer> subsequence : result) {
87:             System.out.println(subsequence);
88:         }
89:     }
90: 
91: }","[83, 81, 29, 31, 52, 54, 56, 58, 59, 60, 61, 63, 64, 65, 36, 38, 39, 40, 41, 44, 46, 47, 48, 49]","{'output': ['83', '81', '29', '31', '52', '54', '56', '58', '59', '60', '61', '63', '64', '65', '36', '38', '39', '40', '41', '44', '46', '47', '48', '49']}","[83, 81, 29, 31, 52, 54, 56, 58, 59, 60, 36, 38, 39, 40, 41, 44, 46, 47, 48, 49, 5, 7, 8, 10, 11]","{'output': ['83', '81', '29', '31', '52', '54', '56', '58', '59', '60', '36', '38', '39', '40', '41', '44', '46', '47', '48', '49', '5', '7', '8', '10', '11']}","[83, 81, 29, 31, 52, 54, 56, 58, 36, 38, 39, 40, 41, 59, 44, 46, 47, 48, 49, 60, 8, 10, 11, 61, 27, 63, 64, 26, 65]","{'output': ['83', '81', '29', '31', '52', '54', '56', '58', '36', '38', '39', '40', '41', '59', '44', '46', '47', '48', '49', '60', '8', '10', '11', '61', '27', '63', '64', '26', '65']}"
"	import java.util.*;
	
	class HighestPeak {
		public int[][] highestPeak(int[][] isWater) {
			int n= isWater.length, m = isWater[0].length;
			Queue<int[]> q = new ArrayDeque<>();
			int[][] h = new int[n][m];
			for(int i = 0;i < n;i++)Arrays.fill(h[i], 999999);
			for(int i = 0;i < n;i++){
				for(int j = 0;j < m;j++){
					if(isWater[i][j] == 1){
						h[i][j] = 0;
						q.add(new int[]{i, j});
					}
				}
			}
			int[] dr = {1, 0, -1, 0};
			int[] dc = {0, 1, 0, -1};

			while(!q.isEmpty()){
				int[] cur = q.poll();
				int r = cur[0], c = cur[1];
				for(int k = 0;k < 4;k++){
					int nr = r + dr[k], nc = c + dc[k];
					if(nr >= 0 && nr < n && nc >= 0 && nc < m &&
					h[nr][nc] > h[r][c] + 1){
						h[nr][nc] = h[r][c] + 1;
						q.add(new int[]{nr, nc});
					}
				}
			}
			return h;
		}
	public static void main(String[] args) {
        HighestPeak highestPeak = new HighestPeak();
        int[][] isWater = {
            {0, 1},
            {0, 0}
        };
        int[][] result = highestPeak.highestPeak(isWater);

        System.out.println(""Highest Peak Matrix:"");
        for (int[] row : result) {
            System.out.println(Arrays.toString(row));
        }
    }
	}
",HighestPeak,40,"[35, 3, 36, 40, 5, 7, 32]","1: 	import java.util.*;
2: 	
3: 	class HighestPeak {
4: 		public int[][] highestPeak(int[][] isWater) {
5: 			int n= isWater.length, m = isWater[0].length;
6: 			Queue<int[]> q = new ArrayDeque<>();
7: 			int[][] h = new int[n][m];
8: 			for(int i = 0;i < n;i++)Arrays.fill(h[i], 999999);
9: 			for(int i = 0;i < n;i++){
10: 				for(int j = 0;j < m;j++){
11: 					if(isWater[i][j] == 1){
12: 						h[i][j] = 0;
13: 						q.add(new int[]{i, j});
14: 					}
15: 				}
16: 			}
17: 			int[] dr = {1, 0, -1, 0};
18: 			int[] dc = {0, 1, 0, -1};
19: 
20: 			while(!q.isEmpty()){
21: 				int[] cur = q.poll();
22: 				int r = cur[0], c = cur[1];
23: 				for(int k = 0;k < 4;k++){
24: 					int nr = r + dr[k], nc = c + dc[k];
25: 					if(nr >= 0 && nr < n && nc >= 0 && nc < m &&
26: 					h[nr][nc] > h[r][c] + 1){
27: 						h[nr][nc] = h[r][c] + 1;
28: 						q.add(new int[]{nr, nc});
29: 					}
30: 				}
31: 			}
32: 			return h;
33: 		}
34: 	public static void main(String[] args) {
35:         HighestPeak highestPeak = new HighestPeak();
36:         int[][] isWater = {
37:             {0, 1},
38:             {0, 0}
39:         };
40:         int[][] result = highestPeak.highestPeak(isWater);
41: 
42:         System.out.println(""Highest Peak Matrix:"");
43:         for (int[] row : result) {
44:             System.out.println(Arrays.toString(row));
45:         }
46:     }
47: 	}
48: ","[40, 35, 4]","{'output': ['40', '35', '4']}","[40, 35, 36, 37, 38]","{'output': ['40', '35', '36', '37', '38']}","[40, 35, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 16, 20, 21, 22, 23, 24, 25, 26, 27, 28, 31, 32]","{'output': ['40', '35', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '16', '20', '21', '22', '23', '24', '25', '26', '27', '28', '31', '32']}"
"	import java.util.*;
	class IsPossible {
	    public boolean isPossible(int[] target) {
	    	PriorityQueue<Integer> pq = new PriorityQueue<>();
	    	for(int v : target){
	    		pq.add(-v);
	    	}
	    	long sum = 0;
	    	for(int v : target){
	    		sum += v;
	    	}
	    	while(true){
	    		int cur = -pq.poll();
	    		if(cur == 1)break;
	    		if(cur-(sum-cur) > 0 && cur-(sum-cur) < cur){
	    			int an = (int)(cur-(sum-cur));
	    			sum -= cur - an;
	    			cur = an;
	    			pq.add(-cur);
	    		}else{
	    			return false;
	    		}
	    	}
	    	return true;
	    }
		public static void main(String[] args) {
        IsPossible isPossible = new IsPossible();
        int[] target = {9, 3, 5};
        boolean result = isPossible.isPossible(target);
        
        System.out.println(""Is it possible to construct the target array? "" + result);
    }
	}	
",IsPossible,29,"[27, 2, 28, 29, 4, 9, 13, 14, 24]","1: 	import java.util.*;
2: 	class IsPossible {
3: 	    public boolean isPossible(int[] target) {
4: 	    	PriorityQueue<Integer> pq = new PriorityQueue<>();
5: 	    	for(int v : target){
6: 	    		pq.add(-v);
7: 	    	}
8: 	    	long sum = 0;
9: 	    	for(int v : target){
10: 	    		sum += v;
11: 	    	}
12: 	    	while(true){
13: 	    		int cur = -pq.poll();
14: 	    		if(cur == 1)break;
15: 	    		if(cur-(sum-cur) > 0 && cur-(sum-cur) < cur){
16: 	    			int an = (int)(cur-(sum-cur));
17: 	    			sum -= cur - an;
18: 	    			cur = an;
19: 	    			pq.add(-cur);
20: 	    		}else{
21: 	    			return false;
22: 	    		}
23: 	    	}
24: 	    	return true;
25: 	    }
26: 		public static void main(String[] args) {
27:         IsPossible isPossible = new IsPossible();
28:         int[] target = {9, 3, 5};
29:         boolean result = isPossible.isPossible(target);
30:         
31:         System.out.println(""Is it possible to construct the target array? "" + result);
32:     }
33: 	}	
34: ","[29, 27, 3]","{'output': ['29', '27', '3']}","[29, 27, 3]","{'output': ['29', '27', '3']}","[29, 27, 3]","{'output': ['29', '27', '3']}"
"	class IsReachable {
		public boolean isReachable(int targetX, int targetY) {
			while(targetX % 2 == 0){
				targetX /= 2;
			}
			while(targetY % 2 == 0){
				targetY /= 2;
			}
			return gcd(targetX, targetY) == 1;
		}

		public static int gcd(int a, int b) {
			while (b > 0) {
				int c = a;
				a = b;
				b = c % b;
			}
			return a;
		}
		public static void main(String[] args) {
        IsReachable isReachable = new IsReachable();
        int targetX = 6;
        int targetY = 9;
        boolean result = isReachable.isReachable(targetX, targetY);
        
        System.out.println(""Is it possible to reach ("" + targetX + "", "" + targetY + "")? "" + result);
    }

	}
",IsReachable,24,"[21, 1, 24, 3, 4, 9, 13, 14, 16, 15, 18]","1: 	class IsReachable {
2: 		public boolean isReachable(int targetX, int targetY) {
3: 			while(targetX % 2 == 0){
4: 				targetX /= 2;
5: 			}
6: 			while(targetY % 2 == 0){
7: 				targetY /= 2;
8: 			}
9: 			return gcd(targetX, targetY) == 1;
10: 		}
11: 
12: 		public static int gcd(int a, int b) {
13: 			while (b > 0) {
14: 				int c = a;
15: 				a = b;
16: 				b = c % b;
17: 			}
18: 			return a;
19: 		}
20: 		public static void main(String[] args) {
21:         IsReachable isReachable = new IsReachable();
22:         int targetX = 6;
23:         int targetY = 9;
24:         boolean result = isReachable.isReachable(targetX, targetY);
25:         
26:         System.out.println(""Is it possible to reach ("" + targetX + "", "" + targetY + "")? "" + result);
27:     }
28: 
29: 	}
30: ","[24, 22, 23, 2, 3, 4, 6, 7, 9, 12, 13, 14, 15, 16, 18]","{'output': ['24', '22', '23', '2', '3', '4', '6', '7', '9', '12', '13', '14', '15', '16', '18']}","[24, 2, 9, 12, 13, 14, 15, 16, 18, 22, 23, 21]","{'output': ['24', '2', '9', '12', '13', '14', '15', '16', '18', '22', '23', '21']}","[24, 2, 3, 4, 6, 7, 9, 12, 13, 14, 15, 16, 18, 22, 23, 21]","{'output': ['24', '2', '3', '4', '6', '7', '9', '12', '13', '14', '15', '16', '18', '22', '23', '21']}"
"	public class KInversePairs {
	    public int kInversePairs(int n, int k) {
	    	long[] dp = new long[k+n+2];
	    	int mod = 1000000007;
	    	dp[0] = 1;
	    	for(int i = 1;i <= n;i++){
	    		for(int j = dp.length-1-i;j >= 0;j--){
	    			dp[j+i] -= dp[j];
	    			if(dp[j+i] < 0)dp[j+i] += mod;
	    		}
	    	}
	    	for(int i = 1;i <= n;i++){
	    		for(int j = 0;j < dp.length-1;j++){
	    			dp[j+1] += dp[j];
	    			dp[j+1] %= mod;
	    		}
	    	}
	    	return (int)dp[k];
	    }
		public static void main(String[] args) {
        KInversePairs kInversePairs = new KInversePairs();
        int n = 3;
        int k = 1;
        int result = kInversePairs.kInversePairs(n, k);
        
        System.out.println(""Number of arrays with "" + k + "" inverse pairs for n = "" + n + "": "" + result);
    }
	}
",KInversePairs,24,"[21, 1, 24, 3, 5, 6, 7, 8, 9, 12, 13, 14, 15, 18]","1: 	public class KInversePairs {
2: 	    public int kInversePairs(int n, int k) {
3: 	    	long[] dp = new long[k+n+2];
4: 	    	int mod = 1000000007;
5: 	    	dp[0] = 1;
6: 	    	for(int i = 1;i <= n;i++){
7: 	    		for(int j = dp.length-1-i;j >= 0;j--){
8: 	    			dp[j+i] -= dp[j];
9: 	    			if(dp[j+i] < 0)dp[j+i] += mod;
10: 	    		}
11: 	    	}
12: 	    	for(int i = 1;i <= n;i++){
13: 	    		for(int j = 0;j < dp.length-1;j++){
14: 	    			dp[j+1] += dp[j];
15: 	    			dp[j+1] %= mod;
16: 	    		}
17: 	    	}
18: 	    	return (int)dp[k];
19: 	    }
20: 		public static void main(String[] args) {
21:         KInversePairs kInversePairs = new KInversePairs();
22:         int n = 3;
23:         int k = 1;
24:         int result = kInversePairs.kInversePairs(n, k);
25:         
26:         System.out.println(""Number of arrays with "" + k + "" inverse pairs for n = "" + n + "": "" + result);
27:     }
28: 	}
29: ","[24, 23, 22, 21, 18, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]","{'output': ['24', '23', '22', '21', '18', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17']}","[24, 23, 22, 21, 2, 18]","{'output': ['24', '23', '22', '21', '2', '18']}","[24, 23, 22, 21, 2, 18, 3, 4, 5, 6, 7, 8, 9, 10, 12, 13, 14, 15, 16, 17]","{'output': ['24', '23', '22', '21', '2', '18', '3', '4', '5', '6', '7', '8', '9', '10', '12', '13', '14', '15', '16', '17']}"
"class KthPalindrome {

	public long[] kthPalindrome(int[] queries, int intLength) {
		long[] result = new long[queries.length];
		for (int i = 0; i < queries.length; i++) {
			String s = (long) Math.pow(10, (intLength - 1) / 2) + queries[i] - 1 + """";
			result[i] = s.length() > (intLength + 1) / 2 ? -1
					: Long.valueOf(s + new StringBuilder(s.substring(0, s.length() - intLength % 2)).reverse());
		}
		return result;
	}
	public static void main(String[] args) {
        KthPalindrome kthPalindrome = new KthPalindrome();
        int[] queries = {1, 2, 3, 4, 5};
        int intLength = 3;
        long[] result = kthPalindrome.kthPalindrome(queries, intLength);
        
        System.out.println(""Kth Palindromes:"");
        for (long palindrome : result) {
            System.out.println(palindrome);
        }
    }
}",KthPalindrome,16,"[13, 1, 14, 16, 4, 5, 6, 7, 8, 10]","1: class KthPalindrome {
2: 
3: 	public long[] kthPalindrome(int[] queries, int intLength) {
4: 		long[] result = new long[queries.length];
5: 		for (int i = 0; i < queries.length; i++) {
6: 			String s = (long) Math.pow(10, (intLength - 1) / 2) + queries[i] - 1 + """";
7: 			result[i] = s.length() > (intLength + 1) / 2 ? -1
8: 					: Long.valueOf(s + new StringBuilder(s.substring(0, s.length() - intLength % 2)).reverse());
9: 		}
10: 		return result;
11: 	}
12: 	public static void main(String[] args) {
13:         KthPalindrome kthPalindrome = new KthPalindrome();
14:         int[] queries = {1, 2, 3, 4, 5};
15:         int intLength = 3;
16:         long[] result = kthPalindrome.kthPalindrome(queries, intLength);
17:         
18:         System.out.println(""Kth Palindromes:"");
19:         for (long palindrome : result) {
20:             System.out.println(palindrome);
21:         }
22:     }
23: }","[16, 13, 3, 4, 5, 6, 7, 8, 10, 14, 15]","{'output': ['16', '13', '3', '4', '5', '6', '7', '8', '10', '14', '15']}","[16, 13, 14, 15]","{'output': ['16', '13', '14', '15']}","[16, 15, 14, 13, 3, 4, 5, 6, 7, 8, 10]","{'output': ['16', '15', '14', '13', '3', '4', '5', '6', '7', '8', '10']}"
"class KthSmallestPath {
    int[][] cts = new int[16][16];
    
    public String kthSmallestPath(int[] dest, int k) {
        int nv = dest[0];
        int nh = dest[1];
        for (int i = 0; i <= 15; ++i) {
            cts[0][i]=1;
            cts[i][0]=1;
        }
        for (int i = 1; i <= 15; ++i) {
            for (int j = 1; j <= 15; ++j) {
                cts[i][j]=cts[i-1][j]+cts[i][j-1];
            }
        }
        return ksm(nh,nv,k);
    }
    
    public String ksm(int nh, int nv, int k) {
        if (nh==0&&nv==0)
            return """";
        if (nh==0)
            return ""V""+ksm(nh,nv-1,k);
        if (nv==0)
            return ""H""+ksm(nh-1,nv,k);
        if (k>cts[nh-1][nv])
            return ""V""+ksm(nh,nv-1,k-cts[nh-1][nv]);
        return ""H""+ksm(nh-1,nv,k);
    }
    public static void main(String[] args) {
        KthSmallestPath kthSmallestPath = new KthSmallestPath();
        int[] dest = {2, 3}; // Destination coordinates
        int k = 3; // k-th smallest path
        
        String result = kthSmallestPath.kthSmallestPath(dest, k);
        
        System.out.println(""The "" + k + ""-th smallest path to destination "" + 
                           ""("" + dest[0] + "", "" + dest[1] + "") is: "" + result);
    }
}",KthSmallestPath,35,"[31, 1, 2, 32, 35, 5, 6, 11, 16, 20, 22, 24, 26, 28, 27]","1: class KthSmallestPath {
2:     int[][] cts = new int[16][16];
3:     
4:     public String kthSmallestPath(int[] dest, int k) {
5:         int nv = dest[0];
6:         int nh = dest[1];
7:         for (int i = 0; i <= 15; ++i) {
8:             cts[0][i]=1;
9:             cts[i][0]=1;
10:         }
11:         for (int i = 1; i <= 15; ++i) {
12:             for (int j = 1; j <= 15; ++j) {
13:                 cts[i][j]=cts[i-1][j]+cts[i][j-1];
14:             }
15:         }
16:         return ksm(nh,nv,k);
17:     }
18:     
19:     public String ksm(int nh, int nv, int k) {
20:         if (nh==0&&nv==0)
21:             return """";
22:         if (nh==0)
23:             return ""V""+ksm(nh,nv-1,k);
24:         if (nv==0)
25:             return ""H""+ksm(nh-1,nv,k);
26:         if (k>cts[nh-1][nv])
27:             return ""V""+ksm(nh,nv-1,k-cts[nh-1][nv]);
28:         return ""H""+ksm(nh-1,nv,k);
29:     }
30:     public static void main(String[] args) {
31:         KthSmallestPath kthSmallestPath = new KthSmallestPath();
32:         int[] dest = {2, 3}; // Destination coordinates
33:         int k = 3; // k-th smallest path
34:         
35:         String result = kthSmallestPath.kthSmallestPath(dest, k);
36:         
37:         System.out.println(""The "" + k + ""-th smallest path to destination "" + 
38:                            ""("" + dest[0] + "", "" + dest[1] + "") is: "" + result);
39:     }
40: }","[35, 4, 5, 6, 16, 19, 26, 27, 28]","{'output': ['35', '4', '5', '6', '16', '19', '26', '27', '28']}","[35, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 19, 26, 27, 28]","{'output': ['35', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '19', '26', '27', '28']}","[35, 4, 5, 6, 16, 19, 26, 27, 28]","{'output': ['35', '4', '5', '6', '16', '19', '26', '27', '28']}"
"class Largest1BorderedSquare {
    public int largest1BorderedSquare(int[][] grid) {
        int n = grid.length;
        int m = grid[0].length;
        boolean[][][] hl = new boolean[n][m][m];
        boolean[][][] vl = new boolean[n][n][m];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (grid[i][j]==0)
                    continue;
                hl[i][j][j] = true;
                vl[i][i][j] = true;
                for (int k = j+1; k < m; ++k) {
                    if (grid[i][k] == 0)
                        break;
                    hl[i][j][k] = true;
                }
                for (int k = i+1; k < n; ++k) {
                    if (grid[k][j] == 0)
                        break;
                    vl[i][k][j] = true;
                }
            }
        }
        int ans = 0;
        for (int a = 0; a < n; ++a) {
            for (int b = 0; b < m; ++b) {
                if (grid[a][b]==0)
                    continue;
                ans = Math.max(ans, 1);
                for (int c = 1; a+c<n&&b+c<m; ++c) {
                    if (!hl[a][b][b+c]||!vl[a][a+c][b])
                        break;
                    if (hl[a+c][b][b+c]&&vl[a][a+c][b+c]) {
                        ans = Math.max(ans, (c+1)*(c+1));
                    }
                }
            }
        }
        return ans;
    }
     public static void main(String[] args) {
        Largest1BorderedSquare largest1BorderedSquare = new Largest1BorderedSquare();
        int[][] grid = {
            {1, 1, 1},
            {1, 0, 1},
            {1, 1, 1}
        };
        
        int result = largest1BorderedSquare.largest1BorderedSquare(grid);
        
        System.out.println(""The area of the largest 1-bordered square is: "" + result);
    }
}",Largest1BorderedSquare,50,"[43, 1, 44, 50, 3, 4, 25, 26, 27, 28, 30, 31, 35, 40]","1: class Largest1BorderedSquare {
2:     public int largest1BorderedSquare(int[][] grid) {
3:         int n = grid.length;
4:         int m = grid[0].length;
5:         boolean[][][] hl = new boolean[n][m][m];
6:         boolean[][][] vl = new boolean[n][n][m];
7:         for (int i = 0; i < n; i++) {
8:             for (int j = 0; j < m; j++) {
9:                 if (grid[i][j]==0)
10:                     continue;
11:                 hl[i][j][j] = true;
12:                 vl[i][i][j] = true;
13:                 for (int k = j+1; k < m; ++k) {
14:                     if (grid[i][k] == 0)
15:                         break;
16:                     hl[i][j][k] = true;
17:                 }
18:                 for (int k = i+1; k < n; ++k) {
19:                     if (grid[k][j] == 0)
20:                         break;
21:                     vl[i][k][j] = true;
22:                 }
23:             }
24:         }
25:         int ans = 0;
26:         for (int a = 0; a < n; ++a) {
27:             for (int b = 0; b < m; ++b) {
28:                 if (grid[a][b]==0)
29:                     continue;
30:                 ans = Math.max(ans, 1);
31:                 for (int c = 1; a+c<n&&b+c<m; ++c) {
32:                     if (!hl[a][b][b+c]||!vl[a][a+c][b])
33:                         break;
34:                     if (hl[a+c][b][b+c]&&vl[a][a+c][b+c]) {
35:                         ans = Math.max(ans, (c+1)*(c+1));
36:                     }
37:                 }
38:             }
39:         }
40:         return ans;
41:     }
42:      public static void main(String[] args) {
43:         Largest1BorderedSquare largest1BorderedSquare = new Largest1BorderedSquare();
44:         int[][] grid = {
45:             {1, 1, 1},
46:             {1, 0, 1},
47:             {1, 1, 1}
48:         };
49:         
50:         int result = largest1BorderedSquare.largest1BorderedSquare(grid);
51:         
52:         System.out.println(""The area of the largest 1-bordered square is: "" + result);
53:     }
54: }","[50, 43, 42]","{'output': ['50', '43', '42']}","[50, 42, 43, 44]","{'output': ['50', '42', '43', '44']}","[50, 43, 44, 45, 46, 47, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 18, 19, 20, 21, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 40]","{'output': ['50', '43', '44', '45', '46', '47', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '18', '19', '20', '21', '25', '26', '27', '28', '29', '30', '31', '32', '33', '34', '35', '40']}"
"class LargestMerge {
    public String largestMerge(String word1, String word2) {
        char[] s = word1.toCharArray();
        char[] t = word2.toCharArray();
        int n = s.length, m = t.length;
        char[] ret = new char[n+m];
        int i = 0, j = 0, p = 0;
        for(;i < n  && j < m;){
            int k, l;
            for(k = i, l = j;k < n && l < m && s[k] == t[l];k++,l++);
            if(k >= n){
                ret[p++] = t[j++];
            }else if(l >= m){
                ret[p++] = s[i++];
            }else if(s[k] > t[l]){
                ret[p++] = s[i++];
            }else{
                ret[p++] = t[j++];
            }
        }
        while(i < n)ret[p++] = s[i++];
        while(j < m)ret[p++] = t[j++];
        return new String(ret);
    }
    public static void main(String[] args) {
        LargestMerge largestMerge = new LargestMerge();
        String word1 = ""abcabc"";
        String word2 = ""abdcaba"";
        
        String result = largestMerge.largestMerge(word1, word2);
        
        System.out.println(""The largest merge is: "" + result);
    }
}",LargestMerge,30,"[26, 1, 30, 3, 4, 5, 6, 7, 10, 11, 13, 15, 18, 16, 22, 23]","1: class LargestMerge {
2:     public String largestMerge(String word1, String word2) {
3:         char[] s = word1.toCharArray();
4:         char[] t = word2.toCharArray();
5:         int n = s.length, m = t.length;
6:         char[] ret = new char[n+m];
7:         int i = 0, j = 0, p = 0;
8:         for(;i < n  && j < m;){
9:             int k, l;
10:             for(k = i, l = j;k < n && l < m && s[k] == t[l];k++,l++);
11:             if(k >= n){
12:                 ret[p++] = t[j++];
13:             }else if(l >= m){
14:                 ret[p++] = s[i++];
15:             }else if(s[k] > t[l]){
16:                 ret[p++] = s[i++];
17:             }else{
18:                 ret[p++] = t[j++];
19:             }
20:         }
21:         while(i < n)ret[p++] = s[i++];
22:         while(j < m)ret[p++] = t[j++];
23:         return new String(ret);
24:     }
25:     public static void main(String[] args) {
26:         LargestMerge largestMerge = new LargestMerge();
27:         String word1 = ""abcabc"";
28:         String word2 = ""abdcaba"";
29:         
30:         String result = largestMerge.largestMerge(word1, word2);
31:         
32:         System.out.println(""The largest merge is: "" + result);
33:     }
34: }","[30, 26, 2, 3, 4, 6, 8, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23]","{'output': ['30', '26', '2', '3', '4', '6', '8', '10', '11', '12', '13', '14', '15', '16', '17', '18', '21', '22', '23']}","[30, 26, 2, 23]","{'output': ['30', '26', '2', '23']}","[30, 26, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 13, 14, 15, 16, 17, 18, 20, 21, 22, 23, 27, 28]","{'output': ['30', '26', '2', '3', '4', '5', '6', '7', '8', '10', '11', '12', '13', '14', '15', '16', '17', '18', '20', '21', '22', '23', '27', '28']}"
"import java.util.*;
	class LatestDayToCross {
		public int latestDayToCross(int n, int m, int[][] cells) {
			int low = 0, high = n*m+1;
			while(high - low > 1){
				int h = high+low>>1;
				boolean[][] wa = new boolean[n][m];
				for(int i = 0;i < h;i++){
					wa[cells[i][0]-1][cells[i][1]-1] = true;
				}
				DJSet ds = new DJSet(n*m+2);
				for(int i = 0;i < n;i++){
					for(int j = 0;j < m;j++){
						if(i+1 < n && !wa[i][j] && !wa[i+1][j]){
							ds.union(i*m+j, (i+1)*m+j);
						}
						if(j+1 < m && !wa[i][j] && !wa[i][j+1]){
							ds.union(i*m+j, i*m+j+1);
						}
					}
				}
				for(int j = 0;j < m;j++){
					if(!wa[0][j])ds.union(n*m, 0*m+j);
					if(!wa[n-1][j])ds.union(n*m+1, (n-1)*m+j);
				}
				if(ds.equiv(n*m, n*m+1)){
					low = h;
				}else{
					high = h;
				}
			}
			return low;
		}

		public class DJSet {
			public int[] upper;

			public DJSet(int n) {
				upper = new int[n];
				Arrays.fill(upper, -1);
			}

			public int root(int x) {
				return upper[x] < 0 ? x : (upper[x] = root(upper[x]));
			}

			public boolean equiv(int x, int y) {
				return root(x) == root(y);
			}

			public boolean union(int x, int y) {
				x = root(x);
				y = root(y);
				if (x != y) {
					if (upper[y] < upper[x]) {
						int d = x;
						x = y;
						y = d;
					}
					upper[x] += upper[y];
					upper[y] = x;
				}
				return x == y;
			}

			public int count() {
				int ct = 0;
				for (int u : upper) if (u < 0) ct++;
				return ct;
			}

			public int[][] toBucket() {
				int n = upper.length;
				int[][] ret = new int[n][];
				int[] rp = new int[n];
				for (int i = 0; i < n; i++) if (upper[i] < 0) ret[i] = new int[-upper[i]];
				for (int i = 0; i < n; i++) {
					int r = root(i);
					ret[r][rp[r]++] = i;
				}
				return ret;
			}
		}
		public static void main(String[] args) {
        LatestDayToCross latestDayToCross = new LatestDayToCross();
        int n = 3;
        int m = 3;
        int[][] cells = {
            {1, 2},
            {2, 1},
            {3, 3},
            {2, 2},
            {1, 1},
            {1, 3},
            {2, 3},
            {3, 1},
            {3, 2}
        };

        int result = latestDayToCross.latestDayToCross(n, m, cells);
        System.out.println(""Latest day to cross: "" + result);
    }

		

	}
",LatestDayToCross,100,"[85, 2, 88, 100, 4, 5, 6, 11, 26, 29, 27, 32]","1: import java.util.*;
2: 	class LatestDayToCross {
3: 		public int latestDayToCross(int n, int m, int[][] cells) {
4: 			int low = 0, high = n*m+1;
5: 			while(high - low > 1){
6: 				int h = high+low>>1;
7: 				boolean[][] wa = new boolean[n][m];
8: 				for(int i = 0;i < h;i++){
9: 					wa[cells[i][0]-1][cells[i][1]-1] = true;
10: 				}
11: 				DJSet ds = new DJSet(n*m+2);
12: 				for(int i = 0;i < n;i++){
13: 					for(int j = 0;j < m;j++){
14: 						if(i+1 < n && !wa[i][j] && !wa[i+1][j]){
15: 							ds.union(i*m+j, (i+1)*m+j);
16: 						}
17: 						if(j+1 < m && !wa[i][j] && !wa[i][j+1]){
18: 							ds.union(i*m+j, i*m+j+1);
19: 						}
20: 					}
21: 				}
22: 				for(int j = 0;j < m;j++){
23: 					if(!wa[0][j])ds.union(n*m, 0*m+j);
24: 					if(!wa[n-1][j])ds.union(n*m+1, (n-1)*m+j);
25: 				}
26: 				if(ds.equiv(n*m, n*m+1)){
27: 					low = h;
28: 				}else{
29: 					high = h;
30: 				}
31: 			}
32: 			return low;
33: 		}
34: 
35: 		public class DJSet {
36: 			public int[] upper;
37: 
38: 			public DJSet(int n) {
39: 				upper = new int[n];
40: 				Arrays.fill(upper, -1);
41: 			}
42: 
43: 			public int root(int x) {
44: 				return upper[x] < 0 ? x : (upper[x] = root(upper[x]));
45: 			}
46: 
47: 			public boolean equiv(int x, int y) {
48: 				return root(x) == root(y);
49: 			}
50: 
51: 			public boolean union(int x, int y) {
52: 				x = root(x);
53: 				y = root(y);
54: 				if (x != y) {
55: 					if (upper[y] < upper[x]) {
56: 						int d = x;
57: 						x = y;
58: 						y = d;
59: 					}
60: 					upper[x] += upper[y];
61: 					upper[y] = x;
62: 				}
63: 				return x == y;
64: 			}
65: 
66: 			public int count() {
67: 				int ct = 0;
68: 				for (int u : upper) if (u < 0) ct++;
69: 				return ct;
70: 			}
71: 
72: 			public int[][] toBucket() {
73: 				int n = upper.length;
74: 				int[][] ret = new int[n][];
75: 				int[] rp = new int[n];
76: 				for (int i = 0; i < n; i++) if (upper[i] < 0) ret[i] = new int[-upper[i]];
77: 				for (int i = 0; i < n; i++) {
78: 					int r = root(i);
79: 					ret[r][rp[r]++] = i;
80: 				}
81: 				return ret;
82: 			}
83: 		}
84: 		public static void main(String[] args) {
85:         LatestDayToCross latestDayToCross = new LatestDayToCross();
86:         int n = 3;
87:         int m = 3;
88:         int[][] cells = {
89:             {1, 2},
90:             {2, 1},
91:             {3, 3},
92:             {2, 2},
93:             {1, 1},
94:             {1, 3},
95:             {2, 3},
96:             {3, 1},
97:             {3, 2}
98:         };
99: 
100:         int result = latestDayToCross.latestDayToCross(n, m, cells);
101:         System.out.println(""Latest day to cross: "" + result);
102:     }
103: 
104: 		
105: 
106: 	}
107: ","[100, 3, 4, 5, 6, 7, 8, 9, 11, 12, 13, 14, 15, 17, 18, 22, 23, 24, 26, 27, 29, 31, 32]","{'output': ['100', '3', '4', '5', '6', '7', '8', '9', '11', '12', '13', '14', '15', '17', '18', '22', '23', '24', '26', '27', '29', '31', '32']}","[100, 3, 4, 5, 6, 8, 9, 11, 12, 13, 14, 15, 17, 18, 22, 23, 24, 26, 27, 29, 32]","{'output': ['100', '3', '4', '5', '6', '8', '9', '11', '12', '13', '14', '15', '17', '18', '22', '23', '24', '26', '27', '29', '32']}","[100, 3, 4, 5, 6, 7, 8, 9, 11, 12, 13, 14, 15, 17, 18, 22, 23, 24, 26, 27, 29, 32]","{'output': ['100', '3', '4', '5', '6', '7', '8', '9', '11', '12', '13', '14', '15', '17', '18', '22', '23', '24', '26', '27', '29', '32']}"
"import java.util.*;
class LenLongestFibSubseq {
    public int lenLongestFibSubseq(int[] A) {
        HashMap<Integer, Integer> s = new HashMap<Integer, Integer>();
        int n = A.length;
        for (int i = 0; i < n; i++) {
            s.put(A[i], i);
        }
        int[][] dp = new int[n][n];
        int max = 0;
        for (int i = n-1; i >= 0; i--) {
            for (int j = i; j < n; ++j) {
                int next = A[i]+A[j];
                if (s.containsKey(next)) {
                    int k = s.get(next);
                    dp[i][j] = dp[j][k]+1;
                    max = Math.max(max, dp[i][j]);
                } else {
                    dp[i][j] = 2;
                }
            }
        }
        return max;
    }
     public static void main(String[] args) {
        LenLongestFibSubseq lenLongestFibSubseq = new LenLongestFibSubseq();
        int[] A = {1, 3, 7, 11, 12, 14, 18};
        
        int result = lenLongestFibSubseq.lenLongestFibSubseq(A);
        
        System.out.println(""Length of the longest Fibonacci-like subsequence: "" + result);
    
}
}",LenLongestFibSubseq,29,"[26, 2, 27, 29, 4, 5, 9, 10, 11, 12, 13, 14, 17, 23]","1: import java.util.*;
2: class LenLongestFibSubseq {
3:     public int lenLongestFibSubseq(int[] A) {
4:         HashMap<Integer, Integer> s = new HashMap<Integer, Integer>();
5:         int n = A.length;
6:         for (int i = 0; i < n; i++) {
7:             s.put(A[i], i);
8:         }
9:         int[][] dp = new int[n][n];
10:         int max = 0;
11:         for (int i = n-1; i >= 0; i--) {
12:             for (int j = i; j < n; ++j) {
13:                 int next = A[i]+A[j];
14:                 if (s.containsKey(next)) {
15:                     int k = s.get(next);
16:                     dp[i][j] = dp[j][k]+1;
17:                     max = Math.max(max, dp[i][j]);
18:                 } else {
19:                     dp[i][j] = 2;
20:                 }
21:             }
22:         }
23:         return max;
24:     }
25:      public static void main(String[] args) {
26:         LenLongestFibSubseq lenLongestFibSubseq = new LenLongestFibSubseq();
27:         int[] A = {1, 3, 7, 11, 12, 14, 18};
28:         
29:         int result = lenLongestFibSubseq.lenLongestFibSubseq(A);
30:         
31:         System.out.println(""Length of the longest Fibonacci-like subsequence: "" + result);
32:     
33: }
34: }","[29, 27, 26, 3, 23, 17, 16, 15, 14, 13, 12, 11, 10]","{'output': ['29', '27', '26', '3', '23', '17', '16', '15', '14', '13', '12', '11', '10']}","[29, 3, 4, 5, 6, 7, 9, 10, 11, 12, 13, 14, 15, 16, 17, 19, 23, 27]","{'output': ['29', '3', '4', '5', '6', '7', '9', '10', '11', '12', '13', '14', '15', '16', '17', '19', '23', '27']}","[29, 28, 27, 26, 3, 23, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5]","{'output': ['29', '28', '27', '26', '3', '23', '17', '16', '15', '14', '13', '12', '11', '10', '9', '8', '7', '6', '5']}"
"import java.util.*;
class LongestStrChain {
boolean check(String a, String b) {
        int idx = 0;
        for (;idx < a.length(); idx++) if (a.charAt(idx) != b.charAt(idx)) break;
        for (;idx < a.length(); idx++) if (a.charAt(idx) != b.charAt(idx+1)) break;
        return idx >= a.length();
    }


    public int longestStrChain(String[] words) {
        int n = words.length;
        List<List<Integer>> graph = new ArrayList<>();
        for (int i = 0; i < n; i++) graph.add(new ArrayList<>());
        for (int i = 0; i < n; i++) for (int j = 0; j < n; j++) {
            String a = words[i];
            String b = words[j];
            if (a.length() + 1 == b.length() && check(a, b)) {
                graph.get(i).add(j);
            }
        }
        int[] dp = new int[n];
        Arrays.fill(dp, -1);
        int res = 0;
        for (int i = 0; i < n; i++) if (dp[i] == -1) {
            res = Math.max(res, solve(dp, i, graph));
        }
        return res;
    }

    private int solve(int[] dp, int cur, List<List<Integer>> graph) {
        if (dp[cur] != -1) return dp[cur];
        int res = 1;
        for (int to: graph.get(cur)) {
            res = Math.max(res, solve(dp, to, graph) + 1);
        }
        return dp[cur] = res;
    }
     public static void main(String[] args) {
        LongestStrChain longestStrChain = new LongestStrChain();
        String[] words = {""a"", ""b"", ""ba"", ""bca"", ""bda"", ""bdca""};
        
        int result = longestStrChain.longestStrChain(words);
        
        System.out.println(""Length of the longest string chain: "" + result);
    }

}",LongestStrChain,43,"[40, 2, 41, 43, 12, 13, 14, 15, 16, 17, 18, 4, 5, 6, 7, 19, 22, 23, 24, 25, 26, 32, 34, 35, 37, 33, 28]","1: import java.util.*;
2: class LongestStrChain {
3: boolean check(String a, String b) {
4:         int idx = 0;
5:         for (;idx < a.length(); idx++) if (a.charAt(idx) != b.charAt(idx)) break;
6:         for (;idx < a.length(); idx++) if (a.charAt(idx) != b.charAt(idx+1)) break;
7:         return idx >= a.length();
8:     }
9: 
10: 
11:     public int longestStrChain(String[] words) {
12:         int n = words.length;
13:         List<List<Integer>> graph = new ArrayList<>();
14:         for (int i = 0; i < n; i++) graph.add(new ArrayList<>());
15:         for (int i = 0; i < n; i++) for (int j = 0; j < n; j++) {
16:             String a = words[i];
17:             String b = words[j];
18:             if (a.length() + 1 == b.length() && check(a, b)) {
19:                 graph.get(i).add(j);
20:             }
21:         }
22:         int[] dp = new int[n];
23:         Arrays.fill(dp, -1);
24:         int res = 0;
25:         for (int i = 0; i < n; i++) if (dp[i] == -1) {
26:             res = Math.max(res, solve(dp, i, graph));
27:         }
28:         return res;
29:     }
30: 
31:     private int solve(int[] dp, int cur, List<List<Integer>> graph) {
32:         if (dp[cur] != -1) return dp[cur];
33:         int res = 1;
34:         for (int to: graph.get(cur)) {
35:             res = Math.max(res, solve(dp, to, graph) + 1);
36:         }
37:         return dp[cur] = res;
38:     }
39:      public static void main(String[] args) {
40:         LongestStrChain longestStrChain = new LongestStrChain();
41:         String[] words = {""a"", ""b"", ""ba"", ""bca"", ""bda"", ""bdca""};
42:         
43:         int result = longestStrChain.longestStrChain(words);
44:         
45:         System.out.println(""Length of the longest string chain: "" + result);
46:     }
47: 
48: }","[43, 41, 40, 11, 12, 24, 25, 26, 28, 31, 32, 33, 34, 35, 37]","{'output': ['43', '41', '40', '11', '12', '24', '25', '26', '28', '31', '32', '33', '34', '35', '37']}","[43, 41, 40, 28, 26, 25, 24, 23, 22, 18, 17, 16, 15, 14, 13, 12, 11]","{'output': ['43', '41', '40', '28', '26', '25', '24', '23', '22', '18', '17', '16', '15', '14', '13', '12', '11']}","[43, 41, 40, 11, 28, 27, 26, 25, 24, 22, 23, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12]","{'output': ['43', '41', '40', '11', '28', '27', '26', '25', '24', '22', '23', '21', '20', '19', '18', '17', '16', '15', '14', '13', '12']}"
"import java.util.*;
class LongestSubarray {
    public int longestSubarray(int[] nums, int limit) {
        int n = nums.length;
        TreeMap<Integer, Integer> tm = new TreeMap<>();
        int max = 0;
        int a = 0;
        for (int i = 0; i < n; ++i) {
            if (!tm.containsKey(nums[i])) {
                tm.put(nums[i],1);
            } else {
                tm.put(nums[i],tm.get(nums[i])+1);
            }
            while (tm.lastKey()-tm.firstKey()>limit) {
                tm.put(nums[a], tm.get(nums[a])-1);
                if (tm.get(nums[a])==0)
                    tm.remove(nums[a]);
                a++;
            }
            max = Math.max(max,i-a+1);
        }
        return max;
    }
      public static void main(String[] args) {
        LongestSubarray longestSubarray = new LongestSubarray();
        int[] nums = {8, 2, 4, 7};
        int limit = 4;
        
        int result = longestSubarray.longestSubarray(nums, limit);
        
        System.out.println(""Length of the longest subarray: "" + result);
    }
}",LongestSubarray,29,"[25, 2, 26, 29, 4, 5, 6, 7, 8, 20, 14, 18, 22]","1: import java.util.*;
2: class LongestSubarray {
3:     public int longestSubarray(int[] nums, int limit) {
4:         int n = nums.length;
5:         TreeMap<Integer, Integer> tm = new TreeMap<>();
6:         int max = 0;
7:         int a = 0;
8:         for (int i = 0; i < n; ++i) {
9:             if (!tm.containsKey(nums[i])) {
10:                 tm.put(nums[i],1);
11:             } else {
12:                 tm.put(nums[i],tm.get(nums[i])+1);
13:             }
14:             while (tm.lastKey()-tm.firstKey()>limit) {
15:                 tm.put(nums[a], tm.get(nums[a])-1);
16:                 if (tm.get(nums[a])==0)
17:                     tm.remove(nums[a]);
18:                 a++;
19:             }
20:             max = Math.max(max,i-a+1);
21:         }
22:         return max;
23:     }
24:       public static void main(String[] args) {
25:         LongestSubarray longestSubarray = new LongestSubarray();
26:         int[] nums = {8, 2, 4, 7};
27:         int limit = 4;
28:         
29:         int result = longestSubarray.longestSubarray(nums, limit);
30:         
31:         System.out.println(""Length of the longest subarray: "" + result);
32:     }
33: }","[29, 25, 3, 22, 20, 8, 4, 5, 6, 7, 9, 10, 12, 14, 15, 16, 17, 18]","{'output': ['29', '25', '3', '22', '20', '8', '4', '5', '6', '7', '9', '10', '12', '14', '15', '16', '17', '18']}","[29, 25, 3, 4, 5, 6, 7, 8, 9, 10, 12, 14, 15, 16, 17, 18, 19, 20, 21, 22]","{'output': ['29', '25', '3', '4', '5', '6', '7', '8', '9', '10', '12', '14', '15', '16', '17', '18', '19', '20', '21', '22']}","[29, 25, 3, 22]","{'output': ['29', '25', '3', '22']}"
"class LongestWPI {
    public int longestWPI(int[] hs) {
        
        int l = hs.length;
        
        int s[] = new int[l+1];
        
        for(int i=0;i<l;++i){
            s[i+1] = s[i]+((hs[i]>8)?1:0);
            //System.out.println(hs[i]);
        }
        int res = 0;
        for(int i=0;i<l;++i){
            for(int j=i;j<l;++j){
                int tot = j-i+1;
                 if(tot<=res){
                     continue;
                 }
                int lao = s[j+1]-s[i];
                if(lao>tot-lao){
                    res = Math.max(res,tot);
                }
            }
        }
        return res;
        
    }
    public static void main(String[] args) {
        LongestWPI longestWPI = new LongestWPI();
        int[] hours = {9, 9, 6, 0, 6, 6, 9};
        
        int result = longestWPI.longestWPI(hours);
        
        System.out.println(""Length of the longest well-performing interval: "" + result);
    }
}",LongestWPI,32,"[29, 1, 30, 32, 4, 6, 8, 9, 12, 13, 14, 15, 19, 20, 21, 25]","1: class LongestWPI {
2:     public int longestWPI(int[] hs) {
3:         
4:         int l = hs.length;
5:         
6:         int s[] = new int[l+1];
7:         
8:         for(int i=0;i<l;++i){
9:             s[i+1] = s[i]+((hs[i]>8)?1:0);
10:             //System.out.println(hs[i]);
11:         }
12:         int res = 0;
13:         for(int i=0;i<l;++i){
14:             for(int j=i;j<l;++j){
15:                 int tot = j-i+1;
16:                  if(tot<=res){
17:                      continue;
18:                  }
19:                 int lao = s[j+1]-s[i];
20:                 if(lao>tot-lao){
21:                     res = Math.max(res,tot);
22:                 }
23:             }
24:         }
25:         return res;
26:         
27:     }
28:     public static void main(String[] args) {
29:         LongestWPI longestWPI = new LongestWPI();
30:         int[] hours = {9, 9, 6, 0, 6, 6, 9};
31:         
32:         int result = longestWPI.longestWPI(hours);
33:         
34:         System.out.println(""Length of the longest well-performing interval: "" + result);
35:     }
36: }","[32, 2, 4, 6, 8, 9, 12, 13, 14, 15, 16, 18, 19, 20, 21, 25, 30]","{'output': ['32', '2', '4', '6', '8', '9', '12', '13', '14', '15', '16', '18', '19', '20', '21', '25', '30']}","[32, 29, 2, 4, 6, 8, 9, 12, 13, 14, 15, 16, 17, 19, 20, 21, 23, 24, 25]","{'output': ['32', '29', '2', '4', '6', '8', '9', '12', '13', '14', '15', '16', '17', '19', '20', '21', '23', '24', '25']}","[32, 2, 4, 6, 8, 9, 12, 13, 14, 15, 16, 17, 19, 20, 21, 23, 25, 30]","{'output': ['32', '2', '4', '6', '8', '9', '12', '13', '14', '15', '16', '17', '19', '20', '21', '23', '25', '30']}"
"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */

 
class LongestZigZag {
	 public static class TreeNode {
     int val;
     TreeNode left;
     TreeNode right;
     TreeNode(int x) { val = x; }
	 }
	int res = 0;
	public int longestZigZag(TreeNode root) {
		res = 0;
		solve(root);
		return res - 1;
	}

	private int[] solve(TreeNode cur) {
		if (cur == null) return new int[] {0, 0};
		int[] left = solve(cur.left);
		int[] right = solve(cur.right);
		int[] ans = new int[] {left[1] + 1, right[0] + 1};
		this.res = Math.max(this.res, ans[0]);
		this.res = Math.max(this.res, ans[1]);
		return ans;
	}
	public static void main(String[] args) {
        LongestZigZag longestZigZag = new LongestZigZag();
        
        LongestZigZag.TreeNode root = new LongestZigZag.TreeNode(1);
        root.left = new LongestZigZag.TreeNode(2);
        root.right = new LongestZigZag.TreeNode(3);
        root.left.right = new LongestZigZag.TreeNode(4);
        root.left.right.right = new LongestZigZag.TreeNode(5);
        root.left.right.right.left = new LongestZigZag.TreeNode(6);

        int result = longestZigZag.longestZigZag(root);

        System.out.println(""Length of the longest ZigZag path: "" + result);
    }
}
",LongestZigZag,45,"[36, 12, 19, 38, 39, 40, 41, 42, 43, 45, 21, 22, 27, 28, 29, 30, 31, 32, 33, 23]","1: /**
2:  * Definition for a binary tree node.
3:  * public class TreeNode {
4:  *     int val;
5:  *     TreeNode left;
6:  *     TreeNode right;
7:  *     TreeNode(int x) { val = x; }
8:  * }
9:  */
10: 
11:  
12: class LongestZigZag {
13: 	 public static class TreeNode {
14:      int val;
15:      TreeNode left;
16:      TreeNode right;
17:      TreeNode(int x) { val = x; }
18: 	 }
19: 	int res = 0;
20: 	public int longestZigZag(TreeNode root) {
21: 		res = 0;
22: 		solve(root);
23: 		return res - 1;
24: 	}
25: 
26: 	private int[] solve(TreeNode cur) {
27: 		if (cur == null) return new int[] {0, 0};
28: 		int[] left = solve(cur.left);
29: 		int[] right = solve(cur.right);
30: 		int[] ans = new int[] {left[1] + 1, right[0] + 1};
31: 		this.res = Math.max(this.res, ans[0]);
32: 		this.res = Math.max(this.res, ans[1]);
33: 		return ans;
34: 	}
35: 	public static void main(String[] args) {
36:         LongestZigZag longestZigZag = new LongestZigZag();
37:         
38:         LongestZigZag.TreeNode root = new LongestZigZag.TreeNode(1);
39:         root.left = new LongestZigZag.TreeNode(2);
40:         root.right = new LongestZigZag.TreeNode(3);
41:         root.left.right = new LongestZigZag.TreeNode(4);
42:         root.left.right.right = new LongestZigZag.TreeNode(5);
43:         root.left.right.right.left = new LongestZigZag.TreeNode(6);
44: 
45:         int result = longestZigZag.longestZigZag(root);
46: 
47:         System.out.println(""Length of the longest ZigZag path: "" + result);
48:     }
49: }
50: ","[45, 35, 36, 38, 39, 40, 41, 42, 43, 20, 21, 22, 23, 26, 27, 28, 29, 30, 31, 32]","{'output': ['45', '35', '36', '38', '39', '40', '41', '42', '43', '20', '21', '22', '23', '26', '27', '28', '29', '30', '31', '32']}","[45, 20, 21, 22, 23]","{'output': ['45', '20', '21', '22', '23']}","[45, 36, 38, 39, 40, 41, 42, 43, 20, 21, 22, 23, 26, 27, 28, 29, 30, 31, 32]","{'output': ['45', '36', '38', '39', '40', '41', '42', '43', '20', '21', '22', '23', '26', '27', '28', '29', '30', '31', '32']}"
"	class MakeStringSorted {
		public int makeStringSorted(String s) {
			int n = s.length();
			int[] a = new int[n];
			for(int i = 0;i < n;i++){
				a[i] = s.charAt(i)-'a';
			}
			int[] f = new int[26];
			for(int v : a)f[v]++;

			final int mod = 1000000007;

			int[][] fif = enumFIF(5000, mod);
			long ret = 0;
			for(int i = 0;i < n;i++){
				for(int j = 0;j < a[i];j++){
					if(f[j] == 0)continue;
					f[j]--;
					long num = 1;
					int su = 0;
					for(int k = 0;k < 26;k++){
						su += f[k];
						num = num * C(su, f[k], mod, fif) % mod;
					}
					ret += num;
					f[j]++;
				}
				f[a[i]]--;
			}
			return (int)(ret%mod);
		}

		public long C(int n, int r, int mod, int[][] fif) {
			if (n < 0 || r < 0 || r > n) return 0;
			return (long) fif[0][n] * fif[1][r] % mod * fif[1][n - r] % mod;
		}


		public int[][] enumFIF(int n, int mod) {
			int[] f = new int[n + 1];
			int[] invf = new int[n + 1];
			f[0] = 1;
			for (int i = 1; i <= n; i++) {
				f[i] = (int) ((long) f[i - 1] * i % mod);
			}
			long a = f[n];
			long b = mod;
			long p = 1, q = 0;
			while (b > 0) {
				long c = a / b;
				long d;
				d = a;
				a = b;
				b = d % b;
				d = p;
				p = q;
				q = d - c * q;
			}
			invf[n] = (int) (p < 0 ? p + mod : p);
			for (int i = n - 1; i >= 0; i--) {
				invf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);
			}
			return new int[][]{f, invf};
		}
		public static void main(String[] args) {
        MakeStringSorted makeStringSorted = new MakeStringSorted();
        
        String s = ""cba"";
        
        int result = makeStringSorted.makeStringSorted(s);
        
        System.out.println(""Number of steps to make the string sorted: "" + result);
    }

	}
",MakeStringSorted,70,"[66, 1, 70, 3, 4, 5, 6, 8, 9, 13, 40, 41, 42, 43, 44, 46, 47, 48, 49, 50, 52, 53, 54, 55, 56, 57, 59, 60, 61, 63, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 35, 25, 26, 28, 30]","1: 	class MakeStringSorted {
2: 		public int makeStringSorted(String s) {
3: 			int n = s.length();
4: 			int[] a = new int[n];
5: 			for(int i = 0;i < n;i++){
6: 				a[i] = s.charAt(i)-'a';
7: 			}
8: 			int[] f = new int[26];
9: 			for(int v : a)f[v]++;
10: 
11: 			final int mod = 1000000007;
12: 
13: 			int[][] fif = enumFIF(5000, mod);
14: 			long ret = 0;
15: 			for(int i = 0;i < n;i++){
16: 				for(int j = 0;j < a[i];j++){
17: 					if(f[j] == 0)continue;
18: 					f[j]--;
19: 					long num = 1;
20: 					int su = 0;
21: 					for(int k = 0;k < 26;k++){
22: 						su += f[k];
23: 						num = num * C(su, f[k], mod, fif) % mod;
24: 					}
25: 					ret += num;
26: 					f[j]++;
27: 				}
28: 				f[a[i]]--;
29: 			}
30: 			return (int)(ret%mod);
31: 		}
32: 
33: 		public long C(int n, int r, int mod, int[][] fif) {
34: 			if (n < 0 || r < 0 || r > n) return 0;
35: 			return (long) fif[0][n] * fif[1][r] % mod * fif[1][n - r] % mod;
36: 		}
37: 
38: 
39: 		public int[][] enumFIF(int n, int mod) {
40: 			int[] f = new int[n + 1];
41: 			int[] invf = new int[n + 1];
42: 			f[0] = 1;
43: 			for (int i = 1; i <= n; i++) {
44: 				f[i] = (int) ((long) f[i - 1] * i % mod);
45: 			}
46: 			long a = f[n];
47: 			long b = mod;
48: 			long p = 1, q = 0;
49: 			while (b > 0) {
50: 				long c = a / b;
51: 				long d;
52: 				d = a;
53: 				a = b;
54: 				b = d % b;
55: 				d = p;
56: 				p = q;
57: 				q = d - c * q;
58: 			}
59: 			invf[n] = (int) (p < 0 ? p + mod : p);
60: 			for (int i = n - 1; i >= 0; i--) {
61: 				invf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);
62: 			}
63: 			return new int[][]{f, invf};
64: 		}
65: 		public static void main(String[] args) {
66:         MakeStringSorted makeStringSorted = new MakeStringSorted();
67:         
68:         String s = ""cba"";
69:         
70:         int result = makeStringSorted.makeStringSorted(s);
71:         
72:         System.out.println(""Number of steps to make the string sorted: "" + result);
73:     }
74: 
75: 	}
76: ","[70, 68, 66, 2, 15, 16, 17, 18, 21, 22, 23, 25, 26, 28, 30]","{'output': ['70', '68', '66', '2', '15', '16', '17', '18', '21', '22', '23', '25', '26', '28', '30']}","[70, 2, 3, 5, 6, 7, 8, 9, 11, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 28, 30, 33, 34, 35, 39, 40, 41, 42, 43, 44, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 63]","{'output': ['70', '2', '3', '5', '6', '7', '8', '9', '11', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24', '25', '26', '28', '30', '33', '34', '35', '39', '40', '41', '42', '43', '44', '46', '47', '48', '49', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '60', '61', '63']}","[70, 2, 3, 4, 5, 6, 8, 9, 11, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 25, 26, 28, 30]","{'output': ['70', '2', '3', '4', '5', '6', '8', '9', '11', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '25', '26', '28', '30']}"
"import java.util.*;

class MatrixSumQueries {

	public long matrixSumQueries(int n, int[][] queries) {
		HashSet<Integer> row = new HashSet<>(), col = new HashSet<>();
		long sum = 0;
		for (int i = queries.length - 1; i >= 0; i--) {
			sum += !(queries[i][0] == 0 ? row : col).add(queries[i][1]) ? 0
					: queries[i][2] * (n - (queries[i][0] == 0 ? col : row).size());
		}
		return sum;
	}
	 public static void main(String[] args) {
        MatrixSumQueries matrixSumQueries = new MatrixSumQueries();
        
        int n = 3;
        int[][] queries = {
            {0, 0, 5},
            {1, 1, 7},
            {0, 2, -3},
            {1, 0, 2}
        };
        
        long result = matrixSumQueries.matrixSumQueries(n, queries);
        
        System.out.println(""Matrix sum after queries: "" + result);
    }
}",MatrixSumQueries,25,"[15, 3, 18, 25, 6, 7, 8, 9, 10, 12]","1: import java.util.*;
2: 
3: class MatrixSumQueries {
4: 
5: 	public long matrixSumQueries(int n, int[][] queries) {
6: 		HashSet<Integer> row = new HashSet<>(), col = new HashSet<>();
7: 		long sum = 0;
8: 		for (int i = queries.length - 1; i >= 0; i--) {
9: 			sum += !(queries[i][0] == 0 ? row : col).add(queries[i][1]) ? 0
10: 					: queries[i][2] * (n - (queries[i][0] == 0 ? col : row).size());
11: 		}
12: 		return sum;
13: 	}
14: 	 public static void main(String[] args) {
15:         MatrixSumQueries matrixSumQueries = new MatrixSumQueries();
16:         
17:         int n = 3;
18:         int[][] queries = {
19:             {0, 0, 5},
20:             {1, 1, 7},
21:             {0, 2, -3},
22:             {1, 0, 2}
23:         };
24:         
25:         long result = matrixSumQueries.matrixSumQueries(n, queries);
26:         
27:         System.out.println(""Matrix sum after queries: "" + result);
28:     }
29: }","[25, 5, 8, 9, 10, 12]","{'output': ['25', '5', '8', '9', '10', '12']}","[25, 5, 6, 8, 9, 10]","{'output': ['25', '5', '6', '8', '9', '10']}","[25, 15, 17, 18]","{'output': ['25', '15', '17', '18']}"
"	import java.util.*;
	
	class MaxDistance {
	    public int maxDistance(int[][] a) {
	        int n = a.length, m = a[0].length;
	        int[][] d = new int[n][m];
	        Queue<int[]> q = new ArrayDeque<>();
	        for(int i = 0;i < n;i++){
	        	for(int j = 0;j < m;j++){
	        		d[i][j] = a[i][j] == 1 ? 0 : 99999999;
	        		if(d[i][j] == 0)q.add(new int[]{i, j});
	        	}
	        }
	        
	        int[] dr = { 1, 0, -1, 0 };
			int[] dc = { 0, 1, 0, -1 };
	        while(!q.isEmpty()){
	        	int[] cur = q.poll();
	        	int r = cur[0], c = cur[1];
	        	for(int k = 0;k < 4;k++){
	        		int nr = r + dr[k], nc = c + dc[k];
	        		if(nr >= 0 && nr < n && nc >= 0 && nc < m && d[nr][nc] > d[r][c] + 1){
	        			d[nr][nc] = d[r][c] + 1;
	        			q.add(new int[]{nr, nc});
	        		}
	        	}
	        }
	        
	        int max = 0;
	        for(int i = 0;i < n;i++){
	        	for(int j = 0;j < m;j++){
	        		max = Math.max(max, d[i][j]);
	        	}
	        }
	        if(max == 99999999 || max == 0)max = -1;
	        return max;
	    }
		public static void main(String[] args) {
        MaxDistance maxDistance = new MaxDistance();
        
        int[][] grid = {
            {1, 0, 1},
            {0, 0, 0},
            {1, 0, 1}
        };
        
        int result = maxDistance.maxDistance(grid);
        
        System.out.println(""Maximum distance from land to water: "" + result);
    }
	}	
",MaxDistance,47,"[39, 3, 41, 47, 5, 6, 29, 30, 31, 32, 36]","1: 	import java.util.*;
2: 	
3: 	class MaxDistance {
4: 	    public int maxDistance(int[][] a) {
5: 	        int n = a.length, m = a[0].length;
6: 	        int[][] d = new int[n][m];
7: 	        Queue<int[]> q = new ArrayDeque<>();
8: 	        for(int i = 0;i < n;i++){
9: 	        	for(int j = 0;j < m;j++){
10: 	        		d[i][j] = a[i][j] == 1 ? 0 : 99999999;
11: 	        		if(d[i][j] == 0)q.add(new int[]{i, j});
12: 	        	}
13: 	        }
14: 	        
15: 	        int[] dr = { 1, 0, -1, 0 };
16: 			int[] dc = { 0, 1, 0, -1 };
17: 	        while(!q.isEmpty()){
18: 	        	int[] cur = q.poll();
19: 	        	int r = cur[0], c = cur[1];
20: 	        	for(int k = 0;k < 4;k++){
21: 	        		int nr = r + dr[k], nc = c + dc[k];
22: 	        		if(nr >= 0 && nr < n && nc >= 0 && nc < m && d[nr][nc] > d[r][c] + 1){
23: 	        			d[nr][nc] = d[r][c] + 1;
24: 	        			q.add(new int[]{nr, nc});
25: 	        		}
26: 	        	}
27: 	        }
28: 	        
29: 	        int max = 0;
30: 	        for(int i = 0;i < n;i++){
31: 	        	for(int j = 0;j < m;j++){
32: 	        		max = Math.max(max, d[i][j]);
33: 	        	}
34: 	        }
35: 	        if(max == 99999999 || max == 0)max = -1;
36: 	        return max;
37: 	    }
38: 		public static void main(String[] args) {
39:         MaxDistance maxDistance = new MaxDistance();
40:         
41:         int[][] grid = {
42:             {1, 0, 1},
43:             {0, 0, 0},
44:             {1, 0, 1}
45:         };
46:         
47:         int result = maxDistance.maxDistance(grid);
48:         
49:         System.out.println(""Maximum distance from land to water: "" + result);
50:     }
51: 	}	
52: ","[47, 39, 46]","{'output': ['47', '39', '46']}","[47, 39, 4, 36, 35, 29, 32, 31, 30, 6, 8, 9, 10, 11, 7, 17, 18, 19, 20, 21, 22, 23, 24, 16, 15]","{'output': ['47', '39', '4', '36', '35', '29', '32', '31', '30', '6', '8', '9', '10', '11', '7', '17', '18', '19', '20', '21', '22', '23', '24', '16', '15']}","[47, 39, 4, 36]","{'output': ['47', '39', '4', '36']}"
"import java.util.*;

class MaxIncreasingCells {
    public int maxIncreasingCells(int[][] mat) {
        int N = mat.length, M = mat[0].length;
        List<int[]> sort = new ArrayList<>();
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < M; j++) {
                sort.add(new int[]{mat[i][j], i, j});
            }
        }
        Collections.sort(sort, ( a, b) -> a[0] - b[0]);
        int[][] dp = new int[N][M];
        int[] row = new int[N], col = new int[M];
        int res = 0;
        for (int i = 0; i < sort.size(); i++) {
            int j = i;
            while (j + 1 < sort.size() && sort.get(j + 1)[0] == sort.get(i)[0]) j++;
            for (int k = i; k <= j; k++) {
                int r = sort.get(k)[1], c = sort.get(k)[2];
                dp[r][c] = Math.max(row[r] + 1, col[c] + 1);
                res = Math.max(res, dp[r][c]);
            }
            for (int k = i; k <= j; k++) {
                int r = sort.get(k)[1], c = sort.get(k)[2];
                row[r] = Math.max(row[r], dp[r][c]);
                col[c] = Math.max(col[c], dp[r][c]);
            }
            i = j;
        }
        return res;
    }
    public static void main(String[] args) {
        MaxIncreasingCells maxIncreasingCells = new MaxIncreasingCells();
        
        int[][] mat = {
            {3, 1, 6},
            {7, 5, 8},
            {9, 2, 4}
        };
        
        int result = maxIncreasingCells.maxIncreasingCells(mat);
        
        System.out.println(""Maximum number of increasing cells: "" + result);
    }
}",MaxIncreasingCells,42,"[34, 3, 36, 42, 5, 6, 7, 8, 9, 12, 13, 15, 16, 17, 18, 19, 20, 22, 24, 25, 31]","1: import java.util.*;
2: 
3: class MaxIncreasingCells {
4:     public int maxIncreasingCells(int[][] mat) {
5:         int N = mat.length, M = mat[0].length;
6:         List<int[]> sort = new ArrayList<>();
7:         for (int i = 0; i < N; i++) {
8:             for (int j = 0; j < M; j++) {
9:                 sort.add(new int[]{mat[i][j], i, j});
10:             }
11:         }
12:         Collections.sort(sort, ( a, b) -> a[0] - b[0]);
13:         int[][] dp = new int[N][M];
14:         int[] row = new int[N], col = new int[M];
15:         int res = 0;
16:         for (int i = 0; i < sort.size(); i++) {
17:             int j = i;
18:             while (j + 1 < sort.size() && sort.get(j + 1)[0] == sort.get(i)[0]) j++;
19:             for (int k = i; k <= j; k++) {
20:                 int r = sort.get(k)[1], c = sort.get(k)[2];
21:                 dp[r][c] = Math.max(row[r] + 1, col[c] + 1);
22:                 res = Math.max(res, dp[r][c]);
23:             }
24:             for (int k = i; k <= j; k++) {
25:                 int r = sort.get(k)[1], c = sort.get(k)[2];
26:                 row[r] = Math.max(row[r], dp[r][c]);
27:                 col[c] = Math.max(col[c], dp[r][c]);
28:             }
29:             i = j;
30:         }
31:         return res;
32:     }
33:     public static void main(String[] args) {
34:         MaxIncreasingCells maxIncreasingCells = new MaxIncreasingCells();
35:         
36:         int[][] mat = {
37:             {3, 1, 6},
38:             {7, 5, 8},
39:             {9, 2, 4}
40:         };
41:         
42:         int result = maxIncreasingCells.maxIncreasingCells(mat);
43:         
44:         System.out.println(""Maximum number of increasing cells: "" + result);
45:     }
46: }","[42, 34, 36]","{'output': ['42', '34', '36']}","[42, 34, 4, 5, 6, 7, 8, 9, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 24, 25, 26, 27, 29, 31, 36, 37, 38, 39, 40]","{'output': ['42', '34', '4', '5', '6', '7', '8', '9', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '24', '25', '26', '27', '29', '31', '36', '37', '38', '39', '40']}","[42, 34, 4, 5, 6, 7, 8, 9, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 24, 25, 26, 27, 29, 31]","{'output': ['42', '34', '4', '5', '6', '7', '8', '9', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '24', '25', '26', '27', '29', '31']}"
"class MaxMoves {

	public int maxMoves(int[][] grid) {
		int dp[][] = new int[grid.length][grid[0].length], max = 0;
		for (int i = 1; i < grid[0].length; i++) {
			for (int j = 0; j < grid.length; j++) {
				max = (dp[j][i] = Math.max(j > 0 && grid[j][i] > grid[j - 1][i - 1] ? dp[j - 1][i - 1] + 1 : 0,
						Math.max(j < grid.length - 1 && grid[j][i] > grid[j + 1][i - 1] ? dp[j + 1][i - 1] + 1 : 0,
								grid[j][i] > grid[j][i - 1] ? dp[j][i - 1] + 1 : 0))) == i ? i : max;
			}
		}
		return max;
	}
	public static void main(String[] args) {
        MaxMoves maxMoves = new MaxMoves();
        
        int[][] grid = {
            {3, 4, 5},
            {3, 2, 6},
            {2, 2, 1}
        };
        
        int result = maxMoves.maxMoves(grid);
        
        System.out.println(""Maximum number of moves: "" + result);
    }
}",MaxMoves,23,"[15, 1, 17, 23, 5, 6, 7, 12]","1: class MaxMoves {
2: 
3: 	public int maxMoves(int[][] grid) {
4: 		int dp[][] = new int[grid.length][grid[0].length], max = 0;
5: 		for (int i = 1; i < grid[0].length; i++) {
6: 			for (int j = 0; j < grid.length; j++) {
7: 				max = (dp[j][i] = Math.max(j > 0 && grid[j][i] > grid[j - 1][i - 1] ? dp[j - 1][i - 1] + 1 : 0,
8: 						Math.max(j < grid.length - 1 && grid[j][i] > grid[j + 1][i - 1] ? dp[j + 1][i - 1] + 1 : 0,
9: 								grid[j][i] > grid[j][i - 1] ? dp[j][i - 1] + 1 : 0))) == i ? i : max;
10: 			}
11: 		}
12: 		return max;
13: 	}
14: 	public static void main(String[] args) {
15:         MaxMoves maxMoves = new MaxMoves();
16:         
17:         int[][] grid = {
18:             {3, 4, 5},
19:             {3, 2, 6},
20:             {2, 2, 1}
21:         };
22:         
23:         int result = maxMoves.maxMoves(grid);
24:         
25:         System.out.println(""Maximum number of moves: "" + result);
26:     }
27: }","[23, 3, 4, 5, 6, 7, 8, 9, 12, 17, 18, 19, 20, 21]","{'output': ['23', '3', '4', '5', '6', '7', '8', '9', '12', '17', '18', '19', '20', '21']}","[23, 15, 3, 4, 5, 6, 7, 8, 9, 12]","{'output': ['23', '15', '3', '4', '5', '6', '7', '8', '9', '12']}","[23, 3, 4, 5, 6, 7, 8, 9, 12, 17, 18, 19, 20, 21]","{'output': ['23', '3', '4', '5', '6', '7', '8', '9', '12', '17', '18', '19', '20', '21']}"
"	import java.util.*;
	
	class MaxPerformance {
	    public int maxPerformance(int n, int[] speed, int[] efficiency, int k) {
	        int[][] se = new int[n][];
	        for(int i = 0;i < n;i++){
	        	se[i] = new int[]{speed[i], efficiency[i]};
	        }
	        int mod = 1000000007;
	        Arrays.sort(se, new Comparator<int[]>() {
				public int compare(int[] a, int[] b) {
					return -(a[1] - b[1]);
				}
			});
	        PriorityQueue<Integer> pq = new PriorityQueue<>();
	        long s = 0;
	        long max = 0;
	        for(int i = 0;i < n;i++){
	        	pq.add(se[i][0]);
	        	s += se[i][0];
	        	if(pq.size() > k){
	        		s -= pq.poll();
	        	}
	        	max = Math.max(max, s*se[i][1]);
	        }
	        return (int)(max % mod);
	    }
		 public static void main(String[] args) {
        MaxPerformance maxPerformance = new MaxPerformance();
        
        int n = 6;
        int[] speed = {2, 10, 3, 1, 5, 8};
        int[] efficiency = {5, 4, 3, 9, 7, 2};
        int k = 3;
        
        int result = maxPerformance.maxPerformance(n, speed, efficiency, k);
        
        System.out.println(""Maximum performance: "" + result);
    }
	}	
",MaxPerformance,36,"[29, 3, 32, 33, 36, 5, 6, 7, 10, 15, 16, 17, 18, 20, 24, 22, 26]","1: 	import java.util.*;
2: 	
3: 	class MaxPerformance {
4: 	    public int maxPerformance(int n, int[] speed, int[] efficiency, int k) {
5: 	        int[][] se = new int[n][];
6: 	        for(int i = 0;i < n;i++){
7: 	        	se[i] = new int[]{speed[i], efficiency[i]};
8: 	        }
9: 	        int mod = 1000000007;
10: 	        Arrays.sort(se, new Comparator<int[]>() {
11: 				public int compare(int[] a, int[] b) {
12: 					return -(a[1] - b[1]);
13: 				}
14: 			});
15: 	        PriorityQueue<Integer> pq = new PriorityQueue<>();
16: 	        long s = 0;
17: 	        long max = 0;
18: 	        for(int i = 0;i < n;i++){
19: 	        	pq.add(se[i][0]);
20: 	        	s += se[i][0];
21: 	        	if(pq.size() > k){
22: 	        		s -= pq.poll();
23: 	        	}
24: 	        	max = Math.max(max, s*se[i][1]);
25: 	        }
26: 	        return (int)(max % mod);
27: 	    }
28: 		 public static void main(String[] args) {
29:         MaxPerformance maxPerformance = new MaxPerformance();
30:         
31:         int n = 6;
32:         int[] speed = {2, 10, 3, 1, 5, 8};
33:         int[] efficiency = {5, 4, 3, 9, 7, 2};
34:         int k = 3;
35:         
36:         int result = maxPerformance.maxPerformance(n, speed, efficiency, k);
37:         
38:         System.out.println(""Maximum performance: "" + result);
39:     }
40: 	}	
41: ","[36, 4, 26, 24, 18, 20, 19, 22, 21, 17, 16, 10, 9, 8, 7, 6, 5, 31, 32, 33, 34]","{'output': ['36', '4', '26', '24', '18', '20', '19', '22', '21', '17', '16', '10', '9', '8', '7', '6', '5', '31', '32', '33', '34']}","[36, 4, 26, 24, 25, 23, 22, 21, 20, 19, 18, 17, 16, 15, 10, 12, 11, 9, 8, 7, 6, 5, 31, 32, 33, 34]","{'output': ['36', '4', '26', '24', '25', '23', '22', '21', '20', '19', '18', '17', '16', '15', '10', '12', '11', '9', '8', '7', '6', '5', '31', '32', '33', '34']}","[36, 4, 5, 6, 7, 9, 10, 11, 12, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 26, 31, 32, 33, 34]","{'output': ['36', '4', '5', '6', '7', '9', '10', '11', '12', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24', '26', '31', '32', '33', '34']}"
"import java.util.*;

class MaxSatisfaction {
    public int maxSatisfaction(int[] sf) {
        Arrays.sort(sf);
        int n = sf.length;
        int curr = 0;
        int ans = 0;
        int sum = 0;
        for (int i = n-1; i>=0; --i) {
            sum+=sf[i];
            curr+=sum;
            ans = Math.max(ans,curr);
        }
        return ans;
    }
      public static void main(String[] args) {
        MaxSatisfaction maxSatisfaction = new MaxSatisfaction();
        
        int[] sf = {-1, -8, 0, 5, -9};
        
        int result = maxSatisfaction.maxSatisfaction(sf);
        
        System.out.println(""Maximum satisfaction: "" + result);
    }
}",MaxSatisfaction,22,"[18, 3, 20, 22, 5, 6, 7, 8, 9, 10, 11, 12, 13, 15]","1: import java.util.*;
2: 
3: class MaxSatisfaction {
4:     public int maxSatisfaction(int[] sf) {
5:         Arrays.sort(sf);
6:         int n = sf.length;
7:         int curr = 0;
8:         int ans = 0;
9:         int sum = 0;
10:         for (int i = n-1; i>=0; --i) {
11:             sum+=sf[i];
12:             curr+=sum;
13:             ans = Math.max(ans,curr);
14:         }
15:         return ans;
16:     }
17:       public static void main(String[] args) {
18:         MaxSatisfaction maxSatisfaction = new MaxSatisfaction();
19:         
20:         int[] sf = {-1, -8, 0, 5, -9};
21:         
22:         int result = maxSatisfaction.maxSatisfaction(sf);
23:         
24:         System.out.println(""Maximum satisfaction: "" + result);
25:     }
26: }","[22, 20, 18, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]","{'output': ['22', '20', '18', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15']}","[22, 20, 18, 4, 5, 10, 11, 12, 13, 15]","{'output': ['22', '20', '18', '4', '5', '10', '11', '12', '13', '15']}","[22, 20, 18, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 15]","{'output': ['22', '20', '18', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '15']}"
"class MaximumCandies {

	public int maximumCandies(int[] candies, long k) {
		long left = 0, right = 10000000;
		while (left < right) {
			long mid = (left + right + 1) / 2, count = 0;
			for (int candy : candies) {
				count += candy / mid;
			}
			if (count < k) {
				right = mid - 1;
			} else {
				left = mid;
			}
		}
		return (int) left;
	}
	  public static void main(String[] args) {
        MaximumCandies maximumCandies = new MaximumCandies();
        
        int[] candies = {5, 8, 6};
        long k = 3;
        
        int result = maximumCandies.maximumCandies(candies, k);
        
        System.out.println(""Maximum number of candies each child can get: "" + result);
    }
}",MaximumCandies,24,"[19, 1, 21, 24, 4, 5, 6, 7, 8, 10, 11, 13, 16]","1: class MaximumCandies {
2: 
3: 	public int maximumCandies(int[] candies, long k) {
4: 		long left = 0, right = 10000000;
5: 		while (left < right) {
6: 			long mid = (left + right + 1) / 2, count = 0;
7: 			for (int candy : candies) {
8: 				count += candy / mid;
9: 			}
10: 			if (count < k) {
11: 				right = mid - 1;
12: 			} else {
13: 				left = mid;
14: 			}
15: 		}
16: 		return (int) left;
17: 	}
18: 	  public static void main(String[] args) {
19:         MaximumCandies maximumCandies = new MaximumCandies();
20:         
21:         int[] candies = {5, 8, 6};
22:         long k = 3;
23:         
24:         int result = maximumCandies.maximumCandies(candies, k);
25:         
26:         System.out.println(""Maximum number of candies each child can get: "" + result);
27:     }
28: }","[24, 23, 21, 19, 3, 16]","{'output': ['24', '23', '21', '19', '3', '16']}","[24, 23, 22, 21, 19]","{'output': ['24', '23', '22', '21', '19']}","[24, 23, 22, 21, 19]","{'output': ['24', '23', '22', '21', '19']}"
"import java.util.*;
class MaximumMinimumPath {
    
    int dir[][] = {{0,-1},{0,1},{1,0},{-1,0}};
    public int maximumMinimumPath(int[][] A) {
        Queue<int[]> q = new ArrayDeque<>();
        
        q.offer(new int[]{0,0,A[0][0]});
        int r = A.length;
        int c = A[0].length;
        
        int dp[][] = new int[r][c];
        dp[0][0] = A[0][0];
        while(q.size()>0){
            int[] ck = q.poll();
            
            for(int d[]:dir){
                
                int nx = d[0]+ck[0];
                int ny = d[1]+ck[1];
                
                if(nx>=0&&ny>=0&&nx<r&&ny<c){
                    int ma = Math.min(ck[2],A[nx][ny]);
                    if(ma>dp[nx][ny]){
                        dp[nx][ny] = ma;
                        q.offer(new int[]{nx,ny,ma});
                    }
                }
                
            }
            
            
        }
        return dp[r-1][c-1];
        
        
        
    }
        public static void main(String[] args) {
        MaximumMinimumPath maximumMinimumPath = new MaximumMinimumPath();
        
        int[][] grid = {
            {5, 4, 5},
            {1, 2, 6},
            {7, 4, 6}
        };
        
        int result = maximumMinimumPath.maximumMinimumPath(grid);
        
        System.out.println(""Maximum minimum value path: "" + result);
    }
}",MaximumMinimumPath,48,"[40, 2, 4, 42, 48, 9, 10, 12, 34]","1: import java.util.*;
2: class MaximumMinimumPath {
3:     
4:     int dir[][] = {{0,-1},{0,1},{1,0},{-1,0}};
5:     public int maximumMinimumPath(int[][] A) {
6:         Queue<int[]> q = new ArrayDeque<>();
7:         
8:         q.offer(new int[]{0,0,A[0][0]});
9:         int r = A.length;
10:         int c = A[0].length;
11:         
12:         int dp[][] = new int[r][c];
13:         dp[0][0] = A[0][0];
14:         while(q.size()>0){
15:             int[] ck = q.poll();
16:             
17:             for(int d[]:dir){
18:                 
19:                 int nx = d[0]+ck[0];
20:                 int ny = d[1]+ck[1];
21:                 
22:                 if(nx>=0&&ny>=0&&nx<r&&ny<c){
23:                     int ma = Math.min(ck[2],A[nx][ny]);
24:                     if(ma>dp[nx][ny]){
25:                         dp[nx][ny] = ma;
26:                         q.offer(new int[]{nx,ny,ma});
27:                     }
28:                 }
29:                 
30:             }
31:             
32:             
33:         }
34:         return dp[r-1][c-1];
35:         
36:         
37:         
38:     }
39:         public static void main(String[] args) {
40:         MaximumMinimumPath maximumMinimumPath = new MaximumMinimumPath();
41:         
42:         int[][] grid = {
43:             {5, 4, 5},
44:             {1, 2, 6},
45:             {7, 4, 6}
46:         };
47:         
48:         int result = maximumMinimumPath.maximumMinimumPath(grid);
49:         
50:         System.out.println(""Maximum minimum value path: "" + result);
51:     }
52: }","[48, 5, 34, 6, 8, 9, 10, 12, 13, 14, 15, 17, 19, 20, 22, 23, 24, 25, 26]","{'output': ['48', '5', '34', '6', '8', '9', '10', '12', '13', '14', '15', '17', '19', '20', '22', '23', '24', '25', '26']}","[48, 40, 5]","{'output': ['48', '40', '5']}","[48, 5, 6, 8, 10, 12, 13, 14, 15, 23, 24, 25, 26, 34]","{'output': ['48', '5', '6', '8', '10', '12', '13', '14', '15', '23', '24', '25', '26', '34']}"
"import java.util.*;

class MaximumProduct {

  public int maximumProduct(int[] nums, int k) {
    PriorityQueue<Integer> queue = new PriorityQueue<>();
    for (int num : nums) {
      queue.offer(num);
    }
    for (int i = 0; i < k; i++) {
      queue.offer(queue.poll() + 1);
    }
    long prod = 1;
    for (int num : queue) {
      prod = prod * num % 1000000007;
    }
    return (int) prod;
  }
  public static void main(String[] args) {
    MaximumProduct mp = new MaximumProduct();
    int[] nums = {1, 2, 3, 4};
    int k = 2;
    int result = mp.maximumProduct(nums, k);
    System.out.println(""The maximum product is: "" + result);
}
}
",MaximumProduct,24,"[23, 6, 13, 14, 15, 17, 24]","1: import java.util.*;
2: 
3: class MaximumProduct {
4: 
5:   public int maximumProduct(int[] nums, int k) {
6:     PriorityQueue<Integer> queue = new PriorityQueue<>();
7:     for (int num : nums) {
8:       queue.offer(num);
9:     }
10:     for (int i = 0; i < k; i++) {
11:       queue.offer(queue.poll() + 1);
12:     }
13:     long prod = 1;
14:     for (int num : queue) {
15:       prod = prod * num % 1000000007;
16:     }
17:     return (int) prod;
18:   }
19:   public static void main(String[] args) {
20:     MaximumProduct mp = new MaximumProduct();
21:     int[] nums = {1, 2, 3, 4};
22:     int k = 2;
23:     int result = mp.maximumProduct(nums, k);
24:     System.out.println(""The maximum product is: "" + result);
25: }
26: }
27: ","[24, 23, 5, 6, 7, 8, 10, 11, 13, 14, 15, 17, 20, 21, 22]","{'output': ['24', '23', '5', '6', '7', '8', '10', '11', '13', '14', '15', '17', '20', '21', '22']}","[24, 23, 21, 22, 20, 5, 6, 7, 8, 10, 11, 13, 14, 15, 17]","{'output': ['24', '23', '21', '22', '20', '5', '6', '7', '8', '10', '11', '13', '14', '15', '17']}","[24, 23, 22, 21, 20, 5, 17, 16, 15, 14, 13, 12, 11, 10, 8, 7]","{'output': ['24', '23', '22', '21', '20', '5', '17', '16', '15', '14', '13', '12', '11', '10', '8', '7']}"
"	import java.util.*;
	
	class MaximumRobots {
		public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {
			int n = chargeTimes.length;
			int p = 0;

			int[] c = new int[n];
			for(int i = 0;i < n;i++)c[i] = -chargeTimes[i];
			SegmentTreeRMQ st = new SegmentTreeRMQ(c);
			long[] cum = new long[n+1];
			for(int i = 0;i < n;i++){
				cum[i+1] = cum[i] + runningCosts[i];
			}
			int ans = 0;
			for(int i = 1;i <= n;i++){
				while(p < i) {
					long v = (cum[i] - cum[p]) * (i - p) - st.min(p, i);
					if(v > budget){
						p++;
					}else{
						break;
					}
				}
				ans = Math.max(ans, i-p);
			}
			return ans;
		}

		public static class SegmentTreeRMQ {
			public final int M, H, N;
			public int[] vals;
			public final int I = Integer.MAX_VALUE;

			public SegmentTreeRMQ(int n)
			{
				N = n;
				M = Integer.highestOneBit(Math.max(N-1, 1))<<2;
				H = M>>>1;
				vals = new int[M];
				Arrays.fill(vals, 0, M, I);
			}

			public SegmentTreeRMQ(int[] a)
			{
				this(a.length);
				for(int i = 0;i < N;i++){
					vals[H+i] = a[i];
				}
				//		Arrays.fill(vals, H+N, M, I);
				for(int i = H-1;i >= 1;i--)propagate(i);
			}

			public void update(int pos, int x)
			{
				vals[H+pos] = x;
				for(int i = (H+pos)>>>1;i >= 1;i >>>= 1)propagate(i);
			}

			private void propagate(int i)
			{
				vals[i] = Math.min(vals[2*i], vals[2*i+1]);
			}

			public int min(int l, int r){
				int min = I;
				if(l >= r)return min;
				l += H; r += H;
				for(;l < r;l>>>=1,r>>>=1){
					if((l&1) == 1)min = Math.min(min, vals[l++]);
					if((r&1) == 1)min = Math.min(min, vals[--r]);
				}
				return min;
			}

			public int firstle(int l, int v) {
				if(l >= H)return -1;
				int cur = H+l;
				while(true){
					if(vals[cur] <= v){
						if(cur >= H)return cur-H;
						cur = 2*cur;
					}else{
						cur++;
						if((cur&cur-1) == 0)return -1;
						if((cur&1)==0)cur>>>=1;
					}
				}
			}

			public int lastle(int l, int v) {
				if(l < 0)return -1;
				int cur = H+l;
				while(true){
					if(vals[cur] <= v){
						if(cur >= H)return cur-H;
						cur = 2*cur + 1;
					}else{
						if((cur&cur-1) == 0)return -1;
						cur--;
						if((cur&1)==1)cur>>>=1;
					}
				}
			}
		}
		  public static void main(String[] args) {
        MaximumRobots maximumRobots = new MaximumRobots();
        
        int[] chargeTimes = {3, 6, 1, 3, 4};
        int[] runningCosts = {2, 1, 3, 4, 5};
        long budget = 25;
        
        int result = maximumRobots.maximumRobots(chargeTimes, runningCosts, budget);
        
        System.out.println(""Maximum number of robots: "" + result);
    }


	}
",MaximumRobots,113,"[107, 3, 109, 110, 113, 5, 6, 8, 9, 10, 11, 12, 13, 15, 16, 17, 18, 19, 25, 24, 20, 27]","1: 	import java.util.*;
2: 	
3: 	class MaximumRobots {
4: 		public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {
5: 			int n = chargeTimes.length;
6: 			int p = 0;
7: 
8: 			int[] c = new int[n];
9: 			for(int i = 0;i < n;i++)c[i] = -chargeTimes[i];
10: 			SegmentTreeRMQ st = new SegmentTreeRMQ(c);
11: 			long[] cum = new long[n+1];
12: 			for(int i = 0;i < n;i++){
13: 				cum[i+1] = cum[i] + runningCosts[i];
14: 			}
15: 			int ans = 0;
16: 			for(int i = 1;i <= n;i++){
17: 				while(p < i) {
18: 					long v = (cum[i] - cum[p]) * (i - p) - st.min(p, i);
19: 					if(v > budget){
20: 						p++;
21: 					}else{
22: 						break;
23: 					}
24: 				}
25: 				ans = Math.max(ans, i-p);
26: 			}
27: 			return ans;
28: 		}
29: 
30: 		public static class SegmentTreeRMQ {
31: 			public final int M, H, N;
32: 			public int[] vals;
33: 			public final int I = Integer.MAX_VALUE;
34: 
35: 			public SegmentTreeRMQ(int n)
36: 			{
37: 				N = n;
38: 				M = Integer.highestOneBit(Math.max(N-1, 1))<<2;
39: 				H = M>>>1;
40: 				vals = new int[M];
41: 				Arrays.fill(vals, 0, M, I);
42: 			}
43: 
44: 			public SegmentTreeRMQ(int[] a)
45: 			{
46: 				this(a.length);
47: 				for(int i = 0;i < N;i++){
48: 					vals[H+i] = a[i];
49: 				}
50: 				//		Arrays.fill(vals, H+N, M, I);
51: 				for(int i = H-1;i >= 1;i--)propagate(i);
52: 			}
53: 
54: 			public void update(int pos, int x)
55: 			{
56: 				vals[H+pos] = x;
57: 				for(int i = (H+pos)>>>1;i >= 1;i >>>= 1)propagate(i);
58: 			}
59: 
60: 			private void propagate(int i)
61: 			{
62: 				vals[i] = Math.min(vals[2*i], vals[2*i+1]);
63: 			}
64: 
65: 			public int min(int l, int r){
66: 				int min = I;
67: 				if(l >= r)return min;
68: 				l += H; r += H;
69: 				for(;l < r;l>>>=1,r>>>=1){
70: 					if((l&1) == 1)min = Math.min(min, vals[l++]);
71: 					if((r&1) == 1)min = Math.min(min, vals[--r]);
72: 				}
73: 				return min;
74: 			}
75: 
76: 			public int firstle(int l, int v) {
77: 				if(l >= H)return -1;
78: 				int cur = H+l;
79: 				while(true){
80: 					if(vals[cur] <= v){
81: 						if(cur >= H)return cur-H;
82: 						cur = 2*cur;
83: 					}else{
84: 						cur++;
85: 						if((cur&cur-1) == 0)return -1;
86: 						if((cur&1)==0)cur>>>=1;
87: 					}
88: 				}
89: 			}
90: 
91: 			public int lastle(int l, int v) {
92: 				if(l < 0)return -1;
93: 				int cur = H+l;
94: 				while(true){
95: 					if(vals[cur] <= v){
96: 						if(cur >= H)return cur-H;
97: 						cur = 2*cur + 1;
98: 					}else{
99: 						if((cur&cur-1) == 0)return -1;
100: 						cur--;
101: 						if((cur&1)==1)cur>>>=1;
102: 					}
103: 				}
104: 			}
105: 		}
106: 		  public static void main(String[] args) {
107:         MaximumRobots maximumRobots = new MaximumRobots();
108:         
109:         int[] chargeTimes = {3, 6, 1, 3, 4};
110:         int[] runningCosts = {2, 1, 3, 4, 5};
111:         long budget = 25;
112:         
113:         int result = maximumRobots.maximumRobots(chargeTimes, runningCosts, budget);
114:         
115:         System.out.println(""Maximum number of robots: "" + result);
116:     }
117: 
118: 
119: 	}
120: ","[113, 4, 5, 9, 10, 11, 12, 13, 15, 16, 17, 18, 19, 22, 25, 27, 107, 109, 110, 111]","{'output': ['113', '4', '5', '9', '10', '11', '12', '13', '15', '16', '17', '18', '19', '22', '25', '27', '107', '109', '110', '111']}","[113, 112, 111, 110, 109, 108, 106, 27, 26, 25, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4]","{'output': ['113', '112', '111', '110', '109', '108', '106', '27', '26', '25', '18', '17', '16', '15', '14', '13', '12', '11', '10', '9', '8', '7', '6', '5', '4']}","[113, 4, 5, 8, 9, 10, 11, 12, 13, 15, 16, 17, 18, 19, 20, 21, 22, 24, 25, 27]","{'output': ['113', '4', '5', '8', '9', '10', '11', '12', '13', '15', '16', '17', '18', '19', '20', '21', '22', '24', '25', '27']}"
"class MaximumScore {
    public int maximumScore(int[] nums, int[] muls) {
        int n = nums.length;
        int m = muls.length;
        int[][] dp = new int[m+1][m+1];
        for (int z = m-1; z>=0; --z) {
            for (int i = 0; i <= z; ++i) {
                int y = z-i;
                int j = n-y-1;
                dp[i][y] = Math.max(dp[i+1][y]+nums[i]*muls[z], dp[i][y+1]+nums[j]*muls[z]);
                //System.out.println(i+"" ""+y+"" ""+j+"" ""+dp[i][y]);
            }
        }
        return dp[0][0];
    }
    public static void main(String[] args) {
        MaximumScore maximumScore = new MaximumScore();
        
        int[] nums = {1, 2, 3};
        int[] muls = {3, 2, 1};
        
        int result = maximumScore.maximumScore(nums, muls);
        
        System.out.println(""Maximum score: "" + result);
    }
}",MaximumScore,22,"[17, 1, 19, 20, 22, 4, 5, 14]","1: class MaximumScore {
2:     public int maximumScore(int[] nums, int[] muls) {
3:         int n = nums.length;
4:         int m = muls.length;
5:         int[][] dp = new int[m+1][m+1];
6:         for (int z = m-1; z>=0; --z) {
7:             for (int i = 0; i <= z; ++i) {
8:                 int y = z-i;
9:                 int j = n-y-1;
10:                 dp[i][y] = Math.max(dp[i+1][y]+nums[i]*muls[z], dp[i][y+1]+nums[j]*muls[z]);
11:                 //System.out.println(i+"" ""+y+"" ""+j+"" ""+dp[i][y]);
12:             }
13:         }
14:         return dp[0][0];
15:     }
16:     public static void main(String[] args) {
17:         MaximumScore maximumScore = new MaximumScore();
18:         
19:         int[] nums = {1, 2, 3};
20:         int[] muls = {3, 2, 1};
21:         
22:         int result = maximumScore.maximumScore(nums, muls);
23:         
24:         System.out.println(""Maximum score: "" + result);
25:     }
26: }","[22, 17, 2, 14]","{'output': ['22', '17', '2', '14']}","[22, 17, 2, 3, 4, 5, 6, 7, 8, 9, 10, 14]","{'output': ['22', '17', '2', '3', '4', '5', '6', '7', '8', '9', '10', '14']}","[22, 17, 2, 3, 4, 5, 6, 7, 8, 9, 10, 14]","{'output': ['22', '17', '2', '3', '4', '5', '6', '7', '8', '9', '10', '14']}"
"	class MaximumSwap {
	    public int maximumSwap(int num) {
	        char[] s = Integer.toString(num).toCharArray();
	        int n = s.length;
	        int max = -1;
	        for(int i = 0;i < n;i++){
	        	for(int j = i;j < n;j++){
	        		{char d = s[i]; s[i] = s[j]; s[j] = d;}
	        		max = Math.max(max, Integer.parseInt(new String(s)));
	        		{char d = s[i]; s[i] = s[j]; s[j] = d;}
	        	}
	        }
	        return max;
	    }
		  public static void main(String[] args) {
        MaximumSwap maximumSwap = new MaximumSwap();
        
        int num = 2736;
        
        int result = maximumSwap.maximumSwap(num);
        
        System.out.println(""Maximum number after swap: "" + result);
    }

	}	
",MaximumSwap,20,"[16, 1, 20, 3, 4, 5, 6, 7, 8, 9, 10, 13]","1: 	class MaximumSwap {
2: 	    public int maximumSwap(int num) {
3: 	        char[] s = Integer.toString(num).toCharArray();
4: 	        int n = s.length;
5: 	        int max = -1;
6: 	        for(int i = 0;i < n;i++){
7: 	        	for(int j = i;j < n;j++){
8: 	        		{char d = s[i]; s[i] = s[j]; s[j] = d;}
9: 	        		max = Math.max(max, Integer.parseInt(new String(s)));
10: 	        		{char d = s[i]; s[i] = s[j]; s[j] = d;}
11: 	        	}
12: 	        }
13: 	        return max;
14: 	    }
15: 		  public static void main(String[] args) {
16:         MaximumSwap maximumSwap = new MaximumSwap();
17:         
18:         int num = 2736;
19:         
20:         int result = maximumSwap.maximumSwap(num);
21:         
22:         System.out.println(""Maximum number after swap: "" + result);
23:     }
24: 
25: 	}	
26: ","[20, 18, 16, 2, 3, 4, 5, 6, 7, 8, 9, 10, 13]","{'output': ['20', '18', '16', '2', '3', '4', '5', '6', '7', '8', '9', '10', '13']}","[20, 18, 16, 2]","{'output': ['20', '18', '16', '2']}","[20, 18, 16]","{'output': ['20', '18', '16']}"
"class MaximumXOR {

	public int maximumXOR(int[] nums) {
		int max = 0;
		for (int num : nums) {
			max |= num;
		}
		return max;
	}
	 public static void main(String[] args) {
        MaximumXOR maximumXOR = new MaximumXOR();
        
        int[] nums = {3, 10, 5, 25, 2, 8};
        
        int result = maximumXOR.maximumXOR(nums);
        
        System.out.println(""Maximum XOR: "" + result);
    }
}",MaximumXOR,15,"[11, 1, 13, 15, 4, 5, 6, 8]","1: class MaximumXOR {
2: 
3: 	public int maximumXOR(int[] nums) {
4: 		int max = 0;
5: 		for (int num : nums) {
6: 			max |= num;
7: 		}
8: 		return max;
9: 	}
10: 	 public static void main(String[] args) {
11:         MaximumXOR maximumXOR = new MaximumXOR();
12:         
13:         int[] nums = {3, 10, 5, 25, 2, 8};
14:         
15:         int result = maximumXOR.maximumXOR(nums);
16:         
17:         System.out.println(""Maximum XOR: "" + result);
18:     }
19: }","[15, 13, 11, 3, 4, 5, 6, 8]","{'output': ['15', '13', '11', '3', '4', '5', '6', '8']}","[15, 13, 11, 3, 4, 5, 6, 8]","{'output': ['15', '13', '11', '3', '4', '5', '6', '8']}","[15, 13, 11, 3, 4, 5, 6, 8]","{'output': ['15', '13', '11', '3', '4', '5', '6', '8']}"
"import java.util.*;

	class MinAbsDifference {
		public int minAbsDifference(int[] a, int goal) {
			int n = a.length;
			int h = n/2;
			int[] L = new int[1<<h];
			for(int i = 1;i < 1<<h;i++){
				L[i] += L[i&i-1] + a[Integer.numberOfTrailingZeros(i)];
			}
			Arrays.sort(L);
			int[] R = new int[1<<n-h];
			for(int i = 1;i < 1<<n-h;i++){
				R[i] += R[i&i-1] + a[h+Integer.numberOfTrailingZeros(i)];
			}
			int ans = Integer.MAX_VALUE;
			for(int v : R){
				int ind = Arrays.binarySearch(L, goal-v);
				if(ind >= 0)return 0;
				if(-ind-1 < L.length)ans = Math.min(ans, Math.abs(L[-ind-1] + v - goal));
				if(-ind-2 >= 0)ans = Math.min(ans, Math.abs(L[-ind-2] + v - goal));
			}
			return ans;
		}
		   public static void main(String[] args) {
        MinAbsDifference minAbsDifference = new MinAbsDifference();
        
        int[] a = {5, -7, 3, 5};
        int goal = 6;
        
        int result = minAbsDifference.minAbsDifference(a, goal);
        
        System.out.println(""Minimum absolute difference: "" + result);
    }

	}
",MinAbsDifference,31,"[26, 3, 28, 31, 19]","1: import java.util.*;
2: 
3: 	class MinAbsDifference {
4: 		public int minAbsDifference(int[] a, int goal) {
5: 			int n = a.length;
6: 			int h = n/2;
7: 			int[] L = new int[1<<h];
8: 			for(int i = 1;i < 1<<h;i++){
9: 				L[i] += L[i&i-1] + a[Integer.numberOfTrailingZeros(i)];
10: 			}
11: 			Arrays.sort(L);
12: 			int[] R = new int[1<<n-h];
13: 			for(int i = 1;i < 1<<n-h;i++){
14: 				R[i] += R[i&i-1] + a[h+Integer.numberOfTrailingZeros(i)];
15: 			}
16: 			int ans = Integer.MAX_VALUE;
17: 			for(int v : R){
18: 				int ind = Arrays.binarySearch(L, goal-v);
19: 				if(ind >= 0)return 0;
20: 				if(-ind-1 < L.length)ans = Math.min(ans, Math.abs(L[-ind-1] + v - goal));
21: 				if(-ind-2 >= 0)ans = Math.min(ans, Math.abs(L[-ind-2] + v - goal));
22: 			}
23: 			return ans;
24: 		}
25: 		   public static void main(String[] args) {
26:         MinAbsDifference minAbsDifference = new MinAbsDifference();
27:         
28:         int[] a = {5, -7, 3, 5};
29:         int goal = 6;
30:         
31:         int result = minAbsDifference.minAbsDifference(a, goal);
32:         
33:         System.out.println(""Minimum absolute difference: "" + result);
34:     }
35: 
36: 	}
37: ","[31, 4, 5, 6, 7, 8, 9, 11, 12, 13, 14, 16, 17, 18, 19, 20, 21, 23, 28, 29]","{'output': ['31', '4', '5', '6', '7', '8', '9', '11', '12', '13', '14', '16', '17', '18', '19', '20', '21', '23', '28', '29']}","[31, 4, 5, 6, 7, 8, 9, 11, 12, 13, 14, 16, 17, 18, 19, 20, 21, 23]","{'output': ['31', '4', '5', '6', '7', '8', '9', '11', '12', '13', '14', '16', '17', '18', '19', '20', '21', '23']}","[31, 4, 5, 6, 7, 8, 9, 11, 12, 13, 14, 16, 17, 18, 19, 20, 21, 23]","{'output': ['31', '4', '5', '6', '7', '8', '9', '11', '12', '13', '14', '16', '17', '18', '19', '20', '21', '23']}"
"class MinEatingSpeed {
    public int minEatingSpeed(int[] piles, int H) {
        int min = 1;
        int max = 1000000000;
        while (min != max) {
            int m = (min+max)/2;
            int time = 0;
            for (int pile : piles) {
                time += pile/m;
                if (pile%m!=0)
                    time++;
            }
            if (time > H)
                min = m+1;
            else
                max = m;
        }
        return min;
    }
     public static void main(String[] args) {
        MinEatingSpeed minEatingSpeed = new MinEatingSpeed();
        
        int[] piles = {3, 6, 7, 11};
        int H = 8;
        
        int result = minEatingSpeed.minEatingSpeed(piles, H);
        
        System.out.println(""Minimum eating speed: "" + result);
    }
}",MinEatingSpeed,26,"[21, 1, 23, 26, 3, 4, 5, 6, 7, 8, 9, 11, 13, 16, 14, 18]","1: class MinEatingSpeed {
2:     public int minEatingSpeed(int[] piles, int H) {
3:         int min = 1;
4:         int max = 1000000000;
5:         while (min != max) {
6:             int m = (min+max)/2;
7:             int time = 0;
8:             for (int pile : piles) {
9:                 time += pile/m;
10:                 if (pile%m!=0)
11:                     time++;
12:             }
13:             if (time > H)
14:                 min = m+1;
15:             else
16:                 max = m;
17:         }
18:         return min;
19:     }
20:      public static void main(String[] args) {
21:         MinEatingSpeed minEatingSpeed = new MinEatingSpeed();
22:         
23:         int[] piles = {3, 6, 7, 11};
24:         int H = 8;
25:         
26:         int result = minEatingSpeed.minEatingSpeed(piles, H);
27:         
28:         System.out.println(""Minimum eating speed: "" + result);
29:     }
30: }","[26, 21, 2]","{'output': ['26', '21', '2']}","[26, 24, 23, 21]","{'output': ['26', '24', '23', '21']}","[26, 25, 24, 23, 21, 2, 18]","{'output': ['26', '25', '24', '23', '21', '2', '18']}"
"	class MinFlips {
	    public int minFlips(int[][] mat) {
	        int u = 0;
	        int n = mat.length, m = mat[0].length;
	        for(int i = 0;i < mat.length;i++){
	        	for(int j = 0;j < mat[0].length;j++){
	        		u |= mat[i][j]<<i*mat[0].length+j;
	        	}
	        }
	        int[] ptns = new int[n*m];
	        for(int i = 0;i < n;i++){
	        	for(int j = 0;j < m;j++){
	        		for(int k = 0;k < n;k++){
	        			for(int l = 0;l < m;l++){
	        				if(Math.abs(i-k) + Math.abs(j-l) <= 1){
	        					ptns[i*m+j] |= 1<<k*m+l;
	        				}
	        			}
	        		}
	        	}
	        }
	        
	        int ans = 99;
	        for(int i = 0;i < 1<<n*m;i++){
	        	int v = u;
	        	for(int j = 0;j < n*m;j++){
	        		if(i<<~j<0){
	        			v ^= ptns[j];
	        		}
	        	}
	        	if(v == 0){
	        		ans = Math.min(ans, Integer.bitCount(i));
	        	}
	        }
	        if(ans == 99)return -1;
	        return ans;
	    }
	public static void main(String[] args) {
        MinFlips minFlips = new MinFlips();
        
        int[][] mat = {
            {0, 0},
            {0, 1}
        };
        
        int result = minFlips.minFlips(mat);
        
        System.out.println(""Minimum number of flips: "" + result);
    }
	}	
",MinFlips,46,"[39, 1, 41, 46, 3, 4, 5, 6, 7, 10, 11, 12, 13, 14, 15, 16, 23, 24, 25, 26, 28, 31, 32, 35, 36]","1: 	class MinFlips {
2: 	    public int minFlips(int[][] mat) {
3: 	        int u = 0;
4: 	        int n = mat.length, m = mat[0].length;
5: 	        for(int i = 0;i < mat.length;i++){
6: 	        	for(int j = 0;j < mat[0].length;j++){
7: 	        		u |= mat[i][j]<<i*mat[0].length+j;
8: 	        	}
9: 	        }
10: 	        int[] ptns = new int[n*m];
11: 	        for(int i = 0;i < n;i++){
12: 	        	for(int j = 0;j < m;j++){
13: 	        		for(int k = 0;k < n;k++){
14: 	        			for(int l = 0;l < m;l++){
15: 	        				if(Math.abs(i-k) + Math.abs(j-l) <= 1){
16: 	        					ptns[i*m+j] |= 1<<k*m+l;
17: 	        				}
18: 	        			}
19: 	        		}
20: 	        	}
21: 	        }
22: 	        
23: 	        int ans = 99;
24: 	        for(int i = 0;i < 1<<n*m;i++){
25: 	        	int v = u;
26: 	        	for(int j = 0;j < n*m;j++){
27: 	        		if(i<<~j<0){
28: 	        			v ^= ptns[j];
29: 	        		}
30: 	        	}
31: 	        	if(v == 0){
32: 	        		ans = Math.min(ans, Integer.bitCount(i));
33: 	        	}
34: 	        }
35: 	        if(ans == 99)return -1;
36: 	        return ans;
37: 	    }
38: 	public static void main(String[] args) {
39:         MinFlips minFlips = new MinFlips();
40:         
41:         int[][] mat = {
42:             {0, 0},
43:             {0, 1}
44:         };
45:         
46:         int result = minFlips.minFlips(mat);
47:         
48:         System.out.println(""Minimum number of flips: "" + result);
49:     }
50: 	}	
51: ","[46, 39, 2, 35, 36, 23, 24, 25, 26, 27, 28, 30, 31, 32]","{'output': ['46', '39', '2', '35', '36', '23', '24', '25', '26', '27', '28', '30', '31', '32']}","[46, 2, 4, 5, 6, 7, 10, 11, 12, 13, 14, 15, 16, 23, 24, 25, 26, 27, 28, 31, 32, 35, 36]","{'output': ['46', '2', '4', '5', '6', '7', '10', '11', '12', '13', '14', '15', '16', '23', '24', '25', '26', '27', '28', '31', '32', '35', '36']}","[46, 39, 2, 36, 35, 33, 32, 31, 29, 28, 27, 26, 25, 24, 23, 10, 6, 7, 5, 4]","{'output': ['46', '39', '2', '36', '35', '33', '32', '31', '29', '28', '27', '26', '25', '24', '23', '10', '6', '7', '5', '4']}"
"import java.util.*;
class MinJumps {
	
	// has tried same value	
	private Set<Integer> set = new HashSet<>();
	private Map<Integer , List<Integer>> map = new HashMap<>();
	private int[] dist;
	
    public int minJumps(int[] arr) {
    	int i , j , n = arr.length;
    	for (i = 0;i < n;i ++) {
    		map.putIfAbsent(arr[i] , new ArrayList<>());
    		map.get(arr[i]).add(i);    		
    	}
    	dist = new int[n];
    	Arrays.fill(dist , - 1);
    	dist[0] = 0;
    	Queue<Integer> queue = new LinkedList<>();
    	queue.add(0);
    	while (!queue.isEmpty()) {
    		int current = queue.poll();
    		if (current == n - 1) {
    			return dist[current];    			
    		}
    		// + 1
    		if (current + 1 < n && dist[current + 1] < 0) {
    			dist[current + 1] = dist[current] + 1;
    			queue.add(current + 1);
    		}
    		// - 1
    		if (current - 1 >= 0 && dist[current - 1] < 0) {
    			dist[current - 1] = dist[current] + 1;
    			queue.add(current - 1);
    		}
    		// same    		
    		if (!set.contains(arr[current])) {
    			set.add(arr[current]);
    			for (int index : map.get(arr[current])) {
    				if (dist[index] < 0) {
    					dist[index] = dist[current] + 1;
    					queue.add(index);    					
    				}
    			}
    		}
    	}
    	return - 1;
    }
	  public static void main(String[] args) {
        MinJumps minJumps = new MinJumps();
        
        int[] arr = {100,-23,100,100,3,2,1,100};
        
        int result = minJumps.minJumps(arr);
        
        System.out.println(""Minimum jumps needed: "" + result);
    }
}",MinJumps,53,"[49, 2, 5, 6, 51, 53, 10, 11, 12, 15, 18, 19, 20, 21, 22, 26, 28, 36, 38, 39, 41, 23]","1: import java.util.*;
2: class MinJumps {
3: 	
4: 	// has tried same value	
5: 	private Set<Integer> set = new HashSet<>();
6: 	private Map<Integer , List<Integer>> map = new HashMap<>();
7: 	private int[] dist;
8: 	
9:     public int minJumps(int[] arr) {
10:     	int i , j , n = arr.length;
11:     	for (i = 0;i < n;i ++) {
12:     		map.putIfAbsent(arr[i] , new ArrayList<>());
13:     		map.get(arr[i]).add(i);    		
14:     	}
15:     	dist = new int[n];
16:     	Arrays.fill(dist , - 1);
17:     	dist[0] = 0;
18:     	Queue<Integer> queue = new LinkedList<>();
19:     	queue.add(0);
20:     	while (!queue.isEmpty()) {
21:     		int current = queue.poll();
22:     		if (current == n - 1) {
23:     			return dist[current];    			
24:     		}
25:     		// + 1
26:     		if (current + 1 < n && dist[current + 1] < 0) {
27:     			dist[current + 1] = dist[current] + 1;
28:     			queue.add(current + 1);
29:     		}
30:     		// - 1
31:     		if (current - 1 >= 0 && dist[current - 1] < 0) {
32:     			dist[current - 1] = dist[current] + 1;
33:     			queue.add(current - 1);
34:     		}
35:     		// same    		
36:     		if (!set.contains(arr[current])) {
37:     			set.add(arr[current]);
38:     			for (int index : map.get(arr[current])) {
39:     				if (dist[index] < 0) {
40:     					dist[index] = dist[current] + 1;
41:     					queue.add(index);    					
42:     				}
43:     			}
44:     		}
45:     	}
46:     	return - 1;
47:     }
48: 	  public static void main(String[] args) {
49:         MinJumps minJumps = new MinJumps();
50:         
51:         int[] arr = {100,-23,100,100,3,2,1,100};
52:         
53:         int result = minJumps.minJumps(arr);
54:         
55:         System.out.println(""Minimum jumps needed: "" + result);
56:     }
57: }","[53, 49, 9, 10, 11, 12, 13, 15, 16, 17, 18, 19, 20, 21, 22, 23]","{'output': ['53', '49', '9', '10', '11', '12', '13', '15', '16', '17', '18', '19', '20', '21', '22', '23']}","[53, 49, 9, 11, 12, 13, 15, 16, 17, 18, 19, 20, 21, 22, 23, 25, 26, 27, 28, 30, 31, 32, 33, 35, 36, 37, 38, 39, 40, 41]","{'output': ['53', '49', '9', '11', '12', '13', '15', '16', '17', '18', '19', '20', '21', '22', '23', '25', '26', '27', '28', '30', '31', '32', '33', '35', '36', '37', '38', '39', '40', '41']}","[53, 51, 50, 49, 9, 10, 11, 12, 13, 15, 16, 17, 18, 19, 20, 21, 22, 23, 25, 26, 27, 28, 30, 31, 32, 33, 35, 36, 37, 38, 39, 40, 41, 45, 46]","{'output': ['53', '51', '50', '49', '9', '10', '11', '12', '13', '15', '16', '17', '18', '19', '20', '21', '22', '23', '25', '26', '27', '28', '30', '31', '32', '33', '35', '36', '37', '38', '39', '40', '41', '45', '46']}"
"class MinMovesToMakePalindrome {

	public int minMovesToMakePalindrome(String s) {
		for (int i = 0; i < s.length() - 1; i++) {
			if (s.charAt(i) == s.charAt(s.length() - 1)) {
				return i + minMovesToMakePalindrome(s.substring(0, i) + s.substring(i + 1, s.length() - 1));
			} else if (s.charAt(s.length() - 1 - i) == s.charAt(0)) {
				return i + minMovesToMakePalindrome(s.substring(1, s.length() - 1 - i) + s.substring(s.length() - i));
			}
		}
		return 0;
	}
	   public static void main(String[] args) {
        MinMovesToMakePalindrome minMovesToMakePalindrome = new MinMovesToMakePalindrome();
        
        String s = ""aabb"";
        
        int result = minMovesToMakePalindrome.minMovesToMakePalindrome(s);
        
        System.out.println(""Minimum moves to make palindrome: "" + result);
    }

}",MinMovesToMakePalindrome,18,"[14, 1, 18, 4, 5, 7, 6, 11]","1: class MinMovesToMakePalindrome {
2: 
3: 	public int minMovesToMakePalindrome(String s) {
4: 		for (int i = 0; i < s.length() - 1; i++) {
5: 			if (s.charAt(i) == s.charAt(s.length() - 1)) {
6: 				return i + minMovesToMakePalindrome(s.substring(0, i) + s.substring(i + 1, s.length() - 1));
7: 			} else if (s.charAt(s.length() - 1 - i) == s.charAt(0)) {
8: 				return i + minMovesToMakePalindrome(s.substring(1, s.length() - 1 - i) + s.substring(s.length() - i));
9: 			}
10: 		}
11: 		return 0;
12: 	}
13: 	   public static void main(String[] args) {
14:         MinMovesToMakePalindrome minMovesToMakePalindrome = new MinMovesToMakePalindrome();
15:         
16:         String s = ""aabb"";
17:         
18:         int result = minMovesToMakePalindrome.minMovesToMakePalindrome(s);
19:         
20:         System.out.println(""Minimum moves to make palindrome: "" + result);
21:     }
22: 
23: }","[18, 16, 14, 3]","{'output': ['18', '16', '14', '3']}","[18, 16, 14, 3]","{'output': ['18', '16', '14', '3']}","[18, 16, 14, 3]","{'output': ['18', '16', '14', '3']}"
"	class MinNonZeroProduct {
		public int minNonZeroProduct(int p) {
			// 0001111
			// 0110011
			// 1010101

			// 0001111
			// 0001111
			// 1110001

			final int mod = 1000000007;
			if(p == 1){
				return 1;
			}else if(p == 2){
				return 6;
			}
			return (int)(pow((1L<<p)-2, (1L<<p-1)-1, mod) * (((1L<<p)-1)%mod) % mod);
		}

		public long pow(long a, long n, long mod) {
					a %= mod;
			long ret = 1;
			int x = 63 - Long.numberOfLeadingZeros(n);
			for (; x >= 0; x--) {
				ret = ret * ret % mod;
				if (n << 63 - x < 0) ret = ret * a % mod;
			}
			return ret;
		}
		    public static void main(String[] args) {
        MinNonZeroProduct minNonZeroProduct = new MinNonZeroProduct();
        
        int p = 3;
        
        int result = minNonZeroProduct.minNonZeroProduct(p);
        
        System.out.println(""Minimum non-zero product for p="" + p + "": "" + result);
    }

	}
",MinNonZeroProduct,35,"[31, 1, 35, 12, 14, 17, 21, 22, 23, 24, 25, 26, 28]","1: 	class MinNonZeroProduct {
2: 		public int minNonZeroProduct(int p) {
3: 			// 0001111
4: 			// 0110011
5: 			// 1010101
6: 
7: 			// 0001111
8: 			// 0001111
9: 			// 1110001
10: 
11: 			final int mod = 1000000007;
12: 			if(p == 1){
13: 				return 1;
14: 			}else if(p == 2){
15: 				return 6;
16: 			}
17: 			return (int)(pow((1L<<p)-2, (1L<<p-1)-1, mod) * (((1L<<p)-1)%mod) % mod);
18: 		}
19: 
20: 		public long pow(long a, long n, long mod) {
21: 					a %= mod;
22: 			long ret = 1;
23: 			int x = 63 - Long.numberOfLeadingZeros(n);
24: 			for (; x >= 0; x--) {
25: 				ret = ret * ret % mod;
26: 				if (n << 63 - x < 0) ret = ret * a % mod;
27: 			}
28: 			return ret;
29: 		}
30: 		    public static void main(String[] args) {
31:         MinNonZeroProduct minNonZeroProduct = new MinNonZeroProduct();
32:         
33:         int p = 3;
34:         
35:         int result = minNonZeroProduct.minNonZeroProduct(p);
36:         
37:         System.out.println(""Minimum non-zero product for p="" + p + "": "" + result);
38:     }
39: 
40: 	}
41: ","[35, 34, 32, 31, 2, 11, 12, 14, 17, 20, 21, 22, 23, 24, 25, 26, 28]","{'output': ['35', '34', '32', '31', '2', '11', '12', '14', '17', '20', '21', '22', '23', '24', '25', '26', '28']}","[35, 34, 32, 31, 2, 17]","{'output': ['35', '34', '32', '31', '2', '17']}","[35, 33, 31, 2, 17, 20, 21, 22, 23, 24, 25, 26, 28, 11]","{'output': ['35', '33', '31', '2', '17', '20', '21', '22', '23', '24', '25', '26', '28', '11']}"
"class MinNumberOperations {
    public int minNumberOperations(int[] target) {
        int free = 0;
        int req = 0;
        for (int i = 0; i < target.length; i++) {
            if (target[i] > free) {
                req += target[i] - free;
                free = target[i];
            } else if (target[i] < free) {
                free = target[i];
            }
        }
        return req;
    }
        public static void main(String[] args) {
        MinNumberOperations minNumberOperations = new MinNumberOperations();
        
        int[] target = {3, 1, 5, 4, 2};
        
        int result = minNumberOperations.minNumberOperations(target);
        
        System.out.println(""Minimum number of operations: "" + result);
    }
}",MinNumberOperations,20,"[16, 1, 18, 20, 3, 4, 5, 6, 7, 8, 9, 10, 13]","1: class MinNumberOperations {
2:     public int minNumberOperations(int[] target) {
3:         int free = 0;
4:         int req = 0;
5:         for (int i = 0; i < target.length; i++) {
6:             if (target[i] > free) {
7:                 req += target[i] - free;
8:                 free = target[i];
9:             } else if (target[i] < free) {
10:                 free = target[i];
11:             }
12:         }
13:         return req;
14:     }
15:         public static void main(String[] args) {
16:         MinNumberOperations minNumberOperations = new MinNumberOperations();
17:         
18:         int[] target = {3, 1, 5, 4, 2};
19:         
20:         int result = minNumberOperations.minNumberOperations(target);
21:         
22:         System.out.println(""Minimum number of operations: "" + result);
23:     }
24: }","[20, 2, 5, 6, 7, 8, 10, 13, 18]","{'output': ['20', '2', '5', '6', '7', '8', '10', '13', '18']}","[20, 18, 16, 2, 5, 6, 7, 8, 9, 10, 13]","{'output': ['20', '18', '16', '2', '5', '6', '7', '8', '9', '10', '13']}","[20, 2, 5, 6, 7, 8, 13, 18]","{'output': ['20', '2', '5', '6', '7', '8', '13', '18']}"
"import java.util.*;
class MinRemoveToMakeValid {
    public String minRemoveToMakeValid(String s) {
        final int N = s.length();
        Stack<Integer> open = new Stack<>();
        char[] A = s.toCharArray();
        for (int i = 0; i < N; ++i) {
            if (A[i] == '(') {
                open.push(i);
            } else if (A[i] == ')') {
                if (open.isEmpty()) {
                    A[i] = '#';
                } else {
                    open.pop();
                }
            }
        }
        while (!open.isEmpty()) {
            int idx = open.pop();
            A[idx] = '#';
        }
        StringBuilder sb = new StringBuilder();
        for (char c : A) {
            if (c != '#') {
                sb.append(c);
            }
        }
        return sb.toString();
    }
       public static void main(String[] args) {
        MinRemoveToMakeValid minRemoveToMakeValid = new MinRemoveToMakeValid();
        
        String s = ""lee(t(c)o)de)"";
        
        String result = minRemoveToMakeValid.minRemoveToMakeValid(s);
        
        System.out.println(""String after removing invalid parentheses: "" + result);
    }
}",MinRemoveToMakeValid,35,"[31, 2, 35, 4, 5, 6, 7, 8, 9, 10, 11, 14, 12, 22, 23, 24, 25, 28]","1: import java.util.*;
2: class MinRemoveToMakeValid {
3:     public String minRemoveToMakeValid(String s) {
4:         final int N = s.length();
5:         Stack<Integer> open = new Stack<>();
6:         char[] A = s.toCharArray();
7:         for (int i = 0; i < N; ++i) {
8:             if (A[i] == '(') {
9:                 open.push(i);
10:             } else if (A[i] == ')') {
11:                 if (open.isEmpty()) {
12:                     A[i] = '#';
13:                 } else {
14:                     open.pop();
15:                 }
16:             }
17:         }
18:         while (!open.isEmpty()) {
19:             int idx = open.pop();
20:             A[idx] = '#';
21:         }
22:         StringBuilder sb = new StringBuilder();
23:         for (char c : A) {
24:             if (c != '#') {
25:                 sb.append(c);
26:             }
27:         }
28:         return sb.toString();
29:     }
30:        public static void main(String[] args) {
31:         MinRemoveToMakeValid minRemoveToMakeValid = new MinRemoveToMakeValid();
32:         
33:         String s = ""lee(t(c)o)de)"";
34:         
35:         String result = minRemoveToMakeValid.minRemoveToMakeValid(s);
36:         
37:         System.out.println(""String after removing invalid parentheses: "" + result);
38:     }
39: }","[35, 33, 32, 31]","{'output': ['35', '33', '32', '31']}","[35, 33, 31, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29]","{'output': ['35', '33', '31', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29']}","[35, 33, 31, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 14, 18, 19, 20, 22, 23, 24, 25, 28]","{'output': ['35', '33', '31', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '14', '18', '19', '20', '22', '23', '24', '25', '28']}"
"	class MinimizeXor {
		public int minimizeXor(int num1, int num2) {
			int o = num1;
			int s = Integer.bitCount(num2);
			for(int d = 29;d >= 0 && s > 0;d--){
				if(num1<<~d<0){
					num1 ^= 1<<d;
					s--;
				}
			}
			for(int d = 0;d < 30 && s > 0;d++){
				if(o<<~d>=0){
					num1 ^= 1<<d;
					s--;
				}
			}
			return num1 ^ o;
		}
		  public static void main(String[] args) {
        MinimizeXor minimizeXor = new MinimizeXor();
        
        int num1 = 3;
        int num2 = 5;
        
        int result = minimizeXor.minimizeXor(num1, num2);
        
        System.out.println(""Minimum XOR value: "" + result);
    }
	}
",MinimizeXor,25,"[20, 1, 25, 3, 5, 7, 17]","1: 	class MinimizeXor {
2: 		public int minimizeXor(int num1, int num2) {
3: 			int o = num1;
4: 			int s = Integer.bitCount(num2);
5: 			for(int d = 29;d >= 0 && s > 0;d--){
6: 				if(num1<<~d<0){
7: 					num1 ^= 1<<d;
8: 					s--;
9: 				}
10: 			}
11: 			for(int d = 0;d < 30 && s > 0;d++){
12: 				if(o<<~d>=0){
13: 					num1 ^= 1<<d;
14: 					s--;
15: 				}
16: 			}
17: 			return num1 ^ o;
18: 		}
19: 		  public static void main(String[] args) {
20:         MinimizeXor minimizeXor = new MinimizeXor();
21:         
22:         int num1 = 3;
23:         int num2 = 5;
24:         
25:         int result = minimizeXor.minimizeXor(num1, num2);
26:         
27:         System.out.println(""Minimum XOR value: "" + result);
28:     }
29: 	}
30: ","[25, 22, 23, 20, 2]","{'output': ['25', '22', '23', '20', '2']}","[25, 22, 23, 2, 17]","{'output': ['25', '22', '23', '2', '17']}","[25, 22, 23, 20, 2]","{'output': ['25', '22', '23', '20', '2']}"
"class MinimumMoney {
    public long minimumMoney(int[][] ts) {
        int n = ts.length;
        long costtot = 0;
        for (int[] t : ts) {
            if (t[0]>t[1])
                costtot += t[0]-t[1];
        }
        long ans = costtot;
        for (int[] t : ts) {
            if (t[0]>t[1])
                ans = Math.max(ans, costtot+t[1]);
            else
                ans = Math.max(ans, costtot+t[0]);
        }
        return ans;
    }
    public static void main(String[] args) {
        MinimumMoney minimumMoney = new MinimumMoney();
        
        int[][] transactions = {
            {10, 20},
            {20, 30},
            {30, 40},
            {40, 50}
        };
        
        long result = minimumMoney.minimumMoney(transactions);
        
        System.out.println(""Minimum money required: "" + result);
    }
}",MinimumMoney,28,"[19, 1, 21, 28, 4, 9, 10, 11, 14, 16]","1: class MinimumMoney {
2:     public long minimumMoney(int[][] ts) {
3:         int n = ts.length;
4:         long costtot = 0;
5:         for (int[] t : ts) {
6:             if (t[0]>t[1])
7:                 costtot += t[0]-t[1];
8:         }
9:         long ans = costtot;
10:         for (int[] t : ts) {
11:             if (t[0]>t[1])
12:                 ans = Math.max(ans, costtot+t[1]);
13:             else
14:                 ans = Math.max(ans, costtot+t[0]);
15:         }
16:         return ans;
17:     }
18:     public static void main(String[] args) {
19:         MinimumMoney minimumMoney = new MinimumMoney();
20:         
21:         int[][] transactions = {
22:             {10, 20},
23:             {20, 30},
24:             {30, 40},
25:             {40, 50}
26:         };
27:         
28:         long result = minimumMoney.minimumMoney(transactions);
29:         
30:         System.out.println(""Minimum money required: "" + result);
31:     }
32: }","[28, 19, 2, 4, 5, 6, 7, 9, 10, 11, 12, 14, 16]","{'output': ['28', '19', '2', '4', '5', '6', '7', '9', '10', '11', '12', '14', '16']}","[28, 19, 2, 3, 4, 5, 6, 7, 9, 10, 11, 12, 14, 16]","{'output': ['28', '19', '2', '3', '4', '5', '6', '7', '9', '10', '11', '12', '14', '16']}","[28, 19, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]","{'output': ['28', '19', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16']}"
"class MinimumMountainRemovals {
    public int minimumMountainRemovals(int[] nums) {
        int n = nums.length;
        int[] left = new int[n];
        
        for (int i = 1; i < n; i++) {
            left[i] = i;
            
            for (int j = 0; j < i; j++) {
                if (nums[j] < nums[i]) {
                    left[i] = Math.min(left[i], left[j] + (i - j - 1));
                }
            }
        }
        
        int[] right = new int[n];
        
        for (int i = n - 2; i >= 0; i--) {
            right[i] = n - i - 1;
            
            for (int j = i + 1; j < n; j++) {
                if (nums[j] < nums[i]) {
                    right[i] = Math.min(right[i], right[j] + (j - i - 1));
                }
            }
        }
        
        int answer = Integer.MAX_VALUE;
        for (int i = 1; i < n - 1; i++) {
            answer = Math.min(answer, left[i] + right[i]);
        }
        
        return answer;
    }
      public static void main(String[] args) {
        MinimumMountainRemovals minimumMountainRemovals = new MinimumMountainRemovals();
        
        int[] nums = {2, 1, 1, 5, 6, 2, 3, 1};
        
        int result = minimumMountainRemovals.minimumMountainRemovals(nums);
        
        System.out.println(""Minimum mountain removals: "" + result);
    }
}",MinimumMountainRemovals,40,"[36, 1, 38, 40, 3, 4, 6, 7, 9, 10, 11, 16, 18, 19, 21, 22, 23, 28, 29, 30, 33]","1: class MinimumMountainRemovals {
2:     public int minimumMountainRemovals(int[] nums) {
3:         int n = nums.length;
4:         int[] left = new int[n];
5:         
6:         for (int i = 1; i < n; i++) {
7:             left[i] = i;
8:             
9:             for (int j = 0; j < i; j++) {
10:                 if (nums[j] < nums[i]) {
11:                     left[i] = Math.min(left[i], left[j] + (i - j - 1));
12:                 }
13:             }
14:         }
15:         
16:         int[] right = new int[n];
17:         
18:         for (int i = n - 2; i >= 0; i--) {
19:             right[i] = n - i - 1;
20:             
21:             for (int j = i + 1; j < n; j++) {
22:                 if (nums[j] < nums[i]) {
23:                     right[i] = Math.min(right[i], right[j] + (j - i - 1));
24:                 }
25:             }
26:         }
27:         
28:         int answer = Integer.MAX_VALUE;
29:         for (int i = 1; i < n - 1; i++) {
30:             answer = Math.min(answer, left[i] + right[i]);
31:         }
32:         
33:         return answer;
34:     }
35:       public static void main(String[] args) {
36:         MinimumMountainRemovals minimumMountainRemovals = new MinimumMountainRemovals();
37:         
38:         int[] nums = {2, 1, 1, 5, 6, 2, 3, 1};
39:         
40:         int result = minimumMountainRemovals.minimumMountainRemovals(nums);
41:         
42:         System.out.println(""Minimum mountain removals: "" + result);
43:     }
44: }","[40, 38, 36, 2, 3, 4, 6, 7, 9, 10, 11, 13, 14, 16, 18, 19, 21, 22, 23, 25, 26, 28, 29, 30, 32, 33]","{'output': ['40', '38', '36', '2', '3', '4', '6', '7', '9', '10', '11', '13', '14', '16', '18', '19', '21', '22', '23', '25', '26', '28', '29', '30', '32', '33']}","[40, 38, 36, 2, 3, 4, 6, 7, 9, 10, 11, 13, 14, 16, 18, 19, 21, 22, 23, 25, 26, 28, 29, 30, 31, 32, 33]","{'output': ['40', '38', '36', '2', '3', '4', '6', '7', '9', '10', '11', '13', '14', '16', '18', '19', '21', '22', '23', '25', '26', '28', '29', '30', '31', '32', '33']}","[40, 38, 36, 2, 3, 33, 30, 29, 28, 6, 7, 9, 10, 11, 16, 18, 19, 21, 22, 23]","{'output': ['40', '38', '36', '2', '3', '33', '30', '29', '28', '6', '7', '9', '10', '11', '16', '18', '19', '21', '22', '23']}"
"	import java.util.*;
	class MinimumMoves {
	    public int minimumMoves(int[][] g) {
	        int n = g.length, m = g[0].length;
	        Queue<int[]> q = new ArrayDeque<>();
	        q.add(new int[]{0, 0, 0});
	        int[][][] d = new int[2][n][m];
	        for(int i = 0;i < 2;i++){
	        	for(int j = 0;j < n;j++){
	        		Arrays.fill(d[i][j], 99999999);
	        	}
	        }
	        d[0][0][0] = 0;
	        while(!q.isEmpty()){
	        	int[] cur = q.poll();
	        	int st = cur[0], r = cur[1], c = cur[2];
	        	int ur = r + (st == 1 ? 1 : 0), uc = c + (st == 1 ? 0 : 1);
	        	if(r == n-1 && c == n-2 && st == 0){
	        		return d[st][r][c];
	        	}
	        	// r
	        	if(uc+1 < m && g[r][c+1] == 0 && g[ur][uc+1] == 0 &&
	        			d[st][r][c+1] > d[st][r][c] + 1){
	        		d[st][r][c+1] = d[st][r][c] + 1;
	        		q.add(new int[]{st, r, c+1});
	        	}
	        	// d
	        	if(ur+1 < n && g[r+1][c] == 0 && g[ur+1][uc] == 0 &&
	        			d[st][r+1][c] > d[st][r][c] + 1){
	        		d[st][r+1][c] = d[st][r][c] + 1;
	        		q.add(new int[]{st, r+1, c});
	        	}
	        	int xr = r + (st == 0 ? 1 : 0), xc = c + (st == 0 ? 0 : 1);
	        	if(xr < n && xc < m && g[xr][xc] == 0 && g[r+1][c+1] == 0 && 
	        			d[st^1][r][c] > d[st][r][c] + 1){
	        		d[st^1][r][c] = d[st][r][c] + 1;
	        		q.add(new int[]{st^1, r, c});
	        	}
	        }
	        return -1;
	    }
		 public static void main(String[] args) {
        MinimumMoves minimumMoves = new MinimumMoves();
        
        int[][] grid = {
            {0, 0, 0, 0, 0, 1},
            {1, 1, 0, 0, 1, 0},
            {0, 0, 0, 0, 1, 1},
            {0, 0, 1, 0, 1, 0},
            {0, 1, 1, 0, 0, 0},
            {0, 1, 1, 0, 0, 0}
        };
        
        int result = minimumMoves.minimumMoves(grid);
        
        System.out.println(""Minimum moves: "" + result);
    }
		
	}	
",MinimumMoves,54,"[43, 2, 45, 54, 4, 5, 6, 7, 14, 15, 16, 22, 25, 28, 31, 33, 34, 37, 18, 19]","1: 	import java.util.*;
2: 	class MinimumMoves {
3: 	    public int minimumMoves(int[][] g) {
4: 	        int n = g.length, m = g[0].length;
5: 	        Queue<int[]> q = new ArrayDeque<>();
6: 	        q.add(new int[]{0, 0, 0});
7: 	        int[][][] d = new int[2][n][m];
8: 	        for(int i = 0;i < 2;i++){
9: 	        	for(int j = 0;j < n;j++){
10: 	        		Arrays.fill(d[i][j], 99999999);
11: 	        	}
12: 	        }
13: 	        d[0][0][0] = 0;
14: 	        while(!q.isEmpty()){
15: 	        	int[] cur = q.poll();
16: 	        	int st = cur[0], r = cur[1], c = cur[2];
17: 	        	int ur = r + (st == 1 ? 1 : 0), uc = c + (st == 1 ? 0 : 1);
18: 	        	if(r == n-1 && c == n-2 && st == 0){
19: 	        		return d[st][r][c];
20: 	        	}
21: 	        	// r
22: 	        	if(uc+1 < m && g[r][c+1] == 0 && g[ur][uc+1] == 0 &&
23: 	        			d[st][r][c+1] > d[st][r][c] + 1){
24: 	        		d[st][r][c+1] = d[st][r][c] + 1;
25: 	        		q.add(new int[]{st, r, c+1});
26: 	        	}
27: 	        	// d
28: 	        	if(ur+1 < n && g[r+1][c] == 0 && g[ur+1][uc] == 0 &&
29: 	        			d[st][r+1][c] > d[st][r][c] + 1){
30: 	        		d[st][r+1][c] = d[st][r][c] + 1;
31: 	        		q.add(new int[]{st, r+1, c});
32: 	        	}
33: 	        	int xr = r + (st == 0 ? 1 : 0), xc = c + (st == 0 ? 0 : 1);
34: 	        	if(xr < n && xc < m && g[xr][xc] == 0 && g[r+1][c+1] == 0 && 
35: 	        			d[st^1][r][c] > d[st][r][c] + 1){
36: 	        		d[st^1][r][c] = d[st][r][c] + 1;
37: 	        		q.add(new int[]{st^1, r, c});
38: 	        	}
39: 	        }
40: 	        return -1;
41: 	    }
42: 		 public static void main(String[] args) {
43:         MinimumMoves minimumMoves = new MinimumMoves();
44:         
45:         int[][] grid = {
46:             {0, 0, 0, 0, 0, 1},
47:             {1, 1, 0, 0, 1, 0},
48:             {0, 0, 0, 0, 1, 1},
49:             {0, 0, 1, 0, 1, 0},
50:             {0, 1, 1, 0, 0, 0},
51:             {0, 1, 1, 0, 0, 0}
52:         };
53:         
54:         int result = minimumMoves.minimumMoves(grid);
55:         
56:         System.out.println(""Minimum moves: "" + result);
57:     }
58: 		
59: 	}	
60: ","[54, 43, 45, 46, 47, 48, 49, 50, 51, 3]","{'output': ['54', '43', '45', '46', '47', '48', '49', '50', '51', '3']}","[54, 43, 3]","{'output': ['54', '43', '3']}","[54, 43]","{'output': ['54', '43']}"
"class MinimumOneBitOperations {

    public int minimumOneBitOperations(int n) {
        int ans = 0;
        for (int i = 1; i <= n; i *= 2) {
            ans ^= n / i;
        }
        return ans;
    }
      public static void main(String[] args) {
        MinimumOneBitOperations minimumOneBitOperations = new MinimumOneBitOperations();
        
        int n = 3;
        
        int result = minimumOneBitOperations.minimumOneBitOperations(n);
        
        System.out.println(""Minimum one bit operations to make "" + n + "" zero: "" + result);
    }
}",MinimumOneBitOperations,15,"[11, 1, 15, 4, 5, 6, 8]","1: class MinimumOneBitOperations {
2: 
3:     public int minimumOneBitOperations(int n) {
4:         int ans = 0;
5:         for (int i = 1; i <= n; i *= 2) {
6:             ans ^= n / i;
7:         }
8:         return ans;
9:     }
10:       public static void main(String[] args) {
11:         MinimumOneBitOperations minimumOneBitOperations = new MinimumOneBitOperations();
12:         
13:         int n = 3;
14:         
15:         int result = minimumOneBitOperations.minimumOneBitOperations(n);
16:         
17:         System.out.println(""Minimum one bit operations to make "" + n + "" zero: "" + result);
18:     }
19: }","[15, 13, 11, 3, 4, 5, 6, 8]","{'output': ['15', '13', '11', '3', '4', '5', '6', '8']}","[15, 13, 11, 3, 5, 6, 8]","{'output': ['15', '13', '11', '3', '5', '6', '8']}","[15, 13, 11, 3, 5, 6, 8]","{'output': ['15', '13', '11', '3', '5', '6', '8']}"
"class MinimumReplacement {

	public long minimumReplacement(int[] nums) {
		long count = 0;
		for (int i = nums.length - 2, j = nums[nums.length - 1]; i >= 0; i--) {
			count += (nums[i] - 1) / j;
			j = nums[i] / ((nums[i] + j - 1) / j);
		}
		return count;
	}
	  public static void main(String[] args) {
        MinimumReplacement minimumReplacement = new MinimumReplacement();
        
        int[] nums = {5, 6, 7, 8};
        
        long result = minimumReplacement.minimumReplacement(nums);
        
        System.out.println(""Minimum replacements needed: "" + result);
    }
}",MinimumReplacement,16,"[12, 1, 14, 16, 4, 5, 6, 7, 9]","1: class MinimumReplacement {
2: 
3: 	public long minimumReplacement(int[] nums) {
4: 		long count = 0;
5: 		for (int i = nums.length - 2, j = nums[nums.length - 1]; i >= 0; i--) {
6: 			count += (nums[i] - 1) / j;
7: 			j = nums[i] / ((nums[i] + j - 1) / j);
8: 		}
9: 		return count;
10: 	}
11: 	  public static void main(String[] args) {
12:         MinimumReplacement minimumReplacement = new MinimumReplacement();
13:         
14:         int[] nums = {5, 6, 7, 8};
15:         
16:         long result = minimumReplacement.minimumReplacement(nums);
17:         
18:         System.out.println(""Minimum replacements needed: "" + result);
19:     }
20: }","[16, 14, 12, 3, 4, 5, 6, 7, 9]","{'output': ['16', '14', '12', '3', '4', '5', '6', '7', '9']}","[16, 14, 12, 3, 4, 5, 6, 7, 9]","{'output': ['16', '14', '12', '3', '4', '5', '6', '7', '9']}","[16, 14, 12, 3, 4, 5, 6, 7, 9]","{'output': ['16', '14', '12', '3', '4', '5', '6', '7', '9']}"
"public class NextGreaterElement {
    public int nextGreaterElement(int n) {
        char[] s = Integer.valueOf(n).toString().toCharArray();
        nextPermutation(s);
        try{
            int ans = Integer.valueOf(String.valueOf(s));
            if (ans <= n) {
                return -1;
            }
            return ans;
        } catch (NumberFormatException e) {
            return -1;
        }
    }

    private void swap(char[] nums, int i, int j) {
        char temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
    public void nextPermutation(char[] nums) {
        //sanity check
        if (nums == null || nums.length <= 1) {
            return;
        }

        //find i
        int i = nums.length - 2;
        while (i >= 0 && nums[i] >= nums[i + 1]) {
            i--;
        }

        //swap i and j
        if (i >= 0) {
            int j = nums.length - 1;
            while (j >= 0 && nums[j] <= nums[i]) {
                j--;
            }
            swap(nums, i, j);
        }

        //reverse nums[i+1, n-1]
        for (int p = i + 1, q = nums.length - 1; p < q; p++, q--) {
            swap(nums, p, q);
        }
    }
      public static void main(String[] args) {
        NextGreaterElement nextGreaterElement = new NextGreaterElement();
        
        int n = 12;
        
        int result = nextGreaterElement.nextGreaterElement(n);
        
        System.out.println(""Next greater element: "" + result);
    }
}",NextGreaterElement,52,"[48, 1, 52, 3, 4, 28, 34, 35, 39, 17, 18, 19, 6, 7, 10]","1: public class NextGreaterElement {
2:     public int nextGreaterElement(int n) {
3:         char[] s = Integer.valueOf(n).toString().toCharArray();
4:         nextPermutation(s);
5:         try{
6:             int ans = Integer.valueOf(String.valueOf(s));
7:             if (ans <= n) {
8:                 return -1;
9:             }
10:             return ans;
11:         } catch (NumberFormatException e) {
12:             return -1;
13:         }
14:     }
15: 
16:     private void swap(char[] nums, int i, int j) {
17:         char temp = nums[i];
18:         nums[i] = nums[j];
19:         nums[j] = temp;
20:     }
21:     public void nextPermutation(char[] nums) {
22:         //sanity check
23:         if (nums == null || nums.length <= 1) {
24:             return;
25:         }
26: 
27:         //find i
28:         int i = nums.length - 2;
29:         while (i >= 0 && nums[i] >= nums[i + 1]) {
30:             i--;
31:         }
32: 
33:         //swap i and j
34:         if (i >= 0) {
35:             int j = nums.length - 1;
36:             while (j >= 0 && nums[j] <= nums[i]) {
37:                 j--;
38:             }
39:             swap(nums, i, j);
40:         }
41: 
42:         //reverse nums[i+1, n-1]
43:         for (int p = i + 1, q = nums.length - 1; p < q; p++, q--) {
44:             swap(nums, p, q);
45:         }
46:     }
47:       public static void main(String[] args) {
48:         NextGreaterElement nextGreaterElement = new NextGreaterElement();
49:         
50:         int n = 12;
51:         
52:         int result = nextGreaterElement.nextGreaterElement(n);
53:         
54:         System.out.println(""Next greater element: "" + result);
55:     }
56: }","[52, 50, 48, 2, 3, 4, 21, 23, 28, 29, 30, 34, 35, 36, 37, 39, 43, 44, 16, 17, 18, 19, 6, 7, 10]","{'output': ['52', '50', '48', '2', '3', '4', '21', '23', '28', '29', '30', '34', '35', '36', '37', '39', '43', '44', '16', '17', '18', '19', '6', '7', '10']}","[52, 50, 48, 2, 3, 4, 21, 23, 28, 29, 30, 34, 35, 36, 37, 39, 16, 17, 18, 19, 43, 44]","{'output': ['52', '50', '48', '2', '3', '4', '21', '23', '28', '29', '30', '34', '35', '36', '37', '39', '16', '17', '18', '19', '43', '44']}","[52, 50, 48, 2, 3, 4, 21, 23, 28, 29, 30, 34, 35, 36, 37, 39, 43, 44, 16, 17, 18, 19]","{'output': ['52', '50', '48', '2', '3', '4', '21', '23', '28', '29', '30', '34', '35', '36', '37', '39', '43', '44', '16', '17', '18', '19']}"
"import java.util.*;
public class NumDecodings {
    public int numDecodings(String s) {
    	long div = 1_000_000_007;
    	if (s.isEmpty()) {
    		return 1;
    	}
    	long[] dp = new long[s.length() + 1];
    	dp[0] = 1;
    	char c0 = s.charAt(0);
    	if (c0 == '*') {
    		dp[1] = 9;
    	} else if(c0 == '0') {
    		return 0;
    	} else {
    		dp[1] = 1;
    	}
    	Set<Character> set2 = new HashSet<>();
    	set2.addAll(Arrays.asList('1','2','3','4','5','6'));
    	
    	for (int i = 1; i < s.length(); i++) {
    		char curr = s.charAt(i);
    		char prev = s.charAt(i-1);
    		long prevCnt = dp[i];
    		long prevPrevCnt = dp[i-1];
    		if (curr == '0') {
    			if (prev == '1' || prev == '2') {
    				dp[i+1] = prevPrevCnt;
    			} else if (prev == '*') {
    				dp[i+1] = (prevPrevCnt * 2) % div;
    			} else {
    				return 0;
    			}
    		} else if (curr == '*') {
    			long currCnt = prevCnt * 9;
    			if (prev == '1') {
    				currCnt = currCnt + prevPrevCnt * 9;
    			} else if (prev == '2') {
    				currCnt = currCnt + prevPrevCnt * 6;
    			} else if (prev == '*') {
    				currCnt = currCnt + prevPrevCnt * 15;
    			}
    			dp[i+1] = currCnt % div;
    		} else {
    			long currCnt = prevCnt;
    			if (prev == '1') {
    				currCnt += prevPrevCnt;
    			} else if (prev == '2' && set2.contains(curr)) {
    				currCnt += prevPrevCnt;
    			} else if (prev == '*') {
    				if (set2.contains(curr)) {
    					currCnt += prevPrevCnt * 2;
    				} else {
    					currCnt += prevPrevCnt;
    				}
    			}
    			dp[i+1] = currCnt % div;
    		}
    	}
    	return (int) dp[s.length()];
    }
	 public static void main(String[] args) {
        NumDecodings numDecodings = new NumDecodings();
        
        String s = ""*1*1*0"";
        
        int result = numDecodings.numDecodings(s);
        
        System.out.println(""Number of ways to decode the string: "" + result);
    }
}",NumDecodings,67,"[63, 2, 67, 5, 8, 9, 10, 12, 18, 19, 21, 22, 23, 24, 25, 51, 52, 44, 57, 28, 26, 35, 34, 37, 43, 30, 60]","1: import java.util.*;
2: public class NumDecodings {
3:     public int numDecodings(String s) {
4:     	long div = 1_000_000_007;
5:     	if (s.isEmpty()) {
6:     		return 1;
7:     	}
8:     	long[] dp = new long[s.length() + 1];
9:     	dp[0] = 1;
10:     	char c0 = s.charAt(0);
11:     	if (c0 == '*') {
12:     		dp[1] = 9;
13:     	} else if(c0 == '0') {
14:     		return 0;
15:     	} else {
16:     		dp[1] = 1;
17:     	}
18:     	Set<Character> set2 = new HashSet<>();
19:     	set2.addAll(Arrays.asList('1','2','3','4','5','6'));
20:     	
21:     	for (int i = 1; i < s.length(); i++) {
22:     		char curr = s.charAt(i);
23:     		char prev = s.charAt(i-1);
24:     		long prevCnt = dp[i];
25:     		long prevPrevCnt = dp[i-1];
26:     		if (curr == '0') {
27:     			if (prev == '1' || prev == '2') {
28:     				dp[i+1] = prevPrevCnt;
29:     			} else if (prev == '*') {
30:     				dp[i+1] = (prevPrevCnt * 2) % div;
31:     			} else {
32:     				return 0;
33:     			}
34:     		} else if (curr == '*') {
35:     			long currCnt = prevCnt * 9;
36:     			if (prev == '1') {
37:     				currCnt = currCnt + prevPrevCnt * 9;
38:     			} else if (prev == '2') {
39:     				currCnt = currCnt + prevPrevCnt * 6;
40:     			} else if (prev == '*') {
41:     				currCnt = currCnt + prevPrevCnt * 15;
42:     			}
43:     			dp[i+1] = currCnt % div;
44:     		} else {
45:     			long currCnt = prevCnt;
46:     			if (prev == '1') {
47:     				currCnt += prevPrevCnt;
48:     			} else if (prev == '2' && set2.contains(curr)) {
49:     				currCnt += prevPrevCnt;
50:     			} else if (prev == '*') {
51:     				if (set2.contains(curr)) {
52:     					currCnt += prevPrevCnt * 2;
53:     				} else {
54:     					currCnt += prevPrevCnt;
55:     				}
56:     			}
57:     			dp[i+1] = currCnt % div;
58:     		}
59:     	}
60:     	return (int) dp[s.length()];
61:     }
62: 	 public static void main(String[] args) {
63:         NumDecodings numDecodings = new NumDecodings();
64:         
65:         String s = ""*1*1*0"";
66:         
67:         int result = numDecodings.numDecodings(s);
68:         
69:         System.out.println(""Number of ways to decode the string: "" + result);
70:     }
71: }","[67, 65, 63, 2, 3, 4, 8, 9, 10, 11, 12, 13, 14, 16, 18, 19, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 34, 35, 36, 37, 38, 39, 40, 41, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 54, 57, 60]","{'output': ['67', '65', '63', '2', '3', '4', '8', '9', '10', '11', '12', '13', '14', '16', '18', '19', '21', '22', '23', '24', '25', '26', '27', '28', '29', '30', '34', '35', '36', '37', '38', '39', '40', '41', '43', '44', '45', '46', '47', '48', '49', '50', '51', '52', '54', '57', '60']}","[67, 66, 63, 62, 3, 60, 59, 57, 55, 54, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4]","{'output': ['67', '66', '63', '62', '3', '60', '59', '57', '55', '54', '52', '51', '50', '49', '48', '47', '46', '45', '44', '43', '42', '41', '40', '39', '38', '37', '36', '35', '34', '32', '31', '30', '29', '28', '27', '26', '25', '24', '23', '22', '21', '20', '19', '18', '17', '16', '15', '14', '13', '12', '11', '10', '9', '8', '7', '6', '5', '4']}","[67, 65, 63, 3, 60, 59, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4]","{'output': ['67', '65', '63', '3', '60', '59', '57', '56', '55', '54', '53', '52', '51', '50', '49', '48', '47', '46', '45', '44', '43', '42', '41', '40', '39', '38', '37', '36', '35', '34', '33', '32', '31', '30', '29', '28', '27', '26', '25', '24', '23', '22', '21', '20', '19', '18', '17', '16', '15', '14', '13', '12', '11', '10', '9', '8', '7', '6', '5', '4']}"
"

import java.util.*;

public class NumSubseq {
    public static void main(String[] args) {
        int[] input = new int[]{};
        int[] output = new int[]{2, 3};
        System.out.println(new NumSubseq());
    }

    public int numSubseq(int[] a, int target) {
        int n = a.length;
        Integer[] indices = new Integer[n];
        for (int i = 0; i < n; i++) {
            indices[i] = i;
        }
        Arrays.sort(indices, 0, n, (Integer x, Integer y) -> a[x] == a[y] ? Integer.compare(x, y) : Integer.compare(a[x], a[y]));
        int r = 0;
        int[] pow2 = new int[n + 1];
        pow2[0] = 1;
        for (int i = 1; i <= n; i++) {
            pow2[i] = pow2[i - 1] * 2 % mod;
        }
        int ans = 0;
        //System.out.println(Arrays.deepToString(indices));
        r = n - 1;
        for (int i = 0; i < n; i++) {
            r = Math.max(r, i);
            while (r - 1 >= i && a[indices[r]] + a[indices[i]] > target) {
                r--;
            }
           // System.out.println(indices[i] + "":"" + r);
            if (a[indices[r]] + a[indices[i]] <= target) {
                int cnt = r - i;
                ans = (ans + pow2[cnt]) % mod;
            }
            
        }
        
        return ans;
    }

    int mod = (int) (1e9 + 7);
}
",NumSubseq,9,"[9, 5, 44]","1: 
2: 
3: import java.util.*;
4: 
5: public class NumSubseq {
6:     public static void main(String[] args) {
7:         int[] input = new int[]{};
8:         int[] output = new int[]{2, 3};
9:         System.out.println(new NumSubseq());
10:     }
11: 
12:     public int numSubseq(int[] a, int target) {
13:         int n = a.length;
14:         Integer[] indices = new Integer[n];
15:         for (int i = 0; i < n; i++) {
16:             indices[i] = i;
17:         }
18:         Arrays.sort(indices, 0, n, (Integer x, Integer y) -> a[x] == a[y] ? Integer.compare(x, y) : Integer.compare(a[x], a[y]));
19:         int r = 0;
20:         int[] pow2 = new int[n + 1];
21:         pow2[0] = 1;
22:         for (int i = 1; i <= n; i++) {
23:             pow2[i] = pow2[i - 1] * 2 % mod;
24:         }
25:         int ans = 0;
26:         //System.out.println(Arrays.deepToString(indices));
27:         r = n - 1;
28:         for (int i = 0; i < n; i++) {
29:             r = Math.max(r, i);
30:             while (r - 1 >= i && a[indices[r]] + a[indices[i]] > target) {
31:                 r--;
32:             }
33:            // System.out.println(indices[i] + "":"" + r);
34:             if (a[indices[r]] + a[indices[i]] <= target) {
35:                 int cnt = r - i;
36:                 ans = (ans + pow2[cnt]) % mod;
37:             }
38:             
39:         }
40:         
41:         return ans;
42:     }
43: 
44:     int mod = (int) (1e9 + 7);
45: }
46: ",[9],{'output': ['9']},"[9, 7, 8]","{'output': ['9', '7', '8']}","[9, 7, 8, 6]","{'output': ['9', '7', '8', '6']}"
"import java.util.*;

public class NumberOfArithmeticSlices {
    HashMap<String, Integer> check = new HashMap<>();
    
    public int numberOfArithmeticSlices(int[] A) {
        if (A==null || A.length<3) return 0;
        HashMap<Long, List<Integer>> map = new HashMap<>();
        for (int i=0; i<A.length; i++) {
            if (!map.containsKey((long)A[i])) map.put((long)A[i], new ArrayList<Integer>());
            map.get((long)A[i]).add(i);
        }
        int count = 0;
        for (int i=0; i<A.length-2; i++) {
            for (int j=i+1; j<A.length-1; j++) {
                long dif = (long)A[j]-(long)A[i];
                long target = (long)A[j]+dif;
                count += helper(map, j, target, dif);
            }
        }
        return count;
    }
    
    private int helper(HashMap<Long, List<Integer>> map, int thred, long target, long dif) {
        String key = thred+"",""+target+"",""+dif;
        if (check.containsKey(key)) return check.get(key);
        if (map.containsKey(target)) {
            List<Integer> list = map.get(target);
            int count = 0;
            for (int each:list) {
                if (each > thred) {
                    count += helper(map, each, target+dif, dif) + 1;
                }
            }
            check.put(key, count);
            return count;
        } else return 0;
    }
       public static void main(String[] args) {
        NumberOfArithmeticSlices numberOfArithmeticSlices = new NumberOfArithmeticSlices();
        
        int[] A = {2, 4, 6, 8, 10};
        
        int result = numberOfArithmeticSlices.numberOfArithmeticSlices(A);
        
        System.out.println(""Number of arithmetic slices: "" + result);
    }
}",NumberOfArithmeticSlices,44,"[40, 3, 4, 42, 44, 8, 13, 14, 15, 16, 17, 18, 25, 26, 27, 28, 30, 31, 32, 29, 35, 36, 37, 21]","1: import java.util.*;
2: 
3: public class NumberOfArithmeticSlices {
4:     HashMap<String, Integer> check = new HashMap<>();
5:     
6:     public int numberOfArithmeticSlices(int[] A) {
7:         if (A==null || A.length<3) return 0;
8:         HashMap<Long, List<Integer>> map = new HashMap<>();
9:         for (int i=0; i<A.length; i++) {
10:             if (!map.containsKey((long)A[i])) map.put((long)A[i], new ArrayList<Integer>());
11:             map.get((long)A[i]).add(i);
12:         }
13:         int count = 0;
14:         for (int i=0; i<A.length-2; i++) {
15:             for (int j=i+1; j<A.length-1; j++) {
16:                 long dif = (long)A[j]-(long)A[i];
17:                 long target = (long)A[j]+dif;
18:                 count += helper(map, j, target, dif);
19:             }
20:         }
21:         return count;
22:     }
23:     
24:     private int helper(HashMap<Long, List<Integer>> map, int thred, long target, long dif) {
25:         String key = thred+"",""+target+"",""+dif;
26:         if (check.containsKey(key)) return check.get(key);
27:         if (map.containsKey(target)) {
28:             List<Integer> list = map.get(target);
29:             int count = 0;
30:             for (int each:list) {
31:                 if (each > thred) {
32:                     count += helper(map, each, target+dif, dif) + 1;
33:                 }
34:             }
35:             check.put(key, count);
36:             return count;
37:         } else return 0;
38:     }
39:        public static void main(String[] args) {
40:         NumberOfArithmeticSlices numberOfArithmeticSlices = new NumberOfArithmeticSlices();
41:         
42:         int[] A = {2, 4, 6, 8, 10};
43:         
44:         int result = numberOfArithmeticSlices.numberOfArithmeticSlices(A);
45:         
46:         System.out.println(""Number of arithmetic slices: "" + result);
47:     }
48: }","[44, 6, 7, 8, 9, 10, 11, 13, 14, 15, 16, 17, 18, 24, 25, 26, 27, 28, 29, 30, 31, 32, 35]","{'output': ['44', '6', '7', '8', '9', '10', '11', '13', '14', '15', '16', '17', '18', '24', '25', '26', '27', '28', '29', '30', '31', '32', '35']}","[44, 6, 7, 8, 9, 10, 11, 13, 14, 15, 16, 17, 18, 24, 25, 26, 27, 28, 29, 30, 31, 32, 35]","{'output': ['44', '6', '7', '8', '9', '10', '11', '13', '14', '15', '16', '17', '18', '24', '25', '26', '27', '28', '29', '30', '31', '32', '35']}","[44, 42, 40, 21, 19, 18, 16, 15, 14, 13, 8, 7, 6]","{'output': ['44', '42', '40', '21', '19', '18', '16', '15', '14', '13', '8', '7', '6']}"
"	class NumberOfArrays {
	    public int numberOfArrays(String S, int k) {
	        int n = S.length();
	        char[] s = S.toCharArray();
	        long[] dp = new long[n+1];
	        dp[0] = 1;
	        int mod = 1000000007;
	        for(int i = 0;i < n;i++){
	        	if(s[i] == '0')continue;
	        	long u = 0;
	        	for(int j = i;j < n;j++){
	        		u = u * 10 + (s[j]-'0');
	        		if(u >= 1 && u <= k){
	        			dp[j+1] += dp[i];
	        			if(dp[j+1] >= mod)dp[j+1] -= mod;
	        		}else{
	        			break;
	        		}
	        	}
	        }
	        return (int)dp[n];
	    }
		 public static void main(String[] args) {
        NumberOfArrays numberOfArrays = new NumberOfArrays();
        
        String S = ""1317"";
        int k = 10;
        
        int result = numberOfArrays.numberOfArrays(S, k);
        
        System.out.println(""Number of ways to split the string: "" + result);
    }
	}	
",NumberOfArrays,29,"[24, 1, 29, 3, 4, 5, 6, 8, 9, 11, 14, 21]","1: 	class NumberOfArrays {
2: 	    public int numberOfArrays(String S, int k) {
3: 	        int n = S.length();
4: 	        char[] s = S.toCharArray();
5: 	        long[] dp = new long[n+1];
6: 	        dp[0] = 1;
7: 	        int mod = 1000000007;
8: 	        for(int i = 0;i < n;i++){
9: 	        	if(s[i] == '0')continue;
10: 	        	long u = 0;
11: 	        	for(int j = i;j < n;j++){
12: 	        		u = u * 10 + (s[j]-'0');
13: 	        		if(u >= 1 && u <= k){
14: 	        			dp[j+1] += dp[i];
15: 	        			if(dp[j+1] >= mod)dp[j+1] -= mod;
16: 	        		}else{
17: 	        			break;
18: 	        		}
19: 	        	}
20: 	        }
21: 	        return (int)dp[n];
22: 	    }
23: 		 public static void main(String[] args) {
24:         NumberOfArrays numberOfArrays = new NumberOfArrays();
25:         
26:         String S = ""1317"";
27:         int k = 10;
28:         
29:         int result = numberOfArrays.numberOfArrays(S, k);
30:         
31:         System.out.println(""Number of ways to split the string: "" + result);
32:     }
33: 	}	
34: ","[29, 24, 2]","{'output': ['29', '24', '2']}","[29, 24, 2]","{'output': ['29', '24', '2']}","[29, 24, 2]","{'output': ['29', '24', '2']}"
"class NumberOfWays {

	public long numberOfWays(String s) {
		long right[] = new long[s.length()], one = 0, count = 0;
		for (int i = s.length() - 1; i > 0; i--) {
			right[i - 1] = (s.charAt(i) - '0') + right[i];
		}
		for (int i = 0; i < s.length(); i++) {
			count += s.charAt(i) == '0' ? one * right[i] : (i - one) * (s.length() - i - right[i] - 1);
			one += s.charAt(i) - '0';
		}
		return count;
	}
	 public static void main(String[] args) {
        NumberOfWays numberOfWays = new NumberOfWays();
        
        String s = ""001101"";
        
        long result = numberOfWays.numberOfWays(s);
        
        System.out.println(""Number of ways to choose triples: "" + result);
    }
}",NumberOfWays,19,"[15, 1, 19, 4, 5, 6, 8, 9, 10, 12]","1: class NumberOfWays {
2: 
3: 	public long numberOfWays(String s) {
4: 		long right[] = new long[s.length()], one = 0, count = 0;
5: 		for (int i = s.length() - 1; i > 0; i--) {
6: 			right[i - 1] = (s.charAt(i) - '0') + right[i];
7: 		}
8: 		for (int i = 0; i < s.length(); i++) {
9: 			count += s.charAt(i) == '0' ? one * right[i] : (i - one) * (s.length() - i - right[i] - 1);
10: 			one += s.charAt(i) - '0';
11: 		}
12: 		return count;
13: 	}
14: 	 public static void main(String[] args) {
15:         NumberOfWays numberOfWays = new NumberOfWays();
16:         
17:         String s = ""001101"";
18:         
19:         long result = numberOfWays.numberOfWays(s);
20:         
21:         System.out.println(""Number of ways to choose triples: "" + result);
22:     }
23: }","[19, 17, 15, 3, 4, 5, 6, 8, 9, 10, 12]","{'output': ['19', '17', '15', '3', '4', '5', '6', '8', '9', '10', '12']}","[19, 17, 15, 3, 4, 5, 6, 8, 9, 10, 12]","{'output': ['19', '17', '15', '3', '4', '5', '6', '8', '9', '10', '12']}","[19, 17, 15, 3, 4, 5, 6, 8, 9, 10, 12]","{'output': ['19', '17', '15', '3', '4', '5', '6', '8', '9', '10', '12']}"
"class PlaceWordInCrossword {
    boolean go(char[][] board, char[] w)
    {
        int n = board.length;
        int m = board[0].length;
        for(int i = 0;i < n;i++){
            for(int j = 0;j < m;){
                int k = j;
                while(k < m && board[i][k] != '#')k++;
                
                if(w.length == k-j){
                    {
                        boolean valid = true;
                        for(int t = 0;t < w.length;t++){
                            if(board[i][j+t] != ' ' && board[i][j+t] != w[t]){
                                valid = false;
                            }
                        }
                        if(valid)return true;
                    }
                    {
                        boolean valid = true;
                        for(int t = 0;t < w.length;t++){
                            if(board[i][j+t] != ' ' && board[i][j+t] != w[w.length-1-t]){
                                valid = false;
                            }
                        }
                        if(valid)return true;
                    }
                }
                
                if(k == j)k++;
                j = k;
            }
        }
        return false;
    }
    
    public boolean placeWordInCrossword(char[][] board, String word) {
        char[] w = word.toCharArray();
        if(go(board, w))return true;
        
        int n = board.length;
        int m = board[0].length;
        char[][] nb = new char[m][n];
        for(int i = 0;i < m;i++){
            for(int j = 0;j < n;j++){
                nb[i][j] = board[j][i];
            }
        }
        return go(nb, w);
    }
     public static void main(String[] args) {
        PlaceWordInCrossword placeWordInCrossword = new PlaceWordInCrossword();
        
        char[][] board = {
            {'#', ' ', '#'},
            {' ', ' ', '#'},
            {'#', 'c', ' '}
        };
        String word = ""abc"";
        
        boolean result = placeWordInCrossword.placeWordInCrossword(board, word);
        
        System.out.println(""Can place the word in the crossword: "" + result);
    }

}",PlaceWordInCrossword,63,"[54, 1, 56, 63, 40, 41, 4, 5, 6, 7, 8, 11, 32, 33, 9, 36, 43, 44, 45, 51, 13, 19]","1: class PlaceWordInCrossword {
2:     boolean go(char[][] board, char[] w)
3:     {
4:         int n = board.length;
5:         int m = board[0].length;
6:         for(int i = 0;i < n;i++){
7:             for(int j = 0;j < m;){
8:                 int k = j;
9:                 while(k < m && board[i][k] != '#')k++;
10:                 
11:                 if(w.length == k-j){
12:                     {
13:                         boolean valid = true;
14:                         for(int t = 0;t < w.length;t++){
15:                             if(board[i][j+t] != ' ' && board[i][j+t] != w[t]){
16:                                 valid = false;
17:                             }
18:                         }
19:                         if(valid)return true;
20:                     }
21:                     {
22:                         boolean valid = true;
23:                         for(int t = 0;t < w.length;t++){
24:                             if(board[i][j+t] != ' ' && board[i][j+t] != w[w.length-1-t]){
25:                                 valid = false;
26:                             }
27:                         }
28:                         if(valid)return true;
29:                     }
30:                 }
31:                 
32:                 if(k == j)k++;
33:                 j = k;
34:             }
35:         }
36:         return false;
37:     }
38:     
39:     public boolean placeWordInCrossword(char[][] board, String word) {
40:         char[] w = word.toCharArray();
41:         if(go(board, w))return true;
42:         
43:         int n = board.length;
44:         int m = board[0].length;
45:         char[][] nb = new char[m][n];
46:         for(int i = 0;i < m;i++){
47:             for(int j = 0;j < n;j++){
48:                 nb[i][j] = board[j][i];
49:             }
50:         }
51:         return go(nb, w);
52:     }
53:      public static void main(String[] args) {
54:         PlaceWordInCrossword placeWordInCrossword = new PlaceWordInCrossword();
55:         
56:         char[][] board = {
57:             {'#', ' ', '#'},
58:             {' ', ' ', '#'},
59:             {'#', 'c', ' '}
60:         };
61:         String word = ""abc"";
62:         
63:         boolean result = placeWordInCrossword.placeWordInCrossword(board, word);
64:         
65:         System.out.println(""Can place the word in the crossword: "" + result);
66:     }
67: 
68: }","[63, 39, 40, 41, 2, 4, 5, 6, 7, 8, 9, 11, 12, 13, 14, 15, 16, 18, 19, 22, 23, 24, 25, 27, 28, 32, 33, 36, 43, 44, 45, 46, 47, 48, 51]","{'output': ['63', '39', '40', '41', '2', '4', '5', '6', '7', '8', '9', '11', '12', '13', '14', '15', '16', '18', '19', '22', '23', '24', '25', '27', '28', '32', '33', '36', '43', '44', '45', '46', '47', '48', '51']}","[63, 62, 61, 60, 59, 58, 57, 56, 55, 54]","{'output': ['63', '62', '61', '60', '59', '58', '57', '56', '55', '54']}","[63, 53, 54, 39, 40, 41, 2, 4, 5, 6, 7, 8, 9, 11, 13, 14, 15, 16, 18, 19, 22, 23, 24, 25, 27, 28, 32, 33, 35, 36, 42, 43, 44, 45, 46, 47, 48, 50, 51]","{'output': ['63', '53', '54', '39', '40', '41', '2', '4', '5', '6', '7', '8', '9', '11', '13', '14', '15', '16', '18', '19', '22', '23', '24', '25', '27', '28', '32', '33', '35', '36', '42', '43', '44', '45', '46', '47', '48', '50', '51']}"
"class ProbabilityOfHeads {
    public double probabilityOfHeads(double[] prob, int target) {
        int n = prob.length;
        double[][] p = new double[1+n][1+n];
        p[0][0] = 1;
        for(int i = 0; i< n; i++){
            for(int j = 0; j<= n; j++){
                p[i+1][j] += p[i][j]*(1-prob[i]);
                if(j < n)p[i+1][j+1] += p[i][j]*prob[i];
            }
        }
        return p[n][target];
    }
     public static void main(String[] args) {
        ProbabilityOfHeads probabilityOfHeads = new ProbabilityOfHeads();
        
        double[] prob = {0.5, 0.5, 0.5, 0.5};
        int target = 2;
        
        double result = probabilityOfHeads.probabilityOfHeads(prob, target);
        
        System.out.println(""Probability of getting exactly "" + target + "" heads: "" + result);
    }
}",ProbabilityOfHeads,20,"[15, 1, 17, 20, 3, 4, 12]","1: class ProbabilityOfHeads {
2:     public double probabilityOfHeads(double[] prob, int target) {
3:         int n = prob.length;
4:         double[][] p = new double[1+n][1+n];
5:         p[0][0] = 1;
6:         for(int i = 0; i< n; i++){
7:             for(int j = 0; j<= n; j++){
8:                 p[i+1][j] += p[i][j]*(1-prob[i]);
9:                 if(j < n)p[i+1][j+1] += p[i][j]*prob[i];
10:             }
11:         }
12:         return p[n][target];
13:     }
14:      public static void main(String[] args) {
15:         ProbabilityOfHeads probabilityOfHeads = new ProbabilityOfHeads();
16:         
17:         double[] prob = {0.5, 0.5, 0.5, 0.5};
18:         int target = 2;
19:         
20:         double result = probabilityOfHeads.probabilityOfHeads(prob, target);
21:         
22:         System.out.println(""Probability of getting exactly "" + target + "" heads: "" + result);
23:     }
24: }","[20, 18, 17, 15]","{'output': ['20', '18', '17', '15']}","[20, 15, 17, 18]","{'output': ['20', '15', '17', '18']}","[20, 15, 17, 18]","{'output': ['20', '15', '17', '18']}"
"class Query {


    private int query(int pos) {
        int ans = 0;
        while (pos >= 1) {
            ans += tree[pos];
            pos -= (pos & (- pos));
        }
        return ans;
    }

    private void update(int pos) {
        while (pos <= 300000) {
            tree[pos] ++;
            pos += (pos & (- pos));
        }
    }

    private int OFFSET = 100000;
    private int[] tree = new int[300010];

    public long numberOfPairs(int[] nums1, int[] nums2, int diff) {
        long ans = 0;
        for (int i = 0;i < nums1.length;i ++) {
            int val = nums1[i] - nums2[i] + OFFSET;
            int expect = val + diff;
            ans += query(expect);
            update(val);
        }
        return ans;
    }
        public static void main(String[] args) {
        Query query = new Query();
        
        int[] nums1 = {3, 1, 4, 1, 5};
        int[] nums2 = {2, 7, 1, 8, 2};
        int diff = 1;
        
        long result = query.numberOfPairs(nums1, nums2, diff);
        
        System.out.println(""Number of pairs: "" + result);
    }

}",Query,40,"[34, 1, 20, 21, 36, 37, 40, 24, 25, 26, 27, 28, 5, 6, 7, 8, 10, 31]","1: class Query {
2: 
3: 
4:     private int query(int pos) {
5:         int ans = 0;
6:         while (pos >= 1) {
7:             ans += tree[pos];
8:             pos -= (pos & (- pos));
9:         }
10:         return ans;
11:     }
12: 
13:     private void update(int pos) {
14:         while (pos <= 300000) {
15:             tree[pos] ++;
16:             pos += (pos & (- pos));
17:         }
18:     }
19: 
20:     private int OFFSET = 100000;
21:     private int[] tree = new int[300010];
22: 
23:     public long numberOfPairs(int[] nums1, int[] nums2, int diff) {
24:         long ans = 0;
25:         for (int i = 0;i < nums1.length;i ++) {
26:             int val = nums1[i] - nums2[i] + OFFSET;
27:             int expect = val + diff;
28:             ans += query(expect);
29:             update(val);
30:         }
31:         return ans;
32:     }
33:         public static void main(String[] args) {
34:         Query query = new Query();
35:         
36:         int[] nums1 = {3, 1, 4, 1, 5};
37:         int[] nums2 = {2, 7, 1, 8, 2};
38:         int diff = 1;
39:         
40:         long result = query.numberOfPairs(nums1, nums2, diff);
41:         
42:         System.out.println(""Number of pairs: "" + result);
43:     }
44: 
45: }","[40, 23, 24, 25, 26, 27, 28, 29, 30, 31, 4, 5, 6, 7, 8, 9, 10, 13, 14, 15, 16, 17, 18, 20, 21, 33, 34, 36, 37, 38]","{'output': ['40', '23', '24', '25', '26', '27', '28', '29', '30', '31', '4', '5', '6', '7', '8', '9', '10', '13', '14', '15', '16', '17', '18', '20', '21', '33', '34', '36', '37', '38']}","[40, 23, 24, 25, 26, 27, 28, 4, 6, 7, 8, 10, 29, 13, 14, 15, 16, 17, 30, 31, 36, 37, 38]","{'output': ['40', '23', '24', '25', '26', '27', '28', '4', '6', '7', '8', '10', '29', '13', '14', '15', '16', '17', '30', '31', '36', '37', '38']}","[40, 23, 24, 25, 26, 27, 28, 4, 5, 6, 7, 8, 10, 29, 13, 14, 15, 16, 18, 30, 31, 20, 21, 34, 36, 37, 38]","{'output': ['40', '23', '24', '25', '26', '27', '28', '4', '5', '6', '7', '8', '10', '29', '13', '14', '15', '16', '18', '30', '31', '20', '21', '34', '36', '37', '38']}"
"import java.util.*;




class ReplaceValueInTree {
	public static class TreeNode {
	int val;
    TreeNode left;
  	TreeNode right;
    TreeNode(int x) { val = x; }
 }

	public TreeNode replaceValueInTree(TreeNode root) {
		HashMap<TreeNode, Integer> map = new HashMap<>();
		HashMap<Integer, Integer> map2 = new HashMap<>();
		replaceValueInTree(root, null, 0, map, map2);
		replaceValueInTree(root, 0, null, map, map2);
		return root;
	}

	private void replaceValueInTree(TreeNode root, TreeNode parent, int depth, HashMap<TreeNode, Integer> map,
			HashMap<Integer, Integer> map2) {
		if (root != null) {
			if (parent != null) {
				map.put(parent, map.getOrDefault(parent, 0) + root.val);
			}
			map2.put(depth, map2.getOrDefault(depth, 0) + root.val);
			replaceValueInTree(root.left, root, depth + 1, map, map2);
			replaceValueInTree(root.right, root, depth + 1, map, map2);
		}
	}

	private void replaceValueInTree(TreeNode root, int depth, TreeNode parent, HashMap<TreeNode, Integer> map,
			HashMap<Integer, Integer> map2) {
		if (root != null) {
			root.val = parent == null ? 0 : map2.get(depth) - map.get(parent);
			replaceValueInTree(root.left, depth + 1, root, map, map2);
			replaceValueInTree(root.right, depth + 1, root, map, map2);
		}
	}
	    public static void main(String[] args) {

        ReplaceValueInTree.TreeNode root = new ReplaceValueInTree.TreeNode(1);
        root.left = new ReplaceValueInTree.TreeNode(2);
        root.right = new ReplaceValueInTree.TreeNode(3);
        root.left.left = new ReplaceValueInTree.TreeNode(4);
        root.left.right = new ReplaceValueInTree.TreeNode(5);
        root.right.right = new ReplaceValueInTree.TreeNode(6);

        ReplaceValueInTree replaceValueInTree = new ReplaceValueInTree();
        ReplaceValueInTree.TreeNode newRoot = replaceValueInTree.replaceValueInTree(root);


    }

}",ReplaceValueInTree,52,"[44, 45, 46, 47, 48, 49, 51, 6, 52, 15, 16, 17, 24, 28, 29, 25, 26, 30, 18, 36, 37, 38, 39, 19]","1: import java.util.*;
2: 
3: 
4: 
5: 
6: class ReplaceValueInTree {
7: 	public static class TreeNode {
8: 	int val;
9:     TreeNode left;
10:   	TreeNode right;
11:     TreeNode(int x) { val = x; }
12:  }
13: 
14: 	public TreeNode replaceValueInTree(TreeNode root) {
15: 		HashMap<TreeNode, Integer> map = new HashMap<>();
16: 		HashMap<Integer, Integer> map2 = new HashMap<>();
17: 		replaceValueInTree(root, null, 0, map, map2);
18: 		replaceValueInTree(root, 0, null, map, map2);
19: 		return root;
20: 	}
21: 
22: 	private void replaceValueInTree(TreeNode root, TreeNode parent, int depth, HashMap<TreeNode, Integer> map,
23: 			HashMap<Integer, Integer> map2) {
24: 		if (root != null) {
25: 			if (parent != null) {
26: 				map.put(parent, map.getOrDefault(parent, 0) + root.val);
27: 			}
28: 			map2.put(depth, map2.getOrDefault(depth, 0) + root.val);
29: 			replaceValueInTree(root.left, root, depth + 1, map, map2);
30: 			replaceValueInTree(root.right, root, depth + 1, map, map2);
31: 		}
32: 	}
33: 
34: 	private void replaceValueInTree(TreeNode root, int depth, TreeNode parent, HashMap<TreeNode, Integer> map,
35: 			HashMap<Integer, Integer> map2) {
36: 		if (root != null) {
37: 			root.val = parent == null ? 0 : map2.get(depth) - map.get(parent);
38: 			replaceValueInTree(root.left, depth + 1, root, map, map2);
39: 			replaceValueInTree(root.right, depth + 1, root, map, map2);
40: 		}
41: 	}
42: 	    public static void main(String[] args) {
43: 
44:         ReplaceValueInTree.TreeNode root = new ReplaceValueInTree.TreeNode(1);
45:         root.left = new ReplaceValueInTree.TreeNode(2);
46:         root.right = new ReplaceValueInTree.TreeNode(3);
47:         root.left.left = new ReplaceValueInTree.TreeNode(4);
48:         root.left.right = new ReplaceValueInTree.TreeNode(5);
49:         root.right.right = new ReplaceValueInTree.TreeNode(6);
50: 
51:         ReplaceValueInTree replaceValueInTree = new ReplaceValueInTree();
52:         ReplaceValueInTree.TreeNode newRoot = replaceValueInTree.replaceValueInTree(root);
53: 
54: 
55:     }
56: 
57: }","[52, 14, 17, 34, 36, 37, 15, 16, 24, 26, 28, 29, 30, 38, 39]","{'output': ['52', '14', '17', '34', '36', '37', '15', '16', '24', '26', '28', '29', '30', '38', '39']}","[52, 14, 17, 18]","{'output': ['52', '14', '17', '18']}","[52, 14, 15, 16, 17, 18, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 34, 35, 36, 37, 38, 39, 40]","{'output': ['52', '14', '15', '16', '17', '18', '22', '23', '24', '25', '26', '27', '28', '29', '30', '31', '32', '34', '35', '36', '37', '38', '39', '40']}"
"import java.util.*;
public class ReplaceWords {    
    class TrieNode 
    {
        TrieNode[] next=new TrieNode[26];
        String word;
    }
    TrieNode buildTrie(List<String> words) 
    {
        TrieNode root=new TrieNode();
        for (String w:words) 
        {
            TrieNode p=root;
            for (char c:w.toCharArray()) 
            {
                if (p.next[c-97]==null) p.next[c-97]=new TrieNode();
                p=p.next[c-97];
            }
            p.word=w;
        }
        return root;
    }
    String find(TrieNode now,String s)
    {
        int l=s.length();
        for (int i=0;i<l;i++)
        {
            char c=s.charAt(i);
            if (now.next[c-97]==null) return """"; else now=now.next[c-97];
            if (now.word!=null) return now.word;
        }
        return """";
    }
    public String replaceWords(List<String> dict, String sentence) {
        TrieNode root=buildTrie(dict);
        String[] ss=sentence.split("" "");
        StringBuilder ans=new StringBuilder();
        boolean bo=false;
        for (String s:ss)
        {
            String t=find(root,s);
            if (t=="""") t=s;
            if (bo) ans.append("" "");
            ans.append(t);
            bo=true;
        }
        return ans+"""";
    }
       public static void main(String[] args) {
        ReplaceWords replaceWords = new ReplaceWords();
        
        List<String> dict = Arrays.asList(""cat"", ""bat"", ""rat"");
        String sentence = ""the cattle was rattled by the battery"";
        
        String result = replaceWords.replaceWords(dict, sentence);
        
        System.out.println(""Replaced sentence: "" + result);
    }
}",ReplaceWords,55,"[50, 2, 52, 55, 35, 10, 11, 14, 16, 19, 36, 37, 38, 39, 41, 25, 26, 28, 29, 42, 43, 44, 45, 30, 47]","1: import java.util.*;
2: public class ReplaceWords {    
3:     class TrieNode 
4:     {
5:         TrieNode[] next=new TrieNode[26];
6:         String word;
7:     }
8:     TrieNode buildTrie(List<String> words) 
9:     {
10:         TrieNode root=new TrieNode();
11:         for (String w:words) 
12:         {
13:             TrieNode p=root;
14:             for (char c:w.toCharArray()) 
15:             {
16:                 if (p.next[c-97]==null) p.next[c-97]=new TrieNode();
17:                 p=p.next[c-97];
18:             }
19:             p.word=w;
20:         }
21:         return root;
22:     }
23:     String find(TrieNode now,String s)
24:     {
25:         int l=s.length();
26:         for (int i=0;i<l;i++)
27:         {
28:             char c=s.charAt(i);
29:             if (now.next[c-97]==null) return """"; else now=now.next[c-97];
30:             if (now.word!=null) return now.word;
31:         }
32:         return """";
33:     }
34:     public String replaceWords(List<String> dict, String sentence) {
35:         TrieNode root=buildTrie(dict);
36:         String[] ss=sentence.split("" "");
37:         StringBuilder ans=new StringBuilder();
38:         boolean bo=false;
39:         for (String s:ss)
40:         {
41:             String t=find(root,s);
42:             if (t=="""") t=s;
43:             if (bo) ans.append("" "");
44:             ans.append(t);
45:             bo=true;
46:         }
47:         return ans+"""";
48:     }
49:        public static void main(String[] args) {
50:         ReplaceWords replaceWords = new ReplaceWords();
51:         
52:         List<String> dict = Arrays.asList(""cat"", ""bat"", ""rat"");
53:         String sentence = ""the cattle was rattled by the battery"";
54:         
55:         String result = replaceWords.replaceWords(dict, sentence);
56:         
57:         System.out.println(""Replaced sentence: "" + result);
58:     }
59: }","[55, 54, 53, 52, 50, 34, 35, 8, 10, 11, 12, 13, 14, 16, 17, 19, 21, 36, 37, 38, 39, 41, 23, 25, 26, 28, 29, 30, 32, 43, 44, 45, 47]","{'output': ['55', '54', '53', '52', '50', '34', '35', '8', '10', '11', '12', '13', '14', '16', '17', '19', '21', '36', '37', '38', '39', '41', '23', '25', '26', '28', '29', '30', '32', '43', '44', '45', '47']}","[55, 54, 52, 50, 34, 35, 8, 10, 11, 13, 14, 16, 17, 19, 21, 23, 25, 26, 28, 29, 30, 32, 36, 37, 38, 39, 41, 42, 43, 44, 45, 47]","{'output': ['55', '54', '52', '50', '34', '35', '8', '10', '11', '13', '14', '16', '17', '19', '21', '23', '25', '26', '28', '29', '30', '32', '36', '37', '38', '39', '41', '42', '43', '44', '45', '47']}","[55, 34, 35, 8, 10, 11, 13, 16, 17, 19, 21, 37, 39, 41, 23, 25, 26, 28, 29, 30, 43, 44, 45, 47]","{'output': ['55', '34', '35', '8', '10', '11', '13', '16', '17', '19', '21', '37', '39', '41', '23', '25', '26', '28', '29', '30', '43', '44', '45', '47']}"
"import java.util.*;
class RobotWithString {

	public String robotWithString(String s) {
		int[] min = new int[s.length()];
		for (int i = s.length() - 1; i > 0; i--) {
			min[i - 1] = Math.min(s.charAt(i), i < s.length() - 1 ? min[i] : 'z');
		}
		StringBuilder sb = new StringBuilder();
		ArrayDeque<Character> deque = new ArrayDeque<>();
		for (int i = 0; i < s.length(); i++) {
			for (deque.push(s.charAt(i)); !deque.isEmpty() && deque.peek() <= min[i];) {
				sb.append(deque.pop());
			}
		}
		while (!deque.isEmpty()) {
			sb.append(deque.pop());
		}
		return sb.toString();
	}
	 public static void main(String[] args) {
        RobotWithString robotWithString = new RobotWithString();
        
        String s = ""bac"";
        
        String result = robotWithString.robotWithString(s);
        
        System.out.println(""Resulting string: "" + result);
    }
}",RobotWithString,26,"[22, 2, 26, 5, 6, 7, 9, 10, 11, 12, 13, 16, 17, 19]","1: import java.util.*;
2: class RobotWithString {
3: 
4: 	public String robotWithString(String s) {
5: 		int[] min = new int[s.length()];
6: 		for (int i = s.length() - 1; i > 0; i--) {
7: 			min[i - 1] = Math.min(s.charAt(i), i < s.length() - 1 ? min[i] : 'z');
8: 		}
9: 		StringBuilder sb = new StringBuilder();
10: 		ArrayDeque<Character> deque = new ArrayDeque<>();
11: 		for (int i = 0; i < s.length(); i++) {
12: 			for (deque.push(s.charAt(i)); !deque.isEmpty() && deque.peek() <= min[i];) {
13: 				sb.append(deque.pop());
14: 			}
15: 		}
16: 		while (!deque.isEmpty()) {
17: 			sb.append(deque.pop());
18: 		}
19: 		return sb.toString();
20: 	}
21: 	 public static void main(String[] args) {
22:         RobotWithString robotWithString = new RobotWithString();
23:         
24:         String s = ""bac"";
25:         
26:         String result = robotWithString.robotWithString(s);
27:         
28:         System.out.println(""Resulting string: "" + result);
29:     }
30: }","[26, 24, 22, 4, 5, 6, 7, 9, 10, 11, 12, 13, 15, 16, 17, 19]","{'output': ['26', '24', '22', '4', '5', '6', '7', '9', '10', '11', '12', '13', '15', '16', '17', '19']}","[26, 24, 22, 4, 5, 6, 7, 9, 10, 11, 12, 13, 15, 16, 17, 19]","{'output': ['26', '24', '22', '4', '5', '6', '7', '9', '10', '11', '12', '13', '15', '16', '17', '19']}","[26, 24, 22, 4, 5, 6, 7, 9, 10, 11, 12, 13, 15, 16, 17, 19]","{'output': ['26', '24', '22', '4', '5', '6', '7', '9', '10', '11', '12', '13', '15', '16', '17', '19']}"
"import java.util.*;
class RotateTheBox {
    public char[][] rotateTheBox(char[][] box) {
        int n = box.length;
        int m = box[0].length;
        char[][] ans = new char[m][n];
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                ans[j][i] = box[n-i-1][j];
            }
        }
        for (int j = 0; j < n; ++j) {
            int ns = m-1;
            for (int i = m-1; i >= 0; --i) {
                if (ans[i][j]=='*') {
                    ns = i-1;
                } else if (ans[i][j]=='#') {
                    ans[i][j] = '.';
                    ans[ns][j] = '#';
                    --ns;
                }
            }
        }
        return ans;
    }
      public static void main(String[] args) {
        RotateTheBox rotateTheBox = new RotateTheBox();
        
        char[][] box = {
            {'#', '.', '#'},
            {'#', '#', '*'},
            {'#', '.', '.'}
        };
        
        char[][] result = rotateTheBox.rotateTheBox(box);
        
        System.out.println(""Rotated box:"");
        for (char[] row : result) {
            System.out.println(Arrays.toString(row));
        }
    }
}",RotateTheBox,39,"[29, 35, 4, 5, 6, 24, 37, 38, 39]","1: import java.util.*;
2: class RotateTheBox {
3:     public char[][] rotateTheBox(char[][] box) {
4:         int n = box.length;
5:         int m = box[0].length;
6:         char[][] ans = new char[m][n];
7:         for (int i = 0; i < n; ++i) {
8:             for (int j = 0; j < m; ++j) {
9:                 ans[j][i] = box[n-i-1][j];
10:             }
11:         }
12:         for (int j = 0; j < n; ++j) {
13:             int ns = m-1;
14:             for (int i = m-1; i >= 0; --i) {
15:                 if (ans[i][j]=='*') {
16:                     ns = i-1;
17:                 } else if (ans[i][j]=='#') {
18:                     ans[i][j] = '.';
19:                     ans[ns][j] = '#';
20:                     --ns;
21:                 }
22:             }
23:         }
24:         return ans;
25:     }
26:       public static void main(String[] args) {
27:         RotateTheBox rotateTheBox = new RotateTheBox();
28:         
29:         char[][] box = {
30:             {'#', '.', '#'},
31:             {'#', '#', '*'},
32:             {'#', '.', '.'}
33:         };
34:         
35:         char[][] result = rotateTheBox.rotateTheBox(box);
36:         
37:         System.out.println(""Rotated box:"");
38:         for (char[] row : result) {
39:             System.out.println(Arrays.toString(row));
40:         }
41:     }
42: }","[39, 35, 3, 4, 5, 6, 7, 8, 9, 12, 13, 14, 15, 16, 17, 18, 19, 20, 24]","{'output': ['39', '35', '3', '4', '5', '6', '7', '8', '9', '12', '13', '14', '15', '16', '17', '18', '19', '20', '24']}","[39, 35, 3, 24, 12, 6, 5, 4, 29]","{'output': ['39', '35', '3', '24', '12', '6', '5', '4', '29']}","[39, 38, 35, 27, 3]","{'output': ['39', '38', '35', '27', '3']}"
"class SellingWood {

	public long sellingWood(int m, int n, int[][] prices) {
		long[][] map = new long[m + 1][n + 1], dp = new long[m + 1][n + 1];
		for (int[] price : prices) {
			map[price[0]][price[1]] = price[2];
		}
		for (int i = 1; i <= m; i++) {
			for (int j = 1; j <= n; j++) {
				dp[i][j] = map[i][j];
				for (int k = 1; k < i; k++) {
					dp[i][j] = Math.max(dp[i][j], dp[k][j] + dp[i - k][j]);
				}
				for (int k = 1; k < j; k++) {
					dp[i][j] = Math.max(dp[i][j], dp[i][k] + dp[i][j - k]);
				}
			}
		}
		return dp[m][n];
	}
	    public static void main(String[] args) {
        SellingWood sellingWood = new SellingWood();
        
        int m = 3;
        int n = 5;
        int[][] prices = {
            {1, 4, 2},
            {2, 2, 7},
            {2, 1, 3}
        };
        
        long result = sellingWood.sellingWood(m, n, prices);
        
        System.out.println(""Maximum profit from selling wood: "" + result);
    }
}",SellingWood,32,"[22, 1, 26, 32, 4, 19]","1: class SellingWood {
2: 
3: 	public long sellingWood(int m, int n, int[][] prices) {
4: 		long[][] map = new long[m + 1][n + 1], dp = new long[m + 1][n + 1];
5: 		for (int[] price : prices) {
6: 			map[price[0]][price[1]] = price[2];
7: 		}
8: 		for (int i = 1; i <= m; i++) {
9: 			for (int j = 1; j <= n; j++) {
10: 				dp[i][j] = map[i][j];
11: 				for (int k = 1; k < i; k++) {
12: 					dp[i][j] = Math.max(dp[i][j], dp[k][j] + dp[i - k][j]);
13: 				}
14: 				for (int k = 1; k < j; k++) {
15: 					dp[i][j] = Math.max(dp[i][j], dp[i][k] + dp[i][j - k]);
16: 				}
17: 			}
18: 		}
19: 		return dp[m][n];
20: 	}
21: 	    public static void main(String[] args) {
22:         SellingWood sellingWood = new SellingWood();
23:         
24:         int m = 3;
25:         int n = 5;
26:         int[][] prices = {
27:             {1, 4, 2},
28:             {2, 2, 7},
29:             {2, 1, 3}
30:         };
31:         
32:         long result = sellingWood.sellingWood(m, n, prices);
33:         
34:         System.out.println(""Maximum profit from selling wood: "" + result);
35:     }
36: }","[32, 3, 4, 5, 6, 8, 9, 10, 11, 12, 14, 15, 19, 24, 25, 26]","{'output': ['32', '3', '4', '5', '6', '8', '9', '10', '11', '12', '14', '15', '19', '24', '25', '26']}","[32, 3, 4, 5, 6, 8, 9, 10, 11, 12, 14, 15, 19, 24, 25, 26, 27, 28, 29]","{'output': ['32', '3', '4', '5', '6', '8', '9', '10', '11', '12', '14', '15', '19', '24', '25', '26', '27', '28', '29']}","[32, 3, 4, 5, 6, 8, 9, 10, 11, 12, 14, 15, 19, 24, 25, 26, 27, 28, 29]","{'output': ['32', '3', '4', '5', '6', '8', '9', '10', '11', '12', '14', '15', '19', '24', '25', '26', '27', '28', '29']}"
"import java.util.*;
import java.math.*;

public class SequenceReconstruction {

    public boolean sequenceReconstruction(int[] org, int[][] seqs) {
        Map<Integer, List<Integer>> g = new HashMap<>();
        Map<Integer, Integer> in = new HashMap<>();
        for (int[] seq : seqs)
            for (int i : seq)
                in.putIfAbsent(i, 0);
        for (int[] seq : seqs)
            for (int i = 1; i < seq.length; i++) {
                int u = seq[i - 1], v = seq[i];
                g.putIfAbsent(u, new ArrayList<>());
                g.get(u).add(v);
                in.put(v, in.get(v) + 1);
            }
        if (org.length != in.size()) return false;

        Map<Integer, Integer> dist = new HashMap<>();
        int[] queue = new int[in.size() + 10];
        int head = 0, tail = 0;
        for (int u : in.keySet())
            if (in.get(u) == 0) {
                dist.put(u, 0);
                queue[tail++] = u;
            }
        if (tail > 1) return false;


        List<Integer> topSeq = new ArrayList<>();
        while (head < tail) {
            int u = queue[head++], d = dist.get(u);
            topSeq.add(u);
            if (head < tail && d == dist.get(queue[head])) return false;

            if (g.containsKey(u))
                for (int v : g.get(u)) {
                    in.put(v, in.get(v) - 1);
                    if (in.get(v) == 0) {
                        queue[tail++] = v;
                        dist.put(v, d + 1);
                    }
                }
        }

        if (topSeq.size() != org.length) return false;
        for (int i = 0; i < org.length; i++)
            if (org[i] != topSeq.get(i)) return false;
        return true;
    }

    public static void main(String[] args) {
        SequenceReconstruction sol = new SequenceReconstruction();
//        int[] ori = {1, 2, 3};
//        int[][] seqs = {
//                {1, 2},
//                {2, 3},
//        };
//        int[][] seqs = {
//                {1, 2},
//        };
//        int[][] seqs = {
//                {1, 2},
//                {2, 3},
//                {1, 3},
//        int[][] seqs = {
//                {1, 2},
//                {1, 3},
//        };

       int[] ori = {4, 1, 5, 2, 6, 3};
       int[][] seqs = {
               {5, 2, 6, 3},
               {4, 1, 5, 2},
       };

//        int[] ori = {};
//        int[][] seqs = {
//        };


        System.out.println(sol.sequenceReconstruction(ori, seqs));
    }
}",SequenceReconstruction,84,"[55, 4, 73, 74, 84, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 19, 22, 23, 24, 25, 26, 27, 29, 32, 33, 34, 35, 38, 39, 40, 41, 42, 48, 49, 50, 51]","1: import java.util.*;
2: import java.math.*;
3: 
4: public class SequenceReconstruction {
5: 
6:     public boolean sequenceReconstruction(int[] org, int[][] seqs) {
7:         Map<Integer, List<Integer>> g = new HashMap<>();
8:         Map<Integer, Integer> in = new HashMap<>();
9:         for (int[] seq : seqs)
10:             for (int i : seq)
11:                 in.putIfAbsent(i, 0);
12:         for (int[] seq : seqs)
13:             for (int i = 1; i < seq.length; i++) {
14:                 int u = seq[i - 1], v = seq[i];
15:                 g.putIfAbsent(u, new ArrayList<>());
16:                 g.get(u).add(v);
17:                 in.put(v, in.get(v) + 1);
18:             }
19:         if (org.length != in.size()) return false;
20: 
21:         Map<Integer, Integer> dist = new HashMap<>();
22:         int[] queue = new int[in.size() + 10];
23:         int head = 0, tail = 0;
24:         for (int u : in.keySet())
25:             if (in.get(u) == 0) {
26:                 dist.put(u, 0);
27:                 queue[tail++] = u;
28:             }
29:         if (tail > 1) return false;
30: 
31: 
32:         List<Integer> topSeq = new ArrayList<>();
33:         while (head < tail) {
34:             int u = queue[head++], d = dist.get(u);
35:             topSeq.add(u);
36:             if (head < tail && d == dist.get(queue[head])) return false;
37: 
38:             if (g.containsKey(u))
39:                 for (int v : g.get(u)) {
40:                     in.put(v, in.get(v) - 1);
41:                     if (in.get(v) == 0) {
42:                         queue[tail++] = v;
43:                         dist.put(v, d + 1);
44:                     }
45:                 }
46:         }
47: 
48:         if (topSeq.size() != org.length) return false;
49:         for (int i = 0; i < org.length; i++)
50:             if (org[i] != topSeq.get(i)) return false;
51:         return true;
52:     }
53: 
54:     public static void main(String[] args) {
55:         SequenceReconstruction sol = new SequenceReconstruction();
56: //        int[] ori = {1, 2, 3};
57: //        int[][] seqs = {
58: //                {1, 2},
59: //                {2, 3},
60: //        };
61: //        int[][] seqs = {
62: //                {1, 2},
63: //        };
64: //        int[][] seqs = {
65: //                {1, 2},
66: //                {2, 3},
67: //                {1, 3},
68: //        int[][] seqs = {
69: //                {1, 2},
70: //                {1, 3},
71: //        };
72: 
73:        int[] ori = {4, 1, 5, 2, 6, 3};
74:        int[][] seqs = {
75:                {5, 2, 6, 3},
76:                {4, 1, 5, 2},
77:        };
78: 
79: //        int[] ori = {};
80: //        int[][] seqs = {
81: //        };
82: 
83: 
84:         System.out.println(sol.sequenceReconstruction(ori, seqs));
85:     }
86: }","[84, 55, 73, 74, 75, 76]","{'output': ['84', '55', '73', '74', '75', '76']}","[84, 73, 74, 75, 76, 55, 6, 19, 48, 49, 50]","{'output': ['84', '73', '74', '75', '76', '55', '6', '19', '48', '49', '50']}","[84, 73, 74, 75, 76, 55, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 19, 21, 22, 23, 24, 25, 26, 27, 29, 32, 33, 34, 35, 36, 38, 39, 40, 41, 42, 43, 46, 48, 49, 50, 51]","{'output': ['84', '73', '74', '75', '76', '55', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '19', '21', '22', '23', '24', '25', '26', '27', '29', '32', '33', '34', '35', '36', '38', '39', '40', '41', '42', '43', '46', '48', '49', '50', '51']}"
"	import java.util.*;
	
	class ShortestPathBinaryMatrix {
	    public int shortestPathBinaryMatrix(int[][] a) {
	        int n = a.length;
	        if(a[0][0] == 1 || a[n-1][n-1] == 1)return -1;
	        int[][] d = new int[n][n];
	        for(int i = 0;i < n;i++){
	        	Arrays.fill(d[i], 999999999);
	        }
	        d[0][0] = 0;
	        Queue<int[]> q = new ArrayDeque<>();
	        q.add(new int[]{0, 0});
	        while(!q.isEmpty()){
	        	int[] cur = q.poll();
	        	int r = cur[0], c = cur[1];
	        	for(int k = -1;k <= 1;k++){
	        		for(int l = -1;l <= 1;l++){
	        			int nr = r + k, nc = c + l;
	        			if(nr >= 0 && nr < n && nc >= 0 && nc < n && a[nr][nc] == 0 && d[nr][nc] > d[r][c] + 1){
	        				d[nr][nc] = d[r][c] + 1;
	        				q.add(new int[]{nr, nc});
	        			}
	        		}
	        	}
	        }
	        if(d[n-1][n-1] > 99999)return -1;
	        return d[n-1][n-1]+1;
	    }
		public static void main(String[] args) {
        ShortestPathBinaryMatrix shortestPathBinaryMatrix = new ShortestPathBinaryMatrix();
        
        int[][] grid = {
            {0, 1},
            {1, 0}
        };
        
        int result = shortestPathBinaryMatrix.shortestPathBinaryMatrix(grid);
        
        System.out.println(""Shortest path length in binary matrix: "" + result);
    }
	}	
",ShortestPathBinaryMatrix,38,"[31, 3, 33, 38, 5, 7, 27, 28]","1: 	import java.util.*;
2: 	
3: 	class ShortestPathBinaryMatrix {
4: 	    public int shortestPathBinaryMatrix(int[][] a) {
5: 	        int n = a.length;
6: 	        if(a[0][0] == 1 || a[n-1][n-1] == 1)return -1;
7: 	        int[][] d = new int[n][n];
8: 	        for(int i = 0;i < n;i++){
9: 	        	Arrays.fill(d[i], 999999999);
10: 	        }
11: 	        d[0][0] = 0;
12: 	        Queue<int[]> q = new ArrayDeque<>();
13: 	        q.add(new int[]{0, 0});
14: 	        while(!q.isEmpty()){
15: 	        	int[] cur = q.poll();
16: 	        	int r = cur[0], c = cur[1];
17: 	        	for(int k = -1;k <= 1;k++){
18: 	        		for(int l = -1;l <= 1;l++){
19: 	        			int nr = r + k, nc = c + l;
20: 	        			if(nr >= 0 && nr < n && nc >= 0 && nc < n && a[nr][nc] == 0 && d[nr][nc] > d[r][c] + 1){
21: 	        				d[nr][nc] = d[r][c] + 1;
22: 	        				q.add(new int[]{nr, nc});
23: 	        			}
24: 	        		}
25: 	        	}
26: 	        }
27: 	        if(d[n-1][n-1] > 99999)return -1;
28: 	        return d[n-1][n-1]+1;
29: 	    }
30: 		public static void main(String[] args) {
31:         ShortestPathBinaryMatrix shortestPathBinaryMatrix = new ShortestPathBinaryMatrix();
32:         
33:         int[][] grid = {
34:             {0, 1},
35:             {1, 0}
36:         };
37:         
38:         int result = shortestPathBinaryMatrix.shortestPathBinaryMatrix(grid);
39:         
40:         System.out.println(""Shortest path length in binary matrix: "" + result);
41:     }
42: 	}	
43: ","[38, 4, 5, 6, 7, 8, 9, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 26, 27, 28, 31, 33]","{'output': ['38', '4', '5', '6', '7', '8', '9', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '26', '27', '28', '31', '33']}","[38, 31, 4, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5]","{'output': ['38', '31', '4', '28', '27', '26', '25', '24', '23', '22', '21', '20', '19', '18', '17', '16', '15', '14', '13', '12', '11', '10', '9', '8', '7', '6', '5']}","[38, 31, 4]","{'output': ['38', '31', '4']}"
"import java.util.*;

class Spellchecker {
   String changeVowel(String s) {
        StringBuilder sb = new StringBuilder();
        s = s.toLowerCase();
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == 'a' ||
                    s.charAt(i) == 'e' ||
            s.charAt(i) == 'i' ||
            s.charAt(i) == 'o' ||
            s.charAt(i) == 'u') {
                sb.append('a');
            } else {
                sb.append(s.charAt(i));
            }
        }
        return sb.toString();
    }

    public String[] spellchecker(String[] wordlist, String[] queries) {
        Map<String, String> ori = new HashMap<>();
        Map<String, String> lowerCase = new HashMap<>();
        Map<String, String> vowel = new HashMap<>();

        for (int i = 0; i < wordlist.length; i++) {
            ori.put(wordlist[i], wordlist[i]);
            String lower = wordlist[i].toLowerCase();
            if (!lowerCase.containsKey(lower)) {
                lowerCase.put(lower, wordlist[i]);
            }

            String vowelString = changeVowel(wordlist[i]);
            if (!vowel.containsKey(vowelString)) {
                vowel.put(vowelString, wordlist[i]);
            }
        }

        String[] ans = new String[queries.length];
        for (int i = 0; i < queries.length; i++) {
            if (ori.containsKey(queries[i])) {
                ans[i] = ori.get(queries[i]);
            } else if (lowerCase.containsKey(queries[i].toLowerCase())) {
                ans[i] = lowerCase.get(queries[i].toLowerCase());
            } else if (vowel.containsKey(changeVowel(queries[i]))) {
                ans[i] = vowel.get(changeVowel(queries[i]));
            } else {
                ans[i] = """";
            }
        }
        return ans;
    }
    public static void main(String[] args) {
        Spellchecker spellchecker = new Spellchecker();
        
        String[] wordlist = {""KiTe"", ""kite"", ""hare"", ""Hare""};
        String[] queries = {""kite"", ""Kite"", ""KiTe"", ""Hare"", ""HARE"", ""Hear"", ""hear"", ""keti"", ""keet"", ""keto""};
        
        String[] results = spellchecker.spellchecker(wordlist, queries);
        
        System.out.println(""Spellcheck results:"");
        for (String result : results) {
            System.out.println(result);
        }
    }
}",Spellchecker,59,"[54, 3, 56, 57, 59, 22, 23, 24, 26, 27, 28, 29, 30, 33, 5, 6, 7, 8, 9, 10, 11, 12, 15, 13, 18, 34, 35, 39, 40, 41, 42, 43, 44, 45, 48, 46, 51]","1: import java.util.*;
2: 
3: class Spellchecker {
4:    String changeVowel(String s) {
5:         StringBuilder sb = new StringBuilder();
6:         s = s.toLowerCase();
7:         for (int i = 0; i < s.length(); i++) {
8:             if (s.charAt(i) == 'a' ||
9:                     s.charAt(i) == 'e' ||
10:             s.charAt(i) == 'i' ||
11:             s.charAt(i) == 'o' ||
12:             s.charAt(i) == 'u') {
13:                 sb.append('a');
14:             } else {
15:                 sb.append(s.charAt(i));
16:             }
17:         }
18:         return sb.toString();
19:     }
20: 
21:     public String[] spellchecker(String[] wordlist, String[] queries) {
22:         Map<String, String> ori = new HashMap<>();
23:         Map<String, String> lowerCase = new HashMap<>();
24:         Map<String, String> vowel = new HashMap<>();
25: 
26:         for (int i = 0; i < wordlist.length; i++) {
27:             ori.put(wordlist[i], wordlist[i]);
28:             String lower = wordlist[i].toLowerCase();
29:             if (!lowerCase.containsKey(lower)) {
30:                 lowerCase.put(lower, wordlist[i]);
31:             }
32: 
33:             String vowelString = changeVowel(wordlist[i]);
34:             if (!vowel.containsKey(vowelString)) {
35:                 vowel.put(vowelString, wordlist[i]);
36:             }
37:         }
38: 
39:         String[] ans = new String[queries.length];
40:         for (int i = 0; i < queries.length; i++) {
41:             if (ori.containsKey(queries[i])) {
42:                 ans[i] = ori.get(queries[i]);
43:             } else if (lowerCase.containsKey(queries[i].toLowerCase())) {
44:                 ans[i] = lowerCase.get(queries[i].toLowerCase());
45:             } else if (vowel.containsKey(changeVowel(queries[i]))) {
46:                 ans[i] = vowel.get(changeVowel(queries[i]));
47:             } else {
48:                 ans[i] = """";
49:             }
50:         }
51:         return ans;
52:     }
53:     public static void main(String[] args) {
54:         Spellchecker spellchecker = new Spellchecker();
55:         
56:         String[] wordlist = {""KiTe"", ""kite"", ""hare"", ""Hare""};
57:         String[] queries = {""kite"", ""Kite"", ""KiTe"", ""Hare"", ""HARE"", ""Hear"", ""hear"", ""keti"", ""keet"", ""keto""};
58:         
59:         String[] results = spellchecker.spellchecker(wordlist, queries);
60:         
61:         System.out.println(""Spellcheck results:"");
62:         for (String result : results) {
63:             System.out.println(result);
64:         }
65:     }
66: }","[59, 54, 56, 57, 21, 22, 23, 24, 26, 27, 28, 29, 30, 33, 34, 35, 39, 40, 41, 42, 43, 44, 45, 46, 48, 50]","{'output': ['59', '54', '56', '57', '21', '22', '23', '24', '26', '27', '28', '29', '30', '33', '34', '35', '39', '40', '41', '42', '43', '44', '45', '46', '48', '50']}","[59, 53, 54, 21, 56, 57, 22, 23, 24, 26, 27, 28, 29, 30, 33, 34, 35, 39, 40, 41, 42, 43, 44, 45, 46, 48, 50]","{'output': ['59', '53', '54', '21', '56', '57', '22', '23', '24', '26', '27', '28', '29', '30', '33', '34', '35', '39', '40', '41', '42', '43', '44', '45', '46', '48', '50']}","[59, 54, 21, 22, 23, 24, 26, 27, 28, 29, 30, 33, 34, 35, 39, 40, 41, 42, 43, 44, 45, 46, 48]","{'output': ['59', '54', '21', '22', '23', '24', '26', '27', '28', '29', '30', '33', '34', '35', '39', '40', '41', '42', '43', '44', '45', '46', '48']}"
"import java.util.*;
class StrangePrinter {
    int[][][] f;
    public int strangePrinter(String s) {
        int n = s.length();
        if (n==0)
            return 0;
        
        f = new int[n][n][27];
        for (int i=0;i<n;i++)
            for (int j=0;j<n;j++)
                Arrays.fill(f[i][j], Integer.MAX_VALUE);
        return calc(s, 0, n-1, 0);
    }
    
    private int calc(String s, int lo, int hi, int color){
        if (f[lo][hi][color] != Integer.MAX_VALUE)
            return f[lo][hi][color];
        
        int res = Integer.MAX_VALUE;
        if (s.charAt(lo) == s.charAt(hi)){
            char c = s.charAt(lo);
            int idx = getIdx(c);
            int start = lo;
            while (s.charAt(start)==c && start<hi)
                start++;
            
            
            if (start==hi){
                if (idx==color)
                    res = 0;
                else
                    res = 1;
            }
            else{
                int end = hi;
                while (s.charAt(end)==c)
                    end--;
                if (color==idx)
                    res = Math.min(res, calc(s, start, end, idx));
                else
                    res = Math.min(res, calc(s, start, end, idx) + 1);
            }
        }
        
        for (int i=lo; i<hi; i++)
            res = Math.min(res, calc(s,lo,i,color) + calc(s,i+1,hi,color));
        
        f[lo][hi][color] = res;
        return res;
    }
    
    private int getIdx(char c){
        return c-'a'+1;
    }
    public static void main(String[] args) {
        StrangePrinter strangePrinter = new StrangePrinter();
        
        String s = ""aaabbb"";
        
        int result = strangePrinter.strangePrinter(s);
        
        System.out.println(""Minimum number of turns the printer needed: "" + result);
    }
}",StrangePrinter,61,"[57, 2, 61, 5, 6, 9, 13, 17, 21, 46, 47, 22, 24, 25, 29, 30, 33, 50]","1: import java.util.*;
2: class StrangePrinter {
3:     int[][][] f;
4:     public int strangePrinter(String s) {
5:         int n = s.length();
6:         if (n==0)
7:             return 0;
8:         
9:         f = new int[n][n][27];
10:         for (int i=0;i<n;i++)
11:             for (int j=0;j<n;j++)
12:                 Arrays.fill(f[i][j], Integer.MAX_VALUE);
13:         return calc(s, 0, n-1, 0);
14:     }
15:     
16:     private int calc(String s, int lo, int hi, int color){
17:         if (f[lo][hi][color] != Integer.MAX_VALUE)
18:             return f[lo][hi][color];
19:         
20:         int res = Integer.MAX_VALUE;
21:         if (s.charAt(lo) == s.charAt(hi)){
22:             char c = s.charAt(lo);
23:             int idx = getIdx(c);
24:             int start = lo;
25:             while (s.charAt(start)==c && start<hi)
26:                 start++;
27:             
28:             
29:             if (start==hi){
30:                 if (idx==color)
31:                     res = 0;
32:                 else
33:                     res = 1;
34:             }
35:             else{
36:                 int end = hi;
37:                 while (s.charAt(end)==c)
38:                     end--;
39:                 if (color==idx)
40:                     res = Math.min(res, calc(s, start, end, idx));
41:                 else
42:                     res = Math.min(res, calc(s, start, end, idx) + 1);
43:             }
44:         }
45:         
46:         for (int i=lo; i<hi; i++)
47:             res = Math.min(res, calc(s,lo,i,color) + calc(s,i+1,hi,color));
48:         
49:         f[lo][hi][color] = res;
50:         return res;
51:     }
52:     
53:     private int getIdx(char c){
54:         return c-'a'+1;
55:     }
56:     public static void main(String[] args) {
57:         StrangePrinter strangePrinter = new StrangePrinter();
58:         
59:         String s = ""aaabbb"";
60:         
61:         int result = strangePrinter.strangePrinter(s);
62:         
63:         System.out.println(""Minimum number of turns the printer needed: "" + result);
64:     }
65: }","[61, 4, 13, 5, 9, 10, 11, 12, 14, 16, 17, 20, 21, 22, 23, 24, 25, 26, 29, 30, 31, 33, 35, 36, 37, 39, 40, 42, 44, 46, 47, 49, 50, 53, 54, 59]","{'output': ['61', '4', '13', '5', '9', '10', '11', '12', '14', '16', '17', '20', '21', '22', '23', '24', '25', '26', '29', '30', '31', '33', '35', '36', '37', '39', '40', '42', '44', '46', '47', '49', '50', '53', '54', '59']}","[61, 4, 5, 6, 9, 10, 11, 12, 13, 16, 17, 20, 21, 22, 23, 24, 25, 29, 30, 31, 33, 36, 37, 39, 40, 42, 46, 47, 49, 50, 53, 54]","{'output': ['61', '4', '5', '6', '9', '10', '11', '12', '13', '16', '17', '20', '21', '22', '23', '24', '25', '29', '30', '31', '33', '36', '37', '39', '40', '42', '46', '47', '49', '50', '53', '54']}","[61, 4, 5, 6, 9, 13, 16, 17, 20, 21, 22, 23, 24, 25, 26, 29, 30, 31, 33, 35, 36, 37, 38, 39, 40, 42, 46, 47, 49, 50, 53, 54]","{'output': ['61', '4', '5', '6', '9', '13', '16', '17', '20', '21', '22', '23', '24', '25', '26', '29', '30', '31', '33', '35', '36', '37', '38', '39', '40', '42', '46', '47', '49', '50', '53', '54']}"
"import java.util.*;
	class TallestBillboard {
	    public int tallestBillboard(int[] rods) {
	    	int n = rods.length;
	    	int h = n/2;
	    	int o = 10002;
	    	int[] ls = new int[20005];
	    	Arrays.fill(ls, -99999999);
	    	for(int i = 0;i < (int)Math.pow(3, h);i++){
	    		int s = 0;
	    		int as = 0;
	    		int v = i;
	    		for(int j = 0;j < h;j++){
	    			int w = v % 3;
	    			if(w == 1){
	    			}else if(w == 0){
	    				s += rods[j];
	    				as += rods[j];
	    			}else{
	    				s -= rods[j];
	    				as += rods[j];
	    			}
	    			v /= 3;
	    		}
	    		ls[s+o] = Math.max(ls[s+o], as);
	    	}
	    	int ret = 0;
	    	for(int i = 0;i < (int)Math.pow(3, n-h);i++){
	    		int s = 0;
	    		int as = 0;
	    		int v = i;
	    		for(int j = 0;j < n-h;j++){
	    			int w = v % 3;
	    			if(w == 1){
	    			}else if(w == 0){
	    				s += rods[j+h];
	    				as += rods[j+h];
	    			}else{
	    				s -= rods[j+h];
	    				as += rods[j+h];
	    			}
	    			v /= 3;
	    		}
	    		ret = Math.max(ret, (ls[o-s] + as) / 2);
	    	}
	    	return ret;
	    }
		public static void main(String[] args) {
        TallestBillboard tallestBillboard = new TallestBillboard();
        
        int[] rods = {1, 2, 3, 6};
        
        int result = tallestBillboard.tallestBillboard(rods);
        
        System.out.println(""Tallest possible height of the billboard: "" + result);
    }
	}	
",TallestBillboard,53,"[49, 2, 51, 53, 4, 5, 7, 8, 9, 10, 11, 12, 13, 14, 16, 17, 18, 23, 25, 20, 21, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 42, 44, 39, 40, 46]","1: import java.util.*;
2: 	class TallestBillboard {
3: 	    public int tallestBillboard(int[] rods) {
4: 	    	int n = rods.length;
5: 	    	int h = n/2;
6: 	    	int o = 10002;
7: 	    	int[] ls = new int[20005];
8: 	    	Arrays.fill(ls, -99999999);
9: 	    	for(int i = 0;i < (int)Math.pow(3, h);i++){
10: 	    		int s = 0;
11: 	    		int as = 0;
12: 	    		int v = i;
13: 	    		for(int j = 0;j < h;j++){
14: 	    			int w = v % 3;
15: 	    			if(w == 1){
16: 	    			}else if(w == 0){
17: 	    				s += rods[j];
18: 	    				as += rods[j];
19: 	    			}else{
20: 	    				s -= rods[j];
21: 	    				as += rods[j];
22: 	    			}
23: 	    			v /= 3;
24: 	    		}
25: 	    		ls[s+o] = Math.max(ls[s+o], as);
26: 	    	}
27: 	    	int ret = 0;
28: 	    	for(int i = 0;i < (int)Math.pow(3, n-h);i++){
29: 	    		int s = 0;
30: 	    		int as = 0;
31: 	    		int v = i;
32: 	    		for(int j = 0;j < n-h;j++){
33: 	    			int w = v % 3;
34: 	    			if(w == 1){
35: 	    			}else if(w == 0){
36: 	    				s += rods[j+h];
37: 	    				as += rods[j+h];
38: 	    			}else{
39: 	    				s -= rods[j+h];
40: 	    				as += rods[j+h];
41: 	    			}
42: 	    			v /= 3;
43: 	    		}
44: 	    		ret = Math.max(ret, (ls[o-s] + as) / 2);
45: 	    	}
46: 	    	return ret;
47: 	    }
48: 		public static void main(String[] args) {
49:         TallestBillboard tallestBillboard = new TallestBillboard();
50:         
51:         int[] rods = {1, 2, 3, 6};
52:         
53:         int result = tallestBillboard.tallestBillboard(rods);
54:         
55:         System.out.println(""Tallest possible height of the billboard: "" + result);
56:     }
57: 	}	
58: ","[53, 51, 49, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46]","{'output': ['53', '51', '49', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '40', '41', '42', '43', '44', '45', '46']}","[53, 49, 3]","{'output': ['53', '49', '3']}","[53, 48, 49, 51, 3, 4, 5, 6, 28, 32, 33, 36, 37, 39, 40, 44, 45, 46]","{'output': ['53', '48', '49', '51', '3', '4', '5', '6', '28', '32', '33', '36', '37', '39', '40', '44', '45', '46']}"
"	class TilingRectangle {
	    public int tilingRectangle(int n, int m) {
	    	ans = 99999999;
	        boolean[][] g = new boolean[n][m];
	        dfs(0, 0, g, 0);
	        return ans;
	    }
	    
	    int ans;
	    
	    void dfs(int r, int c, boolean[][] g, int num)
	    {
	    	int n = g.length, m = g[0].length;
	    	if(num >= ans)return;
	    	if(r >= n){
	    		ans = num;
	    		return;
	    	}
	    	if(c >= m){
	    		dfs(r+1, 0, g, num); return;
	    	}
	    	if(g[r][c]){
	    		dfs(r, c+1, g, num); return;
	    	}
	    	out:
	    	for(int K = Math.min(n-r, m-c);K >= 1;K--){
	    		for(int i = 0;i < K;i++){
	    			for(int j = 0;j < K;j++){
	    				if(g[r+i][c+j])break out;
	    			}
	    		}
	    		for(int i = 0;i < K;i++){
	    			for(int j = 0;j < K;j++){
	    				g[r+i][c+j] = true;
	    			}
	    		}
	    		dfs(r, c+1, g, num+1);
	    		for(int i = 0;i < K;i++){
	    			for(int j = 0;j < K;j++){
	    				g[r+i][c+j] = false;
	    			}
	    		}
	    	}
	    }
	    
		public void tf(boolean[]... b)
		{
			for(boolean[] r : b) {
				for(boolean x : r)System.out.print(x?'#':'.');
				System.out.println();
			}
			System.out.println();
		}
		public static void main(String[] args) {
        TilingRectangle tilingRectangle = new TilingRectangle();
        
        int n = 2;
        int m = 3;
        
        int result = tilingRectangle.tilingRectangle(n, m);
        
        System.out.println(""Minimum number of squares to tile a "" + n + ""x"" + m + "" rectangle: "" + result);
    }
		
	}	
",TilingRectangle,60,"[55, 1, 60, 3, 4, 5, 13, 14, 15, 19, 22, 26, 27, 28, 29, 37, 23, 20, 16, 6]","1: 	class TilingRectangle {
2: 	    public int tilingRectangle(int n, int m) {
3: 	    	ans = 99999999;
4: 	        boolean[][] g = new boolean[n][m];
5: 	        dfs(0, 0, g, 0);
6: 	        return ans;
7: 	    }
8: 	    
9: 	    int ans;
10: 	    
11: 	    void dfs(int r, int c, boolean[][] g, int num)
12: 	    {
13: 	    	int n = g.length, m = g[0].length;
14: 	    	if(num >= ans)return;
15: 	    	if(r >= n){
16: 	    		ans = num;
17: 	    		return;
18: 	    	}
19: 	    	if(c >= m){
20: 	    		dfs(r+1, 0, g, num); return;
21: 	    	}
22: 	    	if(g[r][c]){
23: 	    		dfs(r, c+1, g, num); return;
24: 	    	}
25: 	    	out:
26: 	    	for(int K = Math.min(n-r, m-c);K >= 1;K--){
27: 	    		for(int i = 0;i < K;i++){
28: 	    			for(int j = 0;j < K;j++){
29: 	    				if(g[r+i][c+j])break out;
30: 	    			}
31: 	    		}
32: 	    		for(int i = 0;i < K;i++){
33: 	    			for(int j = 0;j < K;j++){
34: 	    				g[r+i][c+j] = true;
35: 	    			}
36: 	    		}
37: 	    		dfs(r, c+1, g, num+1);
38: 	    		for(int i = 0;i < K;i++){
39: 	    			for(int j = 0;j < K;j++){
40: 	    				g[r+i][c+j] = false;
41: 	    			}
42: 	    		}
43: 	    	}
44: 	    }
45: 	    
46: 		public void tf(boolean[]... b)
47: 		{
48: 			for(boolean[] r : b) {
49: 				for(boolean x : r)System.out.print(x?'#':'.');
50: 				System.out.println();
51: 			}
52: 			System.out.println();
53: 		}
54: 		public static void main(String[] args) {
55:         TilingRectangle tilingRectangle = new TilingRectangle();
56:         
57:         int n = 2;
58:         int m = 3;
59:         
60:         int result = tilingRectangle.tilingRectangle(n, m);
61:         
62:         System.out.println(""Minimum number of squares to tile a "" + n + ""x"" + m + "" rectangle: "" + result);
63:     }
64: 		
65: 	}	
66: ","[60, 2, 3, 4, 5, 9]","{'output': ['60', '2', '3', '4', '5', '9']}","[60, 2, 3, 4, 5, 9]","{'output': ['60', '2', '3', '4', '5', '9']}","[60, 2, 3, 4, 5, 9, 11, 13, 14, 15, 16, 19, 20, 22, 23, 25, 26, 27, 28, 29, 32, 33, 34, 37, 38, 39, 40]","{'output': ['60', '2', '3', '4', '5', '9', '11', '13', '14', '15', '16', '19', '20', '22', '23', '25', '26', '27', '28', '29', '32', '33', '34', '37', '38', '39', '40']}"
"import java.util.*;
	class VideoStitching {
	    public int videoStitching(int[][] clips, int T) {
	        int[] dp = new int[T+1];
	        int I = Integer.MAX_VALUE / 2;
	        Arrays.fill(dp, I);
	        dp[0] = 0;
	        for(int i = 0;i < T;i++){
	        	for(int[] c : clips){
	        		if(c[0] == i){
	        			dp[Math.min(c[1], T)] = Math.min(
	        					dp[Math.min(c[1], T)],
	        					dp[i] + 1
	        					);
	        		}
	        	}
	        	for(int j = T-1;j >= 0;j--){
	        		dp[j] = Math.min(dp[j], dp[j+1]);
	        	}
	        }
	        return dp[T] < I ? dp[T] : -1;
	    }
		public static void main(String[] args) {
        VideoStitching videoStitching = new VideoStitching();
        
        int[][] clips = {
            {0, 2},
            {4, 6},
            {8, 10},
            {1, 9},
            {1, 5},
            {5, 9}
        };
        int T = 10;
        
        int result = videoStitching.videoStitching(clips, T);
        
        System.out.println(""Minimum number of clips to cover the entire interval [0, "" + T + ""]: "" + result);
    }
	}	
",VideoStitching,36,"[24, 2, 26, 36, 4, 6, 7, 8, 9, 11, 12, 17, 18, 21]","1: import java.util.*;
2: 	class VideoStitching {
3: 	    public int videoStitching(int[][] clips, int T) {
4: 	        int[] dp = new int[T+1];
5: 	        int I = Integer.MAX_VALUE / 2;
6: 	        Arrays.fill(dp, I);
7: 	        dp[0] = 0;
8: 	        for(int i = 0;i < T;i++){
9: 	        	for(int[] c : clips){
10: 	        		if(c[0] == i){
11: 	        			dp[Math.min(c[1], T)] = Math.min(
12: 	        					dp[Math.min(c[1], T)],
13: 	        					dp[i] + 1
14: 	        					);
15: 	        		}
16: 	        	}
17: 	        	for(int j = T-1;j >= 0;j--){
18: 	        		dp[j] = Math.min(dp[j], dp[j+1]);
19: 	        	}
20: 	        }
21: 	        return dp[T] < I ? dp[T] : -1;
22: 	    }
23: 		public static void main(String[] args) {
24:         VideoStitching videoStitching = new VideoStitching();
25:         
26:         int[][] clips = {
27:             {0, 2},
28:             {4, 6},
29:             {8, 10},
30:             {1, 9},
31:             {1, 5},
32:             {5, 9}
33:         };
34:         int T = 10;
35:         
36:         int result = videoStitching.videoStitching(clips, T);
37:         
38:         System.out.println(""Minimum number of clips to cover the entire interval [0, "" + T + ""]: "" + result);
39:     }
40: 	}	
41: ","[36, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 23, 24, 26, 27, 28, 29, 30, 31, 32, 34]","{'output': ['36', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '23', '24', '26', '27', '28', '29', '30', '31', '32', '34']}","[36, 34, 26, 27, 28, 29, 30, 31, 32, 3]","{'output': ['36', '34', '26', '27', '28', '29', '30', '31', '32', '3']}","[36, 23, 24, 3, 21, 20, 18, 17, 8, 4, 5, 6, 7, 11, 12, 13, 10, 9]","{'output': ['36', '23', '24', '3', '21', '20', '18', '17', '8', '4', '5', '6', '7', '11', '12', '13', '10', '9']}"
"import java.util.*;
class WatchedVideosByFriends {
    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {
        int n = friends.length;
        Deque<Integer> q = new ArrayDeque<>();
        boolean[] visited = new boolean[n];
        Map<String, Integer> freq = new HashMap<>();
        
        int dist = 0;
        q.addLast(id);
        visited[id] = true;
        while (!q.isEmpty()) {
            int size = q.size();
            for (int i = 0; i < size; i++) {
                int u = q.removeFirst();
                if (dist == level) {
                    for (String video : watchedVideos.get(u)) {
                        freq.put(video, freq.getOrDefault(video, 0) + 1);
                    }
                }
                for (int v : friends[u]) {
                    if (!visited[v]) {
                        visited[v] = true;
                        q.addLast(v);
                    }
                }
            }
            if (dist == level) break;
            dist++;
        }
        List<String> ans = new ArrayList<>(freq.keySet());
        Collections.sort(ans, (String s1,String s2) -> {
            if (freq.get(s1) == freq.get(s2)) {
                return s1.compareTo(s2);
            }
            return Integer.compare(freq.get(s1), freq.get(s2));
        });
        return ans;
    }
    public static void main(String[] args) {
        WatchedVideosByFriends watchedVideosByFriends = new WatchedVideosByFriends();
        
        List<List<String>> watchedVideos = new ArrayList<>();
        watchedVideos.add(Arrays.asList(""A"", ""B""));
        watchedVideos.add(Arrays.asList(""C""));
        watchedVideos.add(Arrays.asList(""B"", ""C""));
        watchedVideos.add(Arrays.asList(""D""));
        
        int[][] friends = {
            {1, 2},
            {0, 3},
            {0, 3},
            {1, 2}
        };
        
        int id = 0;
        int level = 1;
        
        List<String> result = watchedVideosByFriends.watchedVideosByFriends(watchedVideos, friends, id, level);
        
        System.out.println(""Videos watched by friends at level "" + level + "": "" + result);
    }
}",WatchedVideosByFriends,59,"[41, 2, 43, 44, 45, 46, 47, 49, 59, 4, 5, 6, 7, 10, 11, 12, 13, 14, 15, 21, 22, 23, 24, 17, 18, 31, 32, 38]","1: import java.util.*;
2: class WatchedVideosByFriends {
3:     public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {
4:         int n = friends.length;
5:         Deque<Integer> q = new ArrayDeque<>();
6:         boolean[] visited = new boolean[n];
7:         Map<String, Integer> freq = new HashMap<>();
8:         
9:         int dist = 0;
10:         q.addLast(id);
11:         visited[id] = true;
12:         while (!q.isEmpty()) {
13:             int size = q.size();
14:             for (int i = 0; i < size; i++) {
15:                 int u = q.removeFirst();
16:                 if (dist == level) {
17:                     for (String video : watchedVideos.get(u)) {
18:                         freq.put(video, freq.getOrDefault(video, 0) + 1);
19:                     }
20:                 }
21:                 for (int v : friends[u]) {
22:                     if (!visited[v]) {
23:                         visited[v] = true;
24:                         q.addLast(v);
25:                     }
26:                 }
27:             }
28:             if (dist == level) break;
29:             dist++;
30:         }
31:         List<String> ans = new ArrayList<>(freq.keySet());
32:         Collections.sort(ans, (String s1,String s2) -> {
33:             if (freq.get(s1) == freq.get(s2)) {
34:                 return s1.compareTo(s2);
35:             }
36:             return Integer.compare(freq.get(s1), freq.get(s2));
37:         });
38:         return ans;
39:     }
40:     public static void main(String[] args) {
41:         WatchedVideosByFriends watchedVideosByFriends = new WatchedVideosByFriends();
42:         
43:         List<List<String>> watchedVideos = new ArrayList<>();
44:         watchedVideos.add(Arrays.asList(""A"", ""B""));
45:         watchedVideos.add(Arrays.asList(""C""));
46:         watchedVideos.add(Arrays.asList(""B"", ""C""));
47:         watchedVideos.add(Arrays.asList(""D""));
48:         
49:         int[][] friends = {
50:             {1, 2},
51:             {0, 3},
52:             {0, 3},
53:             {1, 2}
54:         };
55:         
56:         int id = 0;
57:         int level = 1;
58:         
59:         List<String> result = watchedVideosByFriends.watchedVideosByFriends(watchedVideos, friends, id, level);
60:         
61:         System.out.println(""Videos watched by friends at level "" + level + "": "" + result);
62:     }
63: }","[59, 41, 43, 44, 45, 46, 47, 49, 50, 51, 52, 53, 56, 57]","{'output': ['59', '41', '43', '44', '45', '46', '47', '49', '50', '51', '52', '53', '56', '57']}","[59, 57, 56, 49, 48, 47, 46, 45, 44, 43, 42, 41]","{'output': ['59', '57', '56', '49', '48', '47', '46', '45', '44', '43', '42', '41']}","[59, 57, 56, 43, 49, 41]","{'output': ['59', '57', '56', '43', '49', '41']}"
"
    public class MinSumSquareOff {

        public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {
            long nums[] = new long[nums1.length], left = 0, right = 1000000000, count = 0, result = 0;
            for (int i = 0; i < nums1.length; i++) {
                nums[i] = Math.abs(nums1[i] - nums2[i]);
            }
            while (left < right) {
                long mid = (left + right) / 2, sum = 0;
                for (long num : nums) {
                    sum += Math.max(0, num - mid);
                }
                if (sum > k1 + k2) {
                    left = mid + 1;
                } else {
                    right = mid;
                    count = k1 + k2 - sum;
                }
            }
            for (long num : nums) {
                result += Math.pow(num < left ? num : left - Math.min(1, Math.max(0, count--)), 2);
            }
            return left > 0 ? result : 0;
        }

        public static void main(String[] args) {
            int[] nums1 = {1, 2, 3, 4};
            int[] nums2 = {2, 3, 4, 5};
            int k1 = 1;
            int k2 = 2;

            MinSumSquareOff solution = new MinSumSquareOff();

            long result = solution.minSumSquareDiff(nums1, nums2, k1, k2);

            System.out.println(""Minimum Sum of Squared Differences: "" + result);
        }
    }
    ",MinSumSquareOff,34,"[27, 28, 32, 1, 34, 4, 5, 6, 8, 9, 10, 11, 13, 16, 17, 14, 20, 21, 23]",,[],"content='It seems that the provided Java code snippet is missing as it says ""nan"" (not a number). To perform backward dynamic slicing, I need the actual Java code to analyze it and determine the relevant lines.\n\nPlease provide the complete Java code snippet, and I\'ll be able to generate the slicing output for the given criterion.' response_metadata={'token_usage': {'completion_tokens': 64, 'prompt_tokens': 183, 'total_tokens': 247}, 'model_name': 'gpt-4o-2024-05-13', 'system_fingerprint': 'fp_25624ae3a5', 'finish_reason': 'stop', 'logprobs': None} id='run-cf360e06-0554-4f28-b4b1-40837f40f725-0' usage_metadata={'input_tokens': 183, 'output_tokens': 64, 'total_tokens': 247}",[],"content='It appears that the provided Java program is missing. Please provide the Java code snippet along with the slicing criterion so that I can perform the backward dynamic slicing and generate the required output.' response_metadata={'token_usage': {'completion_tokens': 36, 'prompt_tokens': 183, 'total_tokens': 219}, 'model_name': 'gpt-4o-2024-05-13', 'system_fingerprint': 'fp_25624ae3a5', 'finish_reason': 'stop', 'logprobs': None} id='run-90994f39-2046-493b-8756-2ef159bb976b-0' usage_metadata={'input_tokens': 183, 'output_tokens': 36, 'total_tokens': 219}",[],"content=""It appears that the provided Java program is missing or wasn't included in your message. Without the actual Java program, it is not possible to perform backward dynamic slicing or to determine which lines influence the Slicing Criterion at line number 34.\n\nCould you please provide the Java program with line numbers so that I can assist you in generating the required output?"" response_metadata={'token_usage': {'completion_tokens': 69, 'prompt_tokens': 183, 'total_tokens': 252}, 'model_name': 'gpt-4o-2024-05-13', 'system_fingerprint': 'fp_25624ae3a5', 'finish_reason': 'stop', 'logprobs': None} id='run-a60c719c-8807-46f4-891d-3a062159190a-0' usage_metadata={'input_tokens': 183, 'output_tokens': 69, 'total_tokens': 252}"
